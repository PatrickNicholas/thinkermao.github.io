<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato | Open Sans:300,300italic,400,400italic,700,700italic|Courier New bold:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=5.1.4">







  <meta name="keywords" content="Blog, Hashcoding.net, C++, GO, Java, Destribute, 分布式, 存储">





  <link rel="alternate" href="/atom.xml" title="Coding" type="application/atom+xml">






<meta name="description" content="C++, Go, 编译器, 分布式, 存储, 操作系统">
<meta property="og:type" content="website">
<meta property="og:title" content="Coding">
<meta property="og:url" content="http://www.hashcoding.net/index.html">
<meta property="og:site_name" content="Coding">
<meta property="og:description" content="C++, Go, 编译器, 分布式, 存储, 操作系统">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coding">
<meta name="twitter:description" content="C++, Go, 编译器, 分布式, 存储, 操作系统">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.hashcoding.net/">





  <title>Coding - 纸上得来终觉浅，绝知此事要躬行</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4c84227c882bfc8efa4a1edc9bc8f47e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">纸上得来终觉浅，绝知此事要躬行</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2019/01/26/Linux-TCP-Rst/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/26/Linux-TCP-Rst/" itemprop="url">探究 Linux 下 TCP 的 RST Packet</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-26T15:13:00+08:00">
                2019-01-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/26/Linux-TCP-Rst/" class="leancloud_visitors" data-flag-title="探究 Linux 下 TCP 的 RST Packet">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>注：<strong>本文结论来自网络，真实性未考究，请批判性阅读，如果谬误，请斧正。</strong>本文所讨论内容，均假设工作环境为 Linux 服务器。</p>
</blockquote>
<p>作为 TCP 不可或缺的一部分，TCP 包头的 <code>RST</code> 为 $1$ 时，表示重置，关闭异常链接。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 <code>RST</code> 包。而接收端收到 <code>RST</code> 包后，也不必发送 <code>ACK</code> 包来确认。TCP 处理程序会在自己认为的异常时刻发送 <code>RST</code> 包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0</span><br></pre></td></tr></table></figure>
<p><em>通过 tcpdump 观察，<code>Flags [R]</code> 表示该包携带了 <code>RST</code> 。</em></p>
<p><code>RST</code> 主要用在三种场景中，保证 TCP 链接的安全性，三种场景分别是：1、到不存在端口的连接请求；2、异常终止连接；3、检测半打开连接。接下来看看 <code>RST</code> 的具体表现。</p>
<h1 id="三种错误"><a href="#三种错误" class="headerlink" title="三种错误"></a>三种错误</h1><p>内核中的 TCP 协议栈将收到 <code>RST</code> 的场景分为三种，并抛出了对应的错误。</p>
<h2 id="connection-refused"><a href="#connection-refused" class="headerlink" title="connection refused"></a>connection refused</h2><p>当内核中的 TCP 协议栈收到了 <code>SYN</code> 请求，但是该端口上没有处于监听状态，则相应 <code>RST</code>，此时 client 看到的便是 <code>connection refused</code>。</p>
<h2 id="broken-pipe"><a href="#broken-pipe" class="headerlink" title="broken pipe"></a>broken pipe</h2><blockquote>
<p><code>fd</code> is connected to a pipe or socket whose reading end is closed.  When this happens the writing process will also receive a SIGPIPE signal.(Thus, the write return value is seen only if the program catches, blocks or ignores this signal.)</p>
</blockquote>
<p>简单的说，如果<strong>已知</strong>远端读通道已经被关闭，而应用程序仍然在调用 <code>write</code>(2) 尝试向 socket 中写入数据，TCP 协议栈便会抛出 <code>broken pipe</code>。</p>
<h2 id="connection-reset-by-peer"><a href="#connection-reset-by-peer" class="headerlink" title="connection reset by peer"></a>connection reset by peer</h2><blockquote>
<p>A network connection was closed for reasons outside the control of the local host, such as by the remote machine rebooting or an unrecoverable protocol violation.</p>
</blockquote>
<p>如果远端已经 <code>close</code>(2) 连接了，本地服务仍发送了数据，此时 TCP 协议栈便会抛出 <code>connection reset by peer</code>。</p>
<h1 id="broken-pipe-和-connection-reset-by-peer"><a href="#broken-pipe-和-connection-reset-by-peer" class="headerlink" title="broken pipe 和 connection reset by peer"></a>broken pipe 和 connection reset by peer</h1><p>无论是 <code>broken pipe</code> 还是 <code>connection reset by peer</code>，都是收到 <code>RST</code> 的表现，二者有何不同呢？</p>
<p>为了进一步研究，这里尝试着构建两个场景，分别重现 <code>broken pipe</code> 和 <code>connection reset by peer</code>。</p>
<h2 id="重现-broken-pipe"><a href="#重现-broken-pipe" class="headerlink" title="重现 broken pipe"></a>重现 broken pipe</h2><p>首先，在服务中监听端口，每个连接分多次写入数据，然后关闭连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    InetAddress address = InetAddress::parseV4(<span class="string">"127.0.0.1"</span>, <span class="number">9490</span>);</span><br><span class="line">    acceptor.bind(address);</span><br><span class="line">    acceptor.listen(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *msg1 = <span class="string">"hello"</span>, *msg2 = <span class="string">"world"</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Connection conn = acceptor.accept();</span><br><span class="line">        sleep(<span class="number">1</span>);                        <span class="comment">// wait client shutdown</span></span><br><span class="line">        conn.write(msg1, <span class="built_in">strlen</span>(msg1));  <span class="comment">// write success, but RST recieved</span></span><br><span class="line">        conn.write(msg2, <span class="built_in">strlen</span>(msg2));  <span class="comment">// throw `broken pipe`</span></span><br><span class="line">    &#125; <span class="comment">// RAII close conn socket</span></span><br><span class="line">&#125; <span class="comment">// RAII close acceptor socket</span></span><br></pre></td></tr></table></figure>
<p>然后客户端连接到服务端，并立即关闭连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connector connector = Socket::create(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    InetAddress address = InetAddress::parseV4(<span class="string">"127.0.0.1"</span>, <span class="number">9490</span>);</span><br><span class="line">    connector.connect(address);</span><br><span class="line">&#125; <span class="comment">// RAII close connector socket</span></span><br></pre></td></tr></table></figure>
<p>通过 tcpdump 观察程序运行时请求：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo tcpdump -i lo '(src host 127.0.0.1) and (port 9490)'  -B 4096</span><br><span class="line">14:59:13.376906 IP localhost.62412 &gt; localhost.9490: Flags [S], seq 4127385760, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 0,nop,wscale 10], length 0</span><br><span class="line">14:59:13.376919 IP localhost.9490 &gt; localhost.62412: Flags [S.], seq 2306780414, ack 4127385761, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 168040030,nop,wscale 10], length 0</span><br><span class="line">14:59:13.376928 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0</span><br><span class="line">14:59:13.377089 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 1:2, ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 1</span><br><span class="line">14:59:13.377223 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 2, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0</span><br><span class="line">14:59:14.377352 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 2:3, ack 1, win 43, options [nop,nop,TS val 168040280 ecr 168040030], length 1</span><br><span class="line">14:59:14.377439 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 3, win 43, options [nop,nop,TS val 168040280 ecr 168040280], length 0</span><br><span class="line">// ....</span><br><span class="line">14:59:22.379462 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 10:11, ack 1, win 43, options [nop,nop,TS val 168042281 ecr 168042031], length 1</span><br><span class="line">14:59:22.379489 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0</span><br><span class="line">14:59:22.379626 IP localhost.62412 &gt; localhost.9490: Flags [F.], seq 1, ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0</span><br><span class="line">14:59:22.382190 IP localhost.9490 &gt; localhost.62412: Flags [.], ack 2, win 43, options [nop,nop,TS val 168042282 ecr 168042281], length 0</span><br><span class="line">14:59:23.379808 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 11:12, ack 2, win 43, options [nop,nop,TS val 168042531 ecr 168042281], length 1</span><br><span class="line">14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0</span><br></pre></td></tr></table></figure>
<p><em>上述 log 为实验过程中，和上面上面的代码略有出入。</em></p>
<p>可以观察到，client <code>close</code>(2)，发送了 <code>FIN</code> 给 server，并收到了 <code>ACK</code>。server 此时再次尝试 <code>write</code>(2)，便抛出了 <code>broken pipe</code> 异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> server();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><code>server</code> 调用方式。</em></p>
<h3 id="SIGPIPE-与-broken-pipe"><a href="#SIGPIPE-与-broken-pipe" class="headerlink" title="SIGPIPE 与 broken pipe"></a>SIGPIPE 与 broken pipe</h3><p>按照预期，当 socket 抛出 <code>broken pipe</code> 时，会被最外层 <code>try</code> 和 <code>catch</code> 抓住，并输出。实际上运行结果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./server</span><br><span class="line"><span class="meta">$</span> </span><br><span class="line"><span class="meta">$</span> echo $?</span><br><span class="line">141</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<p><em>某次 server 端运行结果，没有任何输出，程序返回值为 $141$。</em></p>
<p>内核中 TCP 栈如果已经接收到 <code>RST</code>，那么下一次使用 <code>write</code>(2) 时，除了会返回 <code>broken pipe</code> 外，还会产生 <code>SIGPIPE</code>，默认情况下这个信号会终止整个进程，当然你并不想让进程被 <code>SIGPIPE</code> 信号杀死。对 server 来说，为了不被 <code>SIGPIPE</code> 信号杀死，那就需要忽略 <code>SIGPIPE</code> 信号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGPIPE, SIG_IGN);</span><br></pre></td></tr></table></figure>
<p>最后，让我们整体分析下 <code>broken pipe</code> 产生方式：</p>
<ol>
<li>client 发送了 <code>FIN</code> 给 server；</li>
<li>server 仍给 client 发送数据，client 回复 <code>RST</code>；</li>
<li>server 收到 <code>RST</code> 后，再次给 client 发送数据；往一个已经收到 <code>RST</code> 的 socket 继续写入数据，将引起 <code>SIGPIPE</code> 信号，<code>write</code>(2) 返回 <code>EPIPE</code>。</li>
</ol>
<h2 id="重现-connection-reset-by-peer"><a href="#重现-connection-reset-by-peer" class="headerlink" title="重现 connection reset by peer"></a>重现 <code>connection reset by peer</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    InetAddress address = InetAddress::parseV4(<span class="string">"127.0.0.1"</span>, <span class="number">9490</span>);</span><br><span class="line">    acceptor.bind(address);</span><br><span class="line">    acceptor.listen(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Connection conn = acceptor.accept();</span><br><span class="line">        sleep(<span class="number">10</span>);                       <span class="comment">// 给拔网线留下足够的时间</span></span><br><span class="line">    &#125; <span class="comment">// RAII close conn socket</span></span><br><span class="line">&#125; <span class="comment">// RAII close acceptor socket</span></span><br></pre></td></tr></table></figure>
<p><em>模拟服务端断线重启。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connector connector = Socket::create(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    InetAddress address = InetAddress::parseV4(<span class="string">"127.0.0.1"</span>, <span class="number">9490</span>);</span><br><span class="line">    connector.connect(address);</span><br><span class="line">    sleep(<span class="number">120</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="string">"hello"</span>;</span><br><span class="line">    connector.write(msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">&#125; <span class="comment">// RAII close connector socket</span></span><br></pre></td></tr></table></figure>
<p><em>一段时间后，再给服务器发送请求，此时服务器已经重启。</em></p>
<p>这里构造了这样一个场景，与客户端建立连接后，服务端由于不可抗力，比如断电，未能发送 <code>FIN</code> 给客户端。当服务器重启后，内核中 TCP 协议栈收到了客户端的数据包，回应 <code>RST</code>，此时客户端抛出 <code>connection reset by peer</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo tcpdump -i lo '(src host 127.0.0.1) and (port 9490)'  -B 4096</span><br><span class="line">15:43:12.638464 IP localhost.21316 &gt; localhost.9490: Flags [S], seq 3640034867, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 0,nop,wscale 10], length 0</span><br><span class="line">15:43:12.638478 IP localhost.9490 &gt; localhost.21316: Flags [S.], seq 485213568, ack 3640034868, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 168699846,nop,wscale 10], length 0</span><br><span class="line">15:43:16.639791 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 5:6, ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700596], length 1</span><br><span class="line">15:43:16.639807 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700846], length 0</span><br><span class="line">15:43:17.640127 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 6:7, ack 6, win 43, options [nop,nop,TS val 168701096 ecr 168700846], length 1</span><br><span class="line">15:43:17.640137 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 7, win 43, options [nop,nop,TS val 168701096 ecr 168701096], length 0</span><br><span class="line">15:43:18.170130 IP localhost.9490 &gt; localhost.21316: Flags [R.], seq 7, ack 6, win 43, options [nop,nop,TS val 168701228 ecr 168701096], length 0</span><br></pre></td></tr></table></figure>
<p><em>某次模拟 <code>connection reset by peer</code>。</em></p>
<hr>
<p>这里从读写两个角度来看 <code>RST</code>，如果已经 <code>ACK</code> 远端的 <code>FIN</code> 包：</p>
<ol>
<li><code>read</code>(2) ：返回 0，表示 eof；</li>
<li><code>write</code>(2) ：远端返回 <code>RST</code>，抛出 <code>broken pipe</code>；</li>
</ol>
<p>如果尚未接收到远端的 <code>FIN</code> 包，无论读写操作，收到 <code>RST</code> 时，抛出 <code>connection reset by peer</code>。</p>
<h2 id="what-more-？"><a href="#what-more-？" class="headerlink" title="what more ？"></a>what more ？</h2><p>除了上述几个场景外，还有其他可能吗？</p>
<h3 id="强行关闭"><a href="#强行关闭" class="headerlink" title="强行关闭"></a>强行关闭</h3><p>正常关闭 TCP 链接时，主动关闭一方会进入 <code>TIME_WAIT</code> 状态，等待 2MSL（报文段最大生存时间-Maximum Segment Lifetime，根据具体的实现不同，这个值会不同），此时该端口处于不可用状态。</p>
<p>解决 <code>TIME_WAIT</code> 有三种手段：</p>
<ol>
<li>设置 <code>SO_REUSEADDR</code> 和 <code>SO_REUSEPORT</code>；</li>
<li>修改 <code>TIME_WAIT</code> 等待时长；</li>
<li>设置 <code>SO_LINGER</code>，强行关闭。</li>
</ol>
<p>设置 socket 选项 <code>SO_LINGER</code> 为 <code>(on, 0)</code> 后，<code>close</code>(2) 将立即向对端发送 <code>RST</code>，这种关闭方式称为“强行关闭”。而被动关闭方却不知道对端已经彻底断开，所以紧接着的读写操作，引发 <code>connection reset by peer</code>。</p>
<h3 id="数据滞留"><a href="#数据滞留" class="headerlink" title="数据滞留"></a>数据滞留</h3><p>socket 关闭时，如果接收窗口仍有数据滞留，那么会直接发送 <code>RST</code> ，不会进入正常的 <code>FIN</code> 流程。可以参考：<a href="http://cs.ecs.baylor.edu/~donahoo/practical/CSockets/TCPRST.pdf" target="_blank" rel="noopener">TCP RST: Calling close() on a socket with data in the receive queue</a>。</p>
<p>和“强行关闭”一样，数据滞留也会导致被动关闭方引发 <code>connection reset by peer</code>，这样造成的结果是：如果你的服务各种指标正常，但是有非常多的 <code>connection reset by peer</code> 警告，可能就是服务上游超时 <code>close</code>(2) socket，而由于接收窗口仍有数据滞留，发送了 <code>RST</code>。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="http://www.hashcoding.net/2017/05/26/Linux-TCP-%E7%BC%96%E7%A8%8B/">Linux TCP 编程</a></p>
<p>[2] <a href="http://senlinzhan.github.io/2017/03/02/sigpipe/" target="_blank" rel="noopener">网络编程中 SIGPIPE 信号</a></p>
<p>[3] <a href="http://xiangruix.com/2016/01/12/tcp-closed-without-fin/" target="_blank" rel="noopener">Linux 下 TCP 连接断开未发送 FIN</a></p>
<p>[4] <a href="http://itindex.net/detail/56132-tcp-time-wait" target="_blank" rel="noopener">TCP关闭连接(为什么会能Time_wait,Close_wait?)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2019/01/03/nsq-read-notes/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/nsq-read-notes/" itemprop="url">nsq read notes</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-03T08:00:00+08:00">
                2019-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/消息中间件/" itemprop="url" rel="index">
                    <span itemprop="name">消息中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/03/nsq-read-notes/" class="leancloud_visitors" data-flag-title="nsq read notes">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="nsqd"><a href="#nsqd" class="headerlink" title="nsqd"></a>nsqd</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">topicMap <span class="keyword">map</span>[<span class="keyword">string</span>]*Topic</span><br><span class="line">clientMap <span class="keyword">map</span>[id]*Client</span><br></pre></td></tr></table></figure>
<h2 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h2><ol>
<li>new</li>
<li>load meta data</li>
<li>persist meta data</li>
<li>main<ol>
<li>listen tcp &amp; http port, start server</li>
<li>start queueScanLoop, lookupLoop, statsLoop</li>
</ol>
</li>
</ol>
<p>有新连接到达时，会生成 connection 的 client，保存到 nsqd 的 clientMap 中，同时启动 goroutine 负责 client 的 messagePump。conn 所在的 goroutine 之后会负责读客户端的命令，并执行以及返回结果。可执行命令如下：</p>
<ol>
<li>IDENTIFY: 表名身份</li>
<li>FIN: 在 client 绑定的 channel 上，完成一条消息（调用 channel.FinishMessage），同时会更新当前 client 的 metrics 信息，以及状态</li>
<li>RDY: 更新 client ready count</li>
<li>REQ: 在 client 绑定的 channel 上，把一条消息重新送入队列（调用 channel.RequeueMessage），同时更新 metrics 和状态。这条消息会被放入 defered 队列，延后执行</li>
<li>PUB: 往某个 client 有权限的 topic 发送一条消息（调用 topic.PutMessage），更新 metrics 状态</li>
<li>MPUB: 和 PUB 一样，不过接收多条消息</li>
<li>DPUB: 和 PUB 一样，不过会被放入 defered 队列</li>
<li>NOP: 最简单，啥也不干</li>
<li>TOUCH: 在 client 绑定的 channel 上，重置一条消息的过期时间（调用 channel.TouchMessage)</li>
<li>SUB: 将 client 绑定到 channel 上，如果 topic 和 channel 任一个属于 “”, 且 topic 或 channel 正在关闭， client 会不断重试绑定操作。</li>
<li>CLS: 关闭连接</li>
<li>AUTH: 授权</li>
</ol>
<p>client 有多种状态：init, disconnect, connect, subscribe, closing ，状态迁移由一系列命令执行顺序决定。除此外还有 ready 状态，client 通过 RDY 更新了自己的 ready count，表示 client 最多同时处理多少条消息，如果 inflight count &gt;= ready count，则未 ready，需要等待。</p>
<p>client 使用 SUB 进入 subscribe 模式，该模式只能进入一次，进入后 messagePumb 会接收到 subEvent，然后从对应 channel 中读取 message 发送到 client 里。</p>
<h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">messageChan <span class="keyword">chan</span> *Message</span><br><span class="line">backendChan BackendChan</span><br><span class="line">channelsMap <span class="keyword">map</span>[<span class="keyword">string</span>]Channels</span><br></pre></td></tr></table></figure>
<h3 id="topic-创建流程"><a href="#topic-创建流程" class="headerlink" title="topic 创建流程"></a>topic 创建流程</h3><ol>
<li>new topic, save to topicMap</li>
<li>lookup each lookupd, get all channels in topic $TOPIC</li>
<li>skip “#ephemeral” and create channels</li>
<li>start topic messagePump</li>
</ol>
<h3 id="delete-channel"><a href="#delete-channel" class="headerlink" title="delete channel"></a>delete channel</h3><ol>
<li>remove from topic channelsMap</li>
<li>mark channel deleted</li>
<li>if left channels is zero, and topic is ephemeral, delete topic self</li>
</ol>
<h3 id="put-messages"><a href="#put-messages" class="headerlink" title="put messages"></a>put messages</h3><ol>
<li>try put message into memory message channel</li>
<li>fallthrough into backend queue, most case into disk, but ephemeral just ignore</li>
<li>update message count</li>
</ol>
<h3 id="message-pump"><a href="#message-pump" class="headerlink" title="message pump"></a>message pump</h3><ol>
<li>read message from memory message channel</li>
<li>else read from backend message</li>
<li>else update channel status</li>
<li>copy memory into each channels in current topic<ol>
<li>if message is defered, put into channels defered</li>
<li>else put into normal channels</li>
</ol>
</li>
</ol>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clients <span class="keyword">map</span>[<span class="keyword">string</span>]Consumer</span><br><span class="line">backend BackendQueue</span><br><span class="line">memoryChan <span class="keyword">chan</span> *Message</span><br><span class="line">deferedMessages <span class="keyword">map</span>[MessageID]*Message</span><br><span class="line">defredPQ PriorityQueue</span><br><span class="line">inFlightMessages <span class="keyword">map</span>[MessageID]*Message</span><br><span class="line">inFlightPQ PriorityQueue</span><br></pre></td></tr></table></figure>
<p>channel put message 和 topic put message 类似。put defered message 会把 message 放在deferedMessages 中，并加入 deferedPQ 中。如果 defered 时间到了，使用正常流程 put。clients 提供了 Add 和 Remove 接口，但管理职责不是 channel 的。</p>
<h1 id="nsqlookupd"><a href="#nsqlookupd" class="headerlink" title="nsqlookupd"></a>nsqlookupd</h1><h2 id="nsqlookupd-数据组织方式"><a href="#nsqlookupd-数据组织方式" class="headerlink" title="nsqlookupd 数据组织方式"></a>nsqlookupd 数据组织方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#123;<span class="string">"client"</span>, <span class="string">""</span>, <span class="string">""</span>&#125; =&gt; &#123;</span><br><span class="line">		<span class="string">"127.0.0.1:9490"</span> =&gt; Producer&#123;<span class="string">"127.0.0.1:8081"</span>&#125;,</span><br><span class="line">		<span class="string">"127.0.0.1:9491"</span> =&gt; Producer&#123;<span class="string">"127.0.0.1:8081"</span>&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&#123;<span class="string">"channel"</span>, <span class="string">"topic_a"</span>, <span class="string">"channel_a"</span>&#125; =&gt; &#123;</span><br><span class="line">		<span class="string">"ip1"</span> =&gt; Producer&#123;<span class="string">"addr"</span>&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;<span class="string">"topic"</span>, <span class="string">"topic_a"</span>, <span class="string">""</span>&#125; =&gt; &#123;</span><br><span class="line">		<span class="string">"ip1"</span> =&gt; Producer&#123;<span class="string">"addr_1"</span>&#125;,</span><br><span class="line">		<span class="string">"ip2"</span> =&gt; Producer&#123;<span class="string">"addr2"</span>&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nsqd-nsqlookupd-交互"><a href="#nsqd-nsqlookupd-交互" class="headerlink" title="nsqd  nsqlookupd 交互"></a>nsqd <-> nsqlookupd 交互</-></h2><ol>
<li>connect: send “  V1”</li>
<li>ping: send “PING “<ol>
<li>nsqlookupd update peer info’s lastUpdate</li>
<li>response “OK”</li>
</ol>
</li>
<li>identify: send “IDENTIFY LEN(data) data”<ol>
<li>remote addr as id</li>
<li>load broadcase address, tcp port, http port, version</li>
<li>update peer info’s lastUpdate</li>
<li>add producer to db: Registration{“client”} =&gt; PeerInfo{id}</li>
<li>response {tcp_port, http_port, version, hostname, broadcast_address}</li>
</ol>
</li>
<li>register: send “REGISTER TOPIC [CHANNEL]”<ol>
<li>read topic and channel name</li>
<li>if channel name exists:<ol>
<li>add producer to db: Registration{“channel”, $TOPIC, $CHANNEL} =&gt; PeerInfo{id}</li>
</ol>
</li>
<li>add producer to db: Registration{“topic”, $TOPIC, “”} =&gt; PeerInfo{id}</li>
<li>response “OK”</li>
</ol>
</li>
<li>unregister: send “UNREGISTER TOPIC [CHANNEL]”<ol>
<li>read topic and channel name</li>
<li>if channel name exists:<ol>
<li>remove producer from db: Registration{“channel”, $TOPIC, $CHANNEL}</li>
<li>remove registration for channel has suffix “#ephemeral” if left producer is zero</li>
</ol>
</li>
<li>else:<ol>
<li>find all registrations of channel of $TOPIC</li>
<li>remove all channels of current peer</li>
<li>remove producer form db: Registration{“topic”, $TOPIC, “”}</li>
</ol>
</li>
<li>response “OK”</li>
</ol>
</li>
</ol>
<h2 id="nsqlookupd-support-http-request"><a href="#nsqlookupd-support-http-request" class="headerlink" title="nsqlookupd support http request"></a>nsqlookupd support http request</h2><ol>
<li><p>GET /lookup?topic=topic_name</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"channels"</span>: [<span class="string">"channel1"</span>],</span><br><span class="line">	<span class="attr">"producers"</span>: [&#123;</span><br><span class="line"></span><br><span class="line">	&#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>GET /topics</p>
</li>
<li>GET /channels?topic=topic_name</li>
<li>GET /nodes</li>
<li>POST /topic/create?topic=</li>
<li>POST /topic/delete?topic=</li>
<li>POST /channel/create?topic=topic&amp;channel=channel</li>
<li>POST /channel/delete?topic=&amp;channel=</li>
<li>POST /topic/tombstone?topic=topic_name&amp;node=node_id</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2018/08/04/write-ahead-log/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/04/write-ahead-log/" itemprop="url">Write Ahead Log 杂谈</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-04T08:21:38+08:00">
                2018-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/存储/" itemprop="url" rel="index">
                    <span itemprop="name">存储</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/04/write-ahead-log/" class="leancloud_visitors" data-flag-title="Write Ahead Log 杂谈">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://en.wikipedia.org/wiki/Write-ahead_logging" target="_blank" rel="noopener">预写式日志</a>（Write Ahead Log, WAL）主要用于实现存储系统中的原子性和持久性。预写式日志要求存储系统的修改操作在提交前都要先写入日志（Log）中。在硬盘数据不损坏的情况下，预写式日志允许存储系统在崩溃后能够在日志的指导下恢复到崩溃前的状态，避免数据丢失。</p>
<p>预写式日志并不是实现原子性和持久性的唯一办法，影页替换（Shadow Paging）是另一种实现方式，区别是预写式日志允许数据库进行原地更新（in-place），影页替换则不行。</p>
<p>预写式日志是一种套路，并不仅限于传统数据库中，在需要原子性和持久性的系统中经常见到它的身影。关系数据库的实现里，预写式日志常会被实现为重做（Redo Log）和撤销（Undo Log）两部分。LevelDB 中的日志模块就是预写式日志的简单应用，而最佳实践参考 ARIES algorithm。</p>
<p>Linux 文件系统里也有预写式日志的身影，不过叫做 Journaling。Journaling 提供了文件系统原子写入的可能，减轻存储系统实现难度。Journaling 在存储设备上开辟一段空间，用于记录文件操作，写操作先写入日志，然后复制数据到具体文件空间中，更新文件元信息，确保写入操作完成后再删除日志。Journaling 会在系统挂载文件系统时检查是否有未完成的日志，对其进行重做；系统卸载文件系统时，会将积压的日志写入。如果日志本身就不完整，直接丢弃更改。Journaling 每次操作需要将数据写两次，一种优化方式是先将数据写入对应位置，日志里只记录操作元信息，数据写入成功后再写日志。</p>
<p>预写式日志还应用在使用复制状态机（Replicated State Machine, RSM）进行协作的分布式系统中，如 Raft 算法为了保证安全性要求节点在将日志完整写入硬盘后才能回复该消息。</p>
<p>预写式日志在存储系统中扮演着举足轻重的地位，从文件系统，到分布式系统。不过在新的硬件环境下，出现了另一种与预写式日志相对的叫 Write-Behind Logging 的日志系统。WBL 在事务提交的时候，直接把藏页写入 NVRAM 中，等脏页刷盘后，再去更新日志。关于 WBL 的具体实现方式，参考论文：<a href="http://www.vldb.org/pvldb/vol10/p337-arulraj.pdf" target="_blank" rel="noopener">Write-Behind Logging
</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2018/01/07/Raft-实现指北-领导选举/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/07/Raft-实现指北-领导选举/" itemprop="url">Raft-实现指北-领导选举</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-07T13:31:18+08:00">
                2018-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Destribution/" itemprop="url" rel="index">
                    <span itemprop="name">Destribution</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/01/07/Raft-实现指北-领导选举/" class="leancloud_visitors" data-flag-title="Raft-实现指北-领导选举">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。在选举上，Raft 算法使用一个随机计时器来选举领导者，这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。[1]</p>
<p><img src="https://camo.githubusercontent.com/f9b80d45d67996bb9ce63ba6e5d37b6a03150097/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245352e706e67" alt="时间被划分成一个个的任期，每个任期开始都是一次选举"></p>
<p>Raft 把时间分割任意长度的任期（term），并使用连续整数标记，每个任期都从一次选举开始。每次选举有一个或多个候选人参选，如果一个候选人赢得选举，其就会在该任期充当领导人的职责。某些情况下会出现选票瓜分的现象，那么该任期无法选出领导人，所以进入下一期选举，其中 Raft 通过随机计时来保证选举成功。[1]</p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>实现领导人选举之前，先看到上一节提到的纯函数式的状态机，将 Raft 实现成为一个无副作用的纯函数状态机。Raft 算法可以看作一个角色状态机，通过其他节点传递的消息、计时器、客户端的提交请求和快照等输入消息，从一个状态转移到另一个状态、或修改部分内部状态并返回一个发送给外部的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(state, message) -&gt; state machine -&gt; message</span><br></pre></td></tr></table></figure>
<p>state machine 是一个纯函数式的状态机，负责处理消息，并将改动写入到 state 里，然后返回给外部的消息。</p>
<p>根据 Raft 论文，一个 state 几部分组成：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>所有服务器上持久存在的</th>
</tr>
</thead>
<tbody>
<tr>
<td>currentTerm</td>
<td>服务器最后一次知道的任期号（初始化为 0，持续递增）</td>
</tr>
<tr>
<td>votedFor</td>
<td>在当前获得选票的候选人的 Id</td>
</tr>
<tr>
<td>log[]</td>
<td>日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>状态</th>
<th>所有服务器上经常变的</th>
</tr>
</thead>
<tbody>
<tr>
<td>commitIndex</td>
<td>已知的最大的已经被提交的日志条目的索引值</td>
</tr>
<tr>
<td>lastApplied</td>
<td>最后被应用到状态机的日志条目索引值（初始化为 0，持续递增）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>状态</th>
<th>在领导人里经常改变的 （选举后重新初始化）</th>
</tr>
</thead>
<tbody>
<tr>
<td>nextIndex[]</td>
<td>对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一）</td>
</tr>
<tr>
<td>matchIndex[]</td>
<td>对于每一个服务器，已经复制给他的日志的最高索引值</td>
</tr>
</tbody>
</table>
<p>实现大体是类似的，不过以后需要加入流量控制、成员加入退出等，所以将 state 中保存的其他服务器的信息抽象一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">uint64</span> </span><br><span class="line">    nextIdx <span class="keyword">uint64</span> </span><br><span class="line">    matched <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>id</code> 表示其他服务器在 Raft 中的唯一 ID，<code>nextIdx</code> 与 <code>matched</code> 分别是 <code>nextIndex</code> 数组和 <code>matchIndex</code> 数据中第 <code>id</code> 个元素。</p>
<p>Raft 通过超时来驱动心跳和选举，一共由两种超时：1、心跳超时，领导人定期给跟随者发送心跳信息宣布自己的领导权；2、选举超时，超时时间是随机选择的。</p>
<p>整个 state 如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> core <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">uint64</span> </span><br><span class="line">    leaderId <span class="keyword">uint64</span></span><br><span class="line">    state StateRole</span><br><span class="line"></span><br><span class="line">    term <span class="keyword">uint64</span> </span><br><span class="line">    vote <span class="keyword">uint64</span> </span><br><span class="line">    log *LogHolder </span><br><span class="line"></span><br><span class="line">    nodes []node </span><br><span class="line"></span><br><span class="line">    timeElapsed <span class="keyword">int</span> </span><br><span class="line">    randomizedElectionTimtout <span class="keyword">int</span> </span><br><span class="line">    electionTimeout <span class="keyword">int</span> </span><br><span class="line">    heartbeatTimeout <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>id</code> 是 Raft weiyiqueding d  <code>term</code> 和 <code>vote</code> 分别是 <code>currentTerm</code> 和 <code>voteFor</code> 的实现，而日志由应用负责持久化。<code>lastApplied</code> 和 <code>commitIndex</code> 由 <code>log</code> 负责管理。<code>nodes</code> 表示该 Raft 集群的其他服务器的状态。<code>timeElapsed</code> 表示从时间累积，<code>randomizedElectionTimeout</code> 表示随机生成的选举超时阈值，每次转为跟随者、候选人状态时都会改变。<code>heartbeatTimeout</code> 表示领导人两次心跳的间隔。<code>electionTimeout</code> 用来表示领导人选举超时基准，其用于计算<code>randomizedElectionTimeout</code>，使用公式：$electionTimeout + rand() \% electionTimeout$ 计算得到。另外还有 <code>leaderId</code> 和 <code>state</code> 状态，<code>leaderId</code> 表示当前领导人的 ID，<code>state</code> 则是 Raft 目前所处的角色。</p>
<p>此外，还需要设计消息结构作为外部应用、服务器和 Raft 状态机进行数据交换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    From <span class="keyword">uint64</span> </span><br><span class="line">    To <span class="keyword">uint64</span> </span><br><span class="line">    MsgType MessageType</span><br><span class="line">    Term <span class="keyword">uint64</span> </span><br><span class="line">    Index <span class="keyword">uint64</span></span><br><span class="line">    LogIndex <span class="keyword">uint64</span> </span><br><span class="line">    LogTerm <span class="keyword">uint64</span> </span><br><span class="line">    Reject <span class="keyword">uint64</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该结构不仅仅用于发起请求，也用于状态机返回数据，所以需要 <code>Reject</code> 字段表示拒绝请求，比如拒绝给某个候选人投票。</p>
<p>最后，状态机需要返回消息给消息发送者，由于希望将 Raft 设计为一个纯函数式状态机，消息的接受发送交给了应用处理，所以还得提供一个 <code>Application</code> 接口，供 Raft 和应用交互。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Application <span class="keyword">interface</span> &#123;</span><br><span class="line">    send(msg *raftpd.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当应用接收到消息后，将其输入到 Raft 状态机，处理完后，调用 <code>send</code> 发送回复消息，并保存信息到机中。整个状态机由消息驱动，所以 Raft 接口如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">interface</span> &#123;</span><br><span class="line">    Step(msg *raftpd.Message)</span><br><span class="line">    Periodic(millsSinceLastPeriod <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当应用接受到外部传递的消息后，调用 <code>Step</code> 驱动状态机改变状态。Raft 中通过超时进行心跳或选举，外部应用需要通过某个固定的定时源隔一段时间调用 <code>Periodic</code> 驱动状态机进行心跳、选举等。</p>
<h1 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h1><p><img src="https://camo.githubusercontent.com/6396d99ee401327500ef9eafe92617d7812ecd4d/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245342d30312e706e67" alt="服务器状态变化图"></p>
<p>系统进行初始化时，每个节点都处于跟随者状态，由于没有领导人定期广播心跳，所以一段时间后部分跟随者成为候选人并进行下一届选举。</p>
<p>当某个候选人获得了超过半数的投票后，成为领导人，并向所有节点广播自己成功的信息。当候选人接收到其他候选人成为领导人的信息后，一届只能选出一个领导人（<strong>选举安全特性</strong>），该候选人退回到跟随者的状态，并投票给该领导人。</p>
<p>如果到了下一个选举超时，仍然没有候选人成为领导人，就会跳过这一届，开始下一届的领导人选举。</p>
<h1 id="PreVote"><a href="#PreVote" class="headerlink" title="PreVote"></a>PreVote</h1><p>由于<strong>选举安全特性</strong>的限制，成员会忽略已经过期的信息时，并返回自己所在的任期，用于发送者更新自己。由于这一特性的存在，在一个存在网络延迟的网络中，某个节点由于延迟进入了选举，而实际上大多数节点都能接收到领导人的心跳，也会进入选举。Raft 原论文 9.6 节中提出了 Prevote 算法：在选举前可以选询问其他节点是否愿意参与选举，如果节点能够感知到领导人的心跳，那么它就不会参与选举，否则参与选举。只有过半的节点参与选举，才能开始下一届领导人选举。</p>
<h1 id="领导人选举实现"><a href="#领导人选举实现" class="headerlink" title="领导人选举实现"></a>领导人选举实现</h1><p>加入了 PreVote 算法后，Raft 的状态变为 4 个：领导人、跟随者，候选人，预候选人。此时的外部事件为：选举、心跳超时；以及：</p>
<ul>
<li>MsgPreVoteRequest</li>
<li>MsgPreVoteResponse</li>
<li>MsgVoteRequest</li>
<li>MsgVoteResponse</li>
<li>MsgAppendRequest</li>
</ul>
<p><code>MsgAppendRequest</code> 这种消息类型发生在某个节点成竞选成功后向其他节点宣示领导权，在选举过程中也由该种类型在节点间传递。比如 PreVote 阶段正常的跟随者能够接收到领导人的心跳；又或者新晋领导人首次对外宣誓领导权。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">Periodic</span><span class="params">(millsSinceLastPeriod <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    c.timeElapsed += millsSinceLastPeriod</span><br><span class="line">    log.Debugf(<span class="string">"%d periodic %d, time elapsed %d"</span>, c.id, millsSinceLastPeriod, c.timeElapsed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.state.IsLeader() &#123;</span><br><span class="line">        <span class="keyword">if</span> c.heartbeatTick &lt;= c.timeElapsed &#123;</span><br><span class="line">            c.broadcastAppend()</span><br><span class="line">            c.timeElapsed = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.randomizedElectionTick &lt;= c.timeElapsed &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(c.nodes) &gt; <span class="number">1</span> &#123;</span><br><span class="line">            c.campaign(campaignPreCandidate)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次应用程序调用 <code>Periodic</code> 时，Raft 判断是否为 leader，是判断 <code>timeElapsed</code> 是否超过 <code>heartbeatTick</code>，然后向其他节点发送追加日志（心跳）信息，并清空 <code>timElapsed</code>；如果不是领导人，且已经超过随机生成的选举超时，那么状态转移到预候选人同时开始 PreVote 阶段。</p>
<p>除此之外，PreVote 算法还需要记录其他节点对某次预选举请求的响应状态，所以在 node 结构中添加字段标记：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> voteState <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    voteNone    voteState = <span class="literal">iota</span></span><br><span class="line">    voteReject</span><br><span class="line">    voteGranted</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    vote    voteState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态间转换"><a href="#状态间转换" class="headerlink" title="状态间转换"></a>状态间转换</h2><p>继续之前需要看看 Raft 状态机的状态转换是如何实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">resetRandomizedElectionTimeout</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.randomizedElectionTick =</span><br><span class="line">        c.electionTick + rand.Intn(c.electionTick)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">reset</span><span class="params">(term <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.term != term &#123;</span><br><span class="line">        c.term = term</span><br><span class="line">        c.vote = InvalidId</span><br><span class="line">    &#125;</span><br><span class="line">    c.leaderId = InvalidId</span><br><span class="line">    c.timeElapsed = <span class="number">0</span></span><br><span class="line">    c.resetRandomizedElectionTimeout()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">becomeFollower</span><span class="params">(term, leaderId <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">    c.reset(term)</span><br><span class="line">    c.leaderId = leaderId</span><br><span class="line">    c.state = FOLLOWER</span><br><span class="line">    c.vote = leaderId</span><br><span class="line"></span><br><span class="line">    log.Infof(<span class="string">"%v become follower at %d"</span>, c.id, c.term)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">becomeLeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">    utils.Assert(c.state == CANDIDATE, <span class="string">"invalid translation [%v =&gt; Leader]"</span>, c.state)</span><br><span class="line"></span><br><span class="line">    c.reset(c.term)</span><br><span class="line">    c.leaderId = c.id</span><br><span class="line">    c.state = LEADER</span><br><span class="line">    c.vote = c.id</span><br><span class="line"></span><br><span class="line">    log.Infof(<span class="string">"%v become leader at %d"</span>, c.id, c.term)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">becomeCandidate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    utils.Assert(c.state != LEADER, <span class="string">"invalid translation [Leader =&gt; Candidate]"</span>)</span><br><span class="line"></span><br><span class="line">    c.reset(c.term + <span class="number">1</span>)</span><br><span class="line">    c.vote = c.id</span><br><span class="line">    c.state = CANDIDATE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(c.nodes); i++ &#123;</span><br><span class="line">        node := &amp;c.nodes[i]</span><br><span class="line">        node.resetVoteState()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    log.Infof(<span class="string">"%v become candidate at %d"</span>, c.id, c.term)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">becomePreCandidate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.reset(c.term)</span><br><span class="line">    c.state = PRE_CANDIDATE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(c.nodes); i++ &#123;</span><br><span class="line">        node := &amp;c.nodes[i]</span><br><span class="line">        node.resetVoteState()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Becoming a pre-candidate changes our state,</span></span><br><span class="line">    <span class="comment">// but doesn't change anything else. In particular it does not increase</span></span><br><span class="line">    <span class="comment">// currentTerm or change votedFor.</span></span><br><span class="line">    log.Infof(<span class="string">"%x became pre-candidate at term %d"</span>, c.id, c.term)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看到 <code>reset</code>，它是负责在 Raft 状态转换过程中重置部分状态。<code>reset</code> 中第一步是根据任期是否改变决定重置 <code>vote</code> 和 <code>term</code> 信息；除此之外还重置了 <code>leaderId</code> 以及超时相关的两个属性: <code>timeElapsed</code> 和 <code>randomizedElectionTimeout</code>。</p>
<p>进入预选举的节点在被大多数节点拒绝后会回退到跟随者的状态，因此在 <code>becomePreCandidate</code> 中除了重置基础状态外，仅仅修改了 <code>state</code> 属性和重置其他节点的投票情况。<strong>特别需要注意的是不能修改 <code>currentTerm</code> 和 <code>votedFor</code></strong>。</p>
<p>如果预选举的节点获得了半数的节点参选支持，就会进入候选人状态，因此任期加一，同时给自己投票。</p>
<p>此外，当领导者和跟随者在发送心跳或接收到领导人的通知后，都需要重置 <code>timeElappsed</code>，因此将 <code>becomeLeader</code> 和 <code>becomeFollower</code> 设计为重入只会影响到 <code>timeElapsed</code> 和 <code>randomizedElectinTimeout</code> 属性。</p>
<h2 id="PreCampaign"><a href="#PreCampaign" class="headerlink" title="PreCampaign"></a>PreCampaign</h2><p>竞选时首先调用 <code>campaign</code> 给其他节点发送 <code>MsgPreVoteRequest</code> 请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">campaign</span><span class="params">(ct campaignState)</span></span> &#123;</span><br><span class="line">    utils.Assert(c.state != LEADER,</span><br><span class="line">        <span class="string">"invalid translation [Leader =&gt; PreCandidate/Candidate]"</span>)</span><br><span class="line"></span><br><span class="line">    msg := raftpd.Message&#123;&#125;</span><br><span class="line">    msg.LogIndex = c.log.lastIndex()</span><br><span class="line">    msg.LogTerm = c.log.lastTerm()</span><br><span class="line">    <span class="keyword">if</span> ct == campaignPreCandidate &#123;</span><br><span class="line">        msg.Term = c.term + <span class="number">1</span></span><br><span class="line">        msg.MsgType = raftpd.MsgPreVoteRequest</span><br><span class="line">        c.becomePreCandidate()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg.Term = c.term</span><br><span class="line">        msg.MsgType = raftpd.MsgVoteRequest</span><br><span class="line">        c.becomeCandidate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(c.nodes); i++ &#123;</span><br><span class="line">        node := &amp;c.nodes[i]</span><br><span class="line">        msg.To = node.id</span><br><span class="line"></span><br><span class="line">        log.Infof(<span class="string">"%x [term: %d, index: %d] send %v request to %x at term %d"</span>,</span><br><span class="line">            c.id, c.log.lastTerm(), c.log.lastIndex(), msg.MsgType, msg.To, c.term)</span><br><span class="line">        c.send(&amp;msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PreVote 要求某个节点只有在长时间未和领导人交换心跳时才参与选举。同时参与选举要求候选人的日志必须是最新的（<strong>领导人完全特性</strong>）。所以在接收到其他节点发送的 <code>MsgPreVoteRequest</code> 时，1、如果在一个选举超时内（注意：<code>electionTimeout</code>）有和领导交换过一次心跳；2、或者候选人的任期号小于自身的任期号；3、或者候选人的日志不是最新的都拒绝参加选举。否则回复参加选举。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">handlePreVote</span><span class="params">(msg *raftpd.Message)</span></span> &#123;</span><br><span class="line">    reply := raftpd.Message&#123;&#125;</span><br><span class="line">    reply.To = msg.From</span><br><span class="line">    reply.MsgType = raftpd.MsgPreVoteResponse</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reply false if last AppendEntries call was received less than election timeout ago.</span></span><br><span class="line">    <span class="comment">// Reply false if term &lt; currentTerm.</span></span><br><span class="line">    <span class="comment">// Reply false if candidate's log isn't at least as up­to­date as receiver's log.</span></span><br><span class="line">    <span class="keyword">if</span> (c.leaderId != InvalidId &amp;&amp; c.timeElapsed &lt; c.electionTick) ||</span><br><span class="line">        (msg.Term &lt; c.term) ||</span><br><span class="line">        !c.log.IsUpToDate(msg.LogIndex, msg.LogTerm) &#123;</span><br><span class="line">        reply.Reject = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reply.Reject = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.send(&amp;reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：实际上在处理远程信息时，如果接收到了过期信息，会直接丢弃（后面有讲），不会进入 <code>handlePreVote</code> 函数，所以上面第二点实际上永远为假。</p>
<p>预候选人接收到其他节点回复的信息时:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">handleVoteResponse</span><span class="params">(msg *raftpd.Message)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> msg.Reject &#123;</span><br><span class="line">        log.Infof(<span class="string">"%x received %v rejection from %x at term %d"</span>,</span><br><span class="line">            c.id, msg.MsgType, msg.From, c.term)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Infof(<span class="string">"%x received %v from %x at term %s"</span>,</span><br><span class="line">            c.id, msg.MsgType, msg.From, msg.Term)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node := c.getNodeById(msg.From)</span><br><span class="line">    node.updateVoteState(msg.Reject)</span><br><span class="line"></span><br><span class="line">    count := c.voteStateCount(voteGranted)</span><br><span class="line">    <span class="keyword">if</span> count &gt;= c.quorum() &#123;</span><br><span class="line">        <span class="keyword">if</span> msg.MsgType == raftpd.MsgVoteResponse &#123;</span><br><span class="line">            c.becomeLeader()</span><br><span class="line">            c.broadcastVictory()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.campaign(campaignCandidate)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return to follower state if it receives vote denial from a majority</span></span><br><span class="line">    count = c.voteStateCount(voteReject)</span><br><span class="line">    <span class="keyword">if</span> count &gt;= c.quorum() &#123;</span><br><span class="line">        c.becomeFollower(msg.Term, InvalidId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新某个 node 对此次请求的投票情况，并判断支持者和反对者人数，如果支持者人数过半，那么调用 <code>campaign(campaignCandidate)</code> 进入候选人状态。如果反对者人数过半，那么节点会回退到跟随者的状态。</p>
<h2 id="Campaign"><a href="#Campaign" class="headerlink" title="Campaign"></a>Campaign</h2><p>在候选人一方，选举过程使用了相同的函数，不同的是跟随者对候选人的处理。只有当候选人未投票或者上一次投给了该候选人，候选人才能获得跟随者的选票。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">handleVote</span><span class="params">(msg *raftpd.Message)</span></span> &#123;</span><br><span class="line">    reply := raftpd.Message&#123;&#125;</span><br><span class="line">    reply.To = msg.From</span><br><span class="line">    reply.MsgType = raftpd.MsgVoteResponse</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no vote or vote for candidate, and log is at least as up-to-date as receiver's.</span></span><br><span class="line">    <span class="keyword">if</span> c.vote == InvalidId || c.vote == msg.From ||</span><br><span class="line">        c.log.IsUpToDate(msg.LogIndex, msg.LogTerm) &#123;</span><br><span class="line">        reply.Reject = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reply.Reject = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.send(&amp;reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理过时消息"><a href="#处理过时消息" class="headerlink" title="处理过时消息"></a>处理过时消息</h2><p>根据 Raft 论文中将 term 用作逻辑时间，判断过期的消息。在论文图 2 中提到如果接收到来自高任期的消息，应该回退到跟随者状态；接收到过时消息，直接忽略。所以代码可以写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> msg.Term &lt; c.term &#123;</span><br><span class="line">    c.reject(msg)</span><br><span class="line">&#125; <span class="keyword">if</span> msg.Term &gt; c.term &#123;</span><br><span class="line">    c.becomeFollower()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上可能某个节点成为候选人后，又重新连接到网络中。此时发起投票会导致其他节点增大任期，因此对投票相关的消息做特殊处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *core)</span> <span class="title">Step</span><span class="params">(msg *raftpd.Message)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> msg.Term &lt; c.term &#123;</span><br><span class="line">        c.reject(msg)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.Term &gt; c.term &#123;</span><br><span class="line">        <span class="keyword">if</span> msg.MsgType == raftpd.MsgPreVoteRequest &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.MsgType == raftpd.MsgPreVoteResponse &amp;&amp; msg.Reject &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.becomeFollower(msg.Term, leaderId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> msg.MsgType &#123;</span><br><span class="line">    <span class="keyword">case</span> raftpd.MsgPreVoteRequest:</span><br><span class="line">        c.handlePreVote(msg)</span><br><span class="line">    <span class="keyword">case</span> raftpd.MsgVoteRequest:</span><br><span class="line">        c.handleVote(msg)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        c.dispatch(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Raft 算法虽然更易于理解，但是实现并不简单。就以上述代码为例，Raft 如果没有 PreVote 机制，那么重新上线的候选人会通过 <code>c.reject(msg)</code> 强制让候选人参与选举。加入 PreVote 机制也不能完全避免这种情况。如果一个节点成为了候选人，此时领导人重新上线，那么候选人仍然会强制发起一次选举[3]。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">寻找一种易于理解的一致性算法（扩展版）</a></li>
<li><a href="http://blog.neverchanje.com/2017/01/30/etcd_raft_core/" target="_blank" rel="noopener">Etcd-raft-core 阅读</a></li>
<li><a href="http://blog.neverchanje.com/2017/01/31/morning_paper_four_modifications_mongo_raft/" target="_blank" rel="noopener">Morning Paper, MongoDB 对 Raft 算法的 4 个改动</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2018/01/02/Raft-实现指北-日志模块/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/Raft-实现指北-日志模块/" itemprop="url">Raft 实现指北-日志模块</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-02T21:14:14+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Destribution/" itemprop="url" rel="index">
                    <span itemprop="name">Destribution</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/01/02/Raft-实现指北-日志模块/" class="leancloud_visitors" data-flag-title="Raft 实现指北-日志模块">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在真正开始设计之前，需要考虑好 Raft 框架的搭建。如下图所示，一个服务器由三部分组成：共识算法、状态机以及日志系统。共识算法控制多副本之间日志的同步、广播。Raft 算法主要的工作是管理日志复制，所以在 Raft 应该有一个可操作的日志模块。</p>
<p><img src="https://camo.githubusercontent.com/ad683fbaefbc0bc0fcb31b1d6ca6ca8f715c12cd/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245312d30312e706e67" alt="图一：复制状态机的结构"></p>
<h1 id="Write-Ahead-Log"><a href="#Write-Ahead-Log" class="headerlink" title="Write Ahead Log"></a>Write Ahead Log</h1><p>在设计日志模块之前，需要先说说<strong>预写式日志</strong>（Write Ahead Log, WAL）。预写式日志通常出现在存储系统中，以保证数据的持久性[1]。WAL 的中心思想是对数据文件进行修改前，需要保证操作日志已经同步到稳定存储介质中。如果在进行操作时出现了错误导致程序崩溃，重启的程序可以通过读取日志重建原有状态。</p>
<p>Raft 算法中也需要 WAL 配合工作，比如领导人得知某条日志已经有超过半数的人响应，便将其应用到状态机并将其应用结果返回给客户端。状态机将数据保存在内存中，等待系统写入磁盘。此时如果发生错误，客户端的操作日志丢失，而它又接收到了应用成功的消息，便出现了不一致。</p>
<h1 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LogHolder</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Entry&gt; entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志的存储结构可以简单如上设计，<code>Entry</code> 表示一套操作日志记录。所有已经通过 WAL 持久化的操作日志保存在 Raft 的 <code>LogHolder</code> 中做缓存。IO 操作非常耗时，在实际的项目中每次操作先进行 IO 操作，效率不高。通常考虑 Batch 操作，将结构修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LogHolder</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Entry&gt; entries;</span><br><span class="line">    <span class="keyword">size_t</span> stabled_to;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样操作日志和已经持久化的日志保存在一起，并通过 <code>stable_to</code> 区分开。这样将多个日志 <code>Entry</code> 一起写入 WAL，Batch 的方法可以提升系统整体的吞吐量，不过对于单条数据，会有部分延迟，与提升比起来是非常值得的。</p>
<p>当某条日志被成功复制到集群中过半数的节点中时，Raft 变认为这条日志可以被应用到状态机中，并标记这部分日志为提交状态。提交的日志采用追加的方式，那么原有数据将一直占用存储空间，而对于系统而言，已经被应用了的日志是无用的，所以 Raft 也提出了日志压缩思想。和存储系统中的日志压缩思路一致，都是通过选取某个时间点的日志创建状态机的快照，将时间点之前的日志全部丢弃。[2]</p>
<p>这里将上述的思想也设计到日志系统中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +--------------+--------------+-------------+-------------+</span></span><br><span class="line"><span class="comment">// | wait compact |  wait apply  | wait commit | wait stable |</span></span><br><span class="line"><span class="comment">// +--------------+--------------+-------------+-------------+</span></span><br><span class="line"><span class="comment">// ^ offset       ^ Applied      ^ committed   ^ stabled     ^ last</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LogHolder</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Entry&gt; entries;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">size_t</span> last_applied;</span><br><span class="line">    <span class="keyword">size_t</span> last_committed;</span><br><span class="line">    <span class="keyword">size_t</span> last_stabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>offset</code> 表示日志压缩后日志系统里存储的第一条日志在整个日志中的偏移。整个模块需要保证 $0 \le offset \le last\_applied \lt last\_committed \lt entreis.size()$。需要注意，<code>last_stabled</code> 和 <code>last_committed</code> 之前不一定存在着先后顺序，比如一个出现了网络隔离的节点在一段时间后上线，领导者将将其日志复制给该节点并告知其已经全部提交了，那么就会出现日志属于已经提交的状态，但是还未持久化。</p>
<p>在 Raft 论文中提到，在生成日志快照时，需要保存快照最后一条日志的 <code>index</code> 和 <code>term</code> 作为元信息。也有很多访问该元信息的需求，因此可以在 <code>entries</code> 中保留一个空白（dummy）日志作为快照元信息，那么 <code>offset</code> 完全可以被该日志项替代。</p>
<p>整个 <code>LogHolder</code> 只负责维护日志在内存中的缓存，提供日志追加、应用、提交、持久化以及压缩的基本功能，至于具体的操作实际由使用者负责管理。</p>
<h2 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h2><p>API 设计是一个模块好用与否的关键，良好的 API 设计可以减少内部设计的暴露，减少模块间的耦合，同时提供最大程度的灵活性。这里希望 API 设计简单易用，接口数量少，粒度适中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogHolder <span class="keyword">interface</span> &#123;</span><br><span class="line">    compactTo(to, term <span class="keyword">uint64</span>)</span><br><span class="line">    commitTo(<span class="keyword">uint64</span>)</span><br><span class="line">    applyEntries() []Entry</span><br><span class="line">    stableEntries() []Entry</span><br><span class="line">    term(<span class="keyword">uint64</span>) <span class="keyword">uint64</span></span><br><span class="line">    isUpToDate(idx, term <span class="keyword">uint64</span>) <span class="keyword">bool</span></span><br><span class="line">    tryAppend(idx, term, commitIdx <span class="keyword">uint64</span>, entries []Entry) (<span class="keyword">uint64</span>, <span class="keyword">bool</span>)</span><br><span class="line">    <span class="built_in">append</span>(entries []Entry) <span class="keyword">uint64</span></span><br><span class="line">    slice(lo, hi <span class="keyword">uint64</span>) []Entry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>compactTo</code>: 当应用生成了快照后，需要对冗余的日志进行压缩；</li>
<li><code>commitTo</code>: 日志复制到集群中半数节点中或跟随者接收到领导人提交日志的命令时调用，修改 <code>last_commit</code> 属性；</li>
<li><code>stableEntries</code>: 读取待持久化的日志，并将这部分日志标记为已经持久化；</li>
<li><code>applyEntries</code>: 读取待应用到状态机的日志，同时将其日志标记为已经应用；</li>
<li><code>term</code>: 返回某个日志提交到集群中的 <code>term</code>；</li>
<li><code>isUpToDate</code>: 用于判断候选人是否拥有最新的日志；</li>
<li><code>tryAppend</code>: 跟随者添加日志，会将冲突的日志丢弃；</li>
<li><code>append</code>: 领导添加日志，只有追加功能；</li>
<li><code>slice</code>: 分片</li>
</ul>
<p><code>compactTo</code>，<code>commitTo</code> 负责修改其只修改日志模块属性信息。<code>compactTo</code> 对日志进行压缩，其可用范围为 $[offset, last\_applied]$，范围内的数据均已经应用到状态机中。实际上在跟随者从网络隔离中恢复或新加入集群时，领导人会选择发送日志来加速跟随者的同步，此时快照并没有落到可用范围内，或者日志与快照的元信息冲突（跟随者在一个少数派的网络中增加了很多日志），因此需要对整个日志系统进行重建。<code>commitTo</code> 只需要对 <code>to</code> 范围进行验证，修改 <code>last_commit</code> 即可。</p>
<p><code>stableEntries</code> 和 <code>applyEntries</code> 不需要任何参数，根据属性设置对应的 <code>slice</code>，并返回需要持久化、应用的日志队列。</p>
<p><code>isUpToDate</code> 比较给出的日志项和日志模块谁更新。根据 Raft 论文中给出了谁<strong>比较新</strong>的定义：如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新；如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p>
<p><code>tryAppend</code> 是用于提交领导人复制给候选人的日志，由于网络分化或者节点的加入退出，获选人的日志可能落后、冲突于领导人提供的日志，日志模块需要对待追加的日志进行检查，并找出冲突项目并替换。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><code>compactTo</code> 设计如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(holder *LogHolder)</span> <span class="title">CompactTo</span><span class="params">(to, term <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> holder.Term(to) != term || to &lt;= holder.offset() || to &gt; holder.lastApplied &#123;</span><br><span class="line">		<span class="comment">// log entry conflict with exists, or less than offset, or great than applied</span></span><br><span class="line">		<span class="comment">// so need to rebuild log</span></span><br><span class="line">		entries := <span class="built_in">make</span>([]raftpd.Entry, <span class="number">1</span>)</span><br><span class="line">		entries[<span class="number">0</span>].Index = to</span><br><span class="line">		entries[<span class="number">0</span>].Term = term</span><br><span class="line">		holder.entries = entries</span><br><span class="line">		holder.lastApplied = to</span><br><span class="line">		holder.commitIndex = to</span><br><span class="line">		holder.lastStabled = to</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		offset := holder.offset()</span><br><span class="line">		utils.Assert(offset &lt;= to, <span class="string">"%d compact idx: %d less than first index: %d"</span>,</span><br><span class="line">			holder.id, to, offset)</span><br><span class="line">		holder.entries = drain(holder.entries, <span class="keyword">int</span>(to-offset))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先检查是否存在冲突、或者没有在范围之内，都不存在才对日志队列进行压缩；否则重建日志模块，清空日志队列。因为使用了 dummy 日志项的缘故，这里也要把快照元信息作为一个 dummy log 保存。</p>
<p>和 <code>compactTo</code> 比起来，<code>commitTo</code> 的实现就容易得多。<code>commitTo</code> 需要保证<strong>状态机安全性</strong>和<strong>领导人完全性</strong>[2]，不能减少 <code>commit_index</code>；同时也要保证容错，即在服务器宕机恢复后数据具有一致性，每个可提交的日志需要已经持久化到本地。<code>commitTo</code> 需要保证数据范围在 $[commit_index, last\_stabled]$ 之间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(holder *LogHolder)</span> <span class="title">CommitTo</span><span class="params">(to <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> holder.commitIndex &gt;= to &#123;</span><br><span class="line">		<span class="comment">/* never decrease commit */</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> holder.lastStabled &lt; to &#123;</span><br><span class="line">		<span class="comment">/* cannot commit unstable log entry */</span></span><br><span class="line">		to = utils.MinUint64(to, holder.lastStabled)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	utils.Assert(holder.lastIndex() &gt;= to, <span class="string">"%d toCommit %d is out of range [last index: %d]"</span>,</span><br><span class="line">		holder.id, to, holder.lastIndex())</span><br><span class="line"></span><br><span class="line">	holder.commitIndex = to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>stableEntries</code> 和 <code>applyEntries</code> 需要返回待持久化或待应用的日志，同时会修改属性，将这已返回的日志标记为已持久化或已经应用。<code>term</code> 的实现比较直观，<code>isUpToDate</code> 的实现按照论文给出的定义即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(holder *LogHolder)</span> <span class="title">IsUpToDate</span><span class="params">(idx, term <span class="keyword">uint64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> term &gt; holder.lastTerm() || (term == holder.lastTerm() &amp;&amp; idx &gt;= holder.lastIndex())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>append</code> 由领导人负责调用，由<strong>领导人只附加原则</strong>决定其只追加新日志到模块中。因为 Raft 的日志具有连续性，追加时要保证第一条追加的日志要紧接着日志模块的最后一条日志。<code>tryAppend</code> 由跟随者调用，正常情况下领导人发送的日志可以直接追加到跟随者的日志模块中。跟随者可能是新加入集群，并通过快照已经恢复到了快照所处的状态，此时也可以直接追加到日志模块里。当跟随者出现网络隔离导致日志远低于领导人复制来的第一条日志项（重新选举时），或日志项与领导人提供的存在冲突。如果第一条日志存在冲突，那么需要提醒领导人发送合适的日志；如果仅仅部分日志存在冲突，跟随者需要丢弃冲突日志，然后将领导人提供的日志追加到日志模块中（根据<strong>日志匹配原则</strong>），此时需要保证不能抛弃任何已经提交的日志（<strong>状态机安全性</strong>和<strong>领导人完全性</strong>）。</p>
<p><code>tryAppend</code> 的第一步是找出第一个与现有日志存在冲突的日志索引，然后根据冲突索引丢弃存在冲突的日志，并返回。<code>tryAppend</code> 的返回值表示是否成功的将日志追加到系统中。Raft 论文 5.3 节提出了一个优化方式，<em>算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化</em>，这里可以使用算法给出的一种优化方式：当附加日志 RPC 的请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。因此在拒绝该追加请求时，还给领导人返回提示索引。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(holder *LogHolder)</span> <span class="title">getHintIndex</span><span class="params">(prevIdx, prevTerm <span class="keyword">uint64</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">	utils.Assert(prevIdx != InvalidIndex &amp;&amp; prevTerm != InvalidTerm,</span><br><span class="line">		<span class="string">"%d get hint index with invalid idx or Term"</span>, holder.id)</span><br><span class="line"></span><br><span class="line">	idx := prevIdx</span><br><span class="line">	term := holder.Term(idx)</span><br><span class="line">	<span class="keyword">for</span> idx &gt; InvalidIndex &#123;</span><br><span class="line">		<span class="keyword">if</span> holder.Term(idx) != term &#123;</span><br><span class="line">			<span class="keyword">return</span> utils.MaxUint64(holder.commitIndex, idx)</span><br><span class="line">		&#125;</span><br><span class="line">		idx--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> holder.commitIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findConflict return the first index which Entries[i].Term is not equal</span></span><br><span class="line"><span class="comment">// to holder.Term(Entries[i].Index), if all Term with same index are equals,</span></span><br><span class="line"><span class="comment">// return zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(holder *LogHolder)</span> <span class="title">findConflict</span><span class="params">(entries []raftpd.Entry)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(entries); i++ &#123;</span><br><span class="line">		entry := &amp;entries[i]</span><br><span class="line">		<span class="keyword">if</span> holder.Term(entry.Index) != entry.Term &#123;</span><br><span class="line">			<span class="keyword">if</span> entry.Index &lt;= holder.lastIndex() &#123;</span><br><span class="line">				log.Infof(<span class="string">"%d found conflict at index %d, "</span>+</span><br><span class="line">					<span class="string">"[existing Term: %d, conflicting Term: %d]"</span>,</span><br><span class="line">					holder.id, entry.Index, holder.Term(entry.Index), entry.Term)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> entry.Index</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(holder *LogHolder)</span> <span class="title">TryAppend</span><span class="params">(prevIdx, prevTerm, leaderCommittedIdx <span class="keyword">uint64</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	entries []raftpd.Entry)</span> <span class="params">(<span class="keyword">uint64</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	lastIdxOfEntries := prevIdx + (<span class="keyword">uint64</span>)(<span class="built_in">len</span>(entries))</span><br><span class="line">	<span class="keyword">if</span> holder.Term(prevIdx) == prevTerm &#123;</span><br><span class="line">		conflictIdx := holder.findConflict(entries)</span><br><span class="line">		<span class="keyword">if</span> conflictIdx == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">/* success, no conflict */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> conflictIdx &lt;= holder.commitIndex &#123;</span><br><span class="line">			log.Panicf(<span class="string">"%d entry %d conflict with committed entry %d"</span>,</span><br><span class="line">				holder.id, conflictIdx, holder.commitIndex)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			offset := prevIdx + <span class="number">1</span></span><br><span class="line">			holder.Append(entries[conflictIdx-offset:])</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> lastIdxOfEntries, <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		utils.Assert(prevIdx &gt; holder.commitIndex,</span><br><span class="line">			<span class="string">"%d entry %d [Term: %d] conflict with committed entry Term: %d"</span>,</span><br><span class="line">			holder.id, prevIdx, prevTerm, holder.Term(prevIdx))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> holder.getHintIndex(prevIdx, prevTerm), <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="done"><a href="#done" class="headerlink" title="done"></a>done</h1><p>至此，日志模块的实现就结束了。日志模块是整个 Raft 算法的基础，这里将日志模块剥离出来，并将提供一些原子方法。每个方法只干一件事，从而使分析方法正确性的分析更容易；每个方法都可以看作是纯函数，所以输入一定，输出则一定。实际上分布式程序的调试是一个非常困难的方式：</p>
<blockquote>
<p>你的并发模型往往会成为你代码库中的病毒。你希望有细粒度的并发控制，好吧，你得到了，代码里到处都是。因此是并发导致了不确定性，而不确定性造成了麻烦。因此必须得把并发给踢出去。可是你又不能抛弃并发，你需要它。那么，你一定要禁止把并发和你的分布式状态机结合在一起。换句话说，你的分布式状态机必须成为纯函数式的。没有IO操作，没有并发，什么都没有。[3]</p>
</blockquote>
<p>好的办法是将其抽象成纯函数式的，通过消息进行驱动，这样能够对程序拥有控制力，出现问题是可以完美重现，也能够跟踪定位到问题所在。从 Raft 算法的角度看，在上面的实现里，日志模块只是一个黑匣子，每个操作好比一个按钮，如果得到的不是想要的结果，那肯定是输入有问题（前提是黑匣子实现正确）。因此上面的代码很好的解开了算法和日志模块的耦合，隔离了双方的错误干扰。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E9%A2%84%E5%86%99%E5%BC%8F%E6%97%A5%E5%BF%97" target="_blank" rel="noopener">预写式日志</a></li>
<li><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">寻找一种易于理解的一致性算法（扩展版）</a></li>
<li><a href="http://blog.jobbole.com/20304/" target="_blank" rel="noopener">分布式系统编程，你到哪一级了？</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2018/01/01/Raft-实现指北-开篇/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/01/Raft-实现指北-开篇/" itemprop="url">Raft 实现指北-开篇</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-01T09:34:16+08:00">
                2018-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Destribution/" itemprop="url" rel="index">
                    <span itemprop="name">Destribution</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/01/01/Raft-实现指北-开篇/" class="leancloud_visitors" data-flag-title="Raft 实现指北-开篇">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Raft 是一种解决分布式共识问题的算法。何为分布式共识问题？在此之前，还得说说分布式系统中的基础模型。基础模型是对分布式算法的一个定性的评估（分类）标准，它说明了算法的作用范围，可解决什么问题。</p>
<h1 id="基础模型"><a href="#基础模型" class="headerlink" title="基础模型"></a>基础模型</h1><p>基础模型也可以称为算法的属性，这里主要关心两个部分：定时模型（Timing Model）、失效模式（Failure Model）、失效检测器（Failure Detectors）[1]。</p>
<p>定时模型是研究分布式系统的网络传输时延特性，分布式系统通过消息传递来进行通信，根据消息在网络中传递时间是否有上界，可以将消息系统分类为：<strong>同步模型（Synchronous Model）</strong>和<strong>异步模型（Asynchronous Model）</strong>[2]。在同步模型中，消息传递时间是已知的，每个进程的速度也是确定的，即每个进程执行一个算法步骤耗时是确定的。在异步模型中，每个组件自行决定算法步骤的执行顺序，每一步的耗时也没有保证[1]。注意，这里的<em>同步</em>和<em>异步</em>要与编程中出现的同步异步加以区分。</p>
<p>失效模式是对分布式系统中节点失效种类的假设。最基础的是<strong>崩溃-结束（crash-stop）失效模式</strong>，节点一直正常运行，直至崩溃，节点崩溃后不会恢复。相较于崩溃-结束失效模式，另一种<strong>崩溃-恢复（crash-recovery）失效模式</strong>更为常见，即节点崩溃后，会被恢复。值得一提的是崩溃-恢复模式中，一个节点恢复时，并不等同于没崩溃的原始节点（比如 Raft 算法动态调整系群组关系，某个节点被另一个新加入节点顶替）。一种更复杂的失效模式叫做<strong>拜占庭失效模式</strong>或者<strong>任意失效模式（Byzantine or arbitrary failures mode）</strong>：进程有可能向同伴发送错误的信息；进程可能是冒充的；应答给其他进程的数据是正确的，但是篡改了本地数据库的内容，等等[2]。设计分布式系统时，失效模式必须考虑进去，通常来说，我们并不需要考虑拜占庭失效模式。</p>
<p>上述两种属性能够描述分布式系统所处的问题，另外还有部分属性用于对系统工作方式进行分类，失效检测器便是这样的一种属性。<strong>失效检测器</strong>是对<em>报告系统状态</em>的抽象，即检测节点是否已经崩溃（或者怀疑是否崩溃）。失效检测器是在异步系统中解决共识问题的关键。在著名的FLP论文中指出，在异步的分布式系统中，如果进程有可能失效，那么就不可能达成共识。要达成共识，就必须为系统引入一个能够规避上述问题的失效检测器[1]。</p>
<h1 id="分布式共识问题"><a href="#分布式共识问题" class="headerlink" title="分布式共识问题"></a>分布式共识问题</h1><p>分布式共识问题，简单说，就是在一个或多个进程提议了一个值应当是什么后，使系统中所有进程对这个值达成一致意见。为了达到共识，每个进程都提出自己的提议（propose），最终通过共识算法，所有正确运行的进程决定（decide）相同的值[2]。</p>
<p>在同步、可靠的系统中，想要多个节点达成一致比较容易。实际的分布式场景多为异步模型，FLP不可能性说明：没有任何算法可以在存在任何故障的异步系统中确保达到共识，绕过不可能性结论的办法是考虑部分同步系统，利用故障屏蔽、故障检测器或随机化手段避开异步系统模型[2]。</p>
<p>分布式问题最常见的应用场景是多副本状态机（Replicated state machine）。<strong>多副本状态机是指多台机器具有完全相同的状态，并且运行有完全相同的确定性状态机</strong>[2]。多副本状态机主要用于解决分布式系统中的容错问题，因为副本冗余了状态机，只要保证大多数副本存活且一致，就能向外部提供服务。多副本状态机的实现思想：状态机的每个副本上都保存有完全相同的操作日志，保证所有副本状态机按照相同的顺序执行操作，这样由于状态机是确定性的，则一定会得到相同的状态[2]。具体的实现方式主要分为两种[3]：</p>
<ul>
<li>日志复制：由 primary 机接受操作日志，并广播给 backup 机，backup 机需要跟 primary 机的操作日志保持一致；</li>
<li>状态重演：操作日志由多个副本共享，每个副本通过重新执行操作日志从放状态；</li>
</ul>
<h1 id="Raft-算法"><a href="#Raft-算法" class="headerlink" title="Raft 算法"></a>Raft 算法</h1><p>有三种非常具有代表性的分布式共识算法：分别是 Viewstamped Replication 、Raft 和大名鼎鼎的 Paxos 算法，前两个工作本身就是基于多副本状态机的场景完成的，而 Paxos 算法是作为独立的分布式共识算法提出，并给出了使用该算法实现多副本状态机的范例[2]。</p>
<p>Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。从一个用户研究的结果可以证明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性[4]。</p>
<p>与其他共识算法相比，Raft 算法有三个特点[4]：</p>
<ul>
<li>强领导者：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。</li>
<li>领导选举：Raft 算法使用一个随机计时器来选举领导者。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。</li>
<li>成员关系调整：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。</li>
</ul>
<p>虽然这篇文章标题有“Raft 实现”关键字，但并不会讲 Raft 算法的原理，这只是 Raft 的功能实现介绍，所以我建议在继续阅读之前，先学习一下 Raft 算法：<a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">寻找一种易于理解的一致性算法（扩展版）</a>。</p>
<h1 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h1><p>一个基础的 Raft 功能只需要实现选举和日志复制，但这远远不够。想要应用到实际的工程中，还需要实现日至压缩、成员关系调整，才算完整的 Raft 实现。这里给出个 Raft 功能清单，实际上也是本系列文章希望实现的功能：</p>
<ul>
<li>leader election</li>
<li>prevote </li>
<li>log replication </li>
<li>log compaction &amp; snapshot </li>
<li>linearizable read(read index &amp; lease)</li>
<li>membership change </li>
<li>leadership transfer</li>
</ul>
<p>拥有上述功能可以算上一个工业级的 Raft 实现，不过在实际应用中，还会有许多工业上的优化技巧比如 Batch 和 Pipeline，具体有哪些可以优化的，放到以后的章节详述。</p>
<p>这是我在学习 Raft 算法，并以之为基础实现分布式系统过程中的学习总结。在接下来的几篇文章中，将按照上述清单依次谈谈对应的实现方法和优化原理。实现方法参考优秀的开源实现：etcd/raft 以及其各语言移植版本。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="http://alvaro-videla.com/2015/12/learning-about-distributed-systems.html" target="_blank" rel="noopener">WHAT WE TALK ABOUT WHEN WE TALK ABOUT DISTRIBUTED SYSTEMS</a></li>
<li><a href="http://blog.kongfy.com/2016/05/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86consensus%EF%BC%9Aviewstamped%E3%80%81raft%E5%8F%8Apaxos/" target="_blank" rel="noopener">分布式共识(Consensus)：Viewstamped Replication、Raft以及Paxos</a></li>
<li>The design of a practical system for Fault-Tolerant Virtual Machines</li>
<li><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">寻找一种易于理解的一致性算法（扩展版）</a></li>
<li><a href="http://blog.jobbole.com/20304/" target="_blank" rel="noopener">分布式系统编程，你到哪一级了？</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/12/07/Mysql 事务隔离级别的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/07/Mysql 事务隔离级别的使用/" itemprop="url">Mysql 事务隔离级别的使用</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-07T15:00:00+08:00">
                2017-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/07/Mysql 事务隔离级别的使用/" class="leancloud_visitors" data-flag-title="Mysql 事务隔离级别的使用">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在项目中遇到一个问题，在 Mysql 的 Repeatable Read 隔离级别下，出现了数据丢失更新。一开始怀疑的是事务失效，被排查后否定。最后定位到 Mysql 事务的使用问题上。我们的 Sql 场景类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT number FROM A WHERE ID = 1;</span><br><span class="line">UPDATE A SET NUMBER = number + 1 WHERE ID = 1;</span><br></pre></td></tr></table></figure>
<h2 id="事务回顾"><a href="#事务回顾" class="headerlink" title="事务回顾"></a>事务回顾</h2><p>事务有四种特性（ACID）：</p>
<ul>
<li>原子性</li>
<li>隔离性</li>
<li>一致性</li>
<li>持久性</li>
</ul>
<p>在执行事务时可能出现以下问题：</p>
<ul>
<li>丢失更新：<ol>
<li>第一类丢失更新：事务失败回滚时将其他事务已经提交的数据覆盖</li>
<li>第二类丢失更新：事务提交时，覆盖了其他事务的提交（类似 += ，是不可重复读的特例）</li>
</ol>
</li>
<li>脏读：事务读取了其他事务还未提交的内容</li>
<li>不可重复读：一个事务中多次读取同一个内容，结果不一致</li>
<li>幻读：一个事务中两次查询，但第二次查询比第一次查询多了或少了几行或几列数据</li>
</ul>
<p>为了解决上述问题，数据库系统提供了四种事务隔离级别供用户选择：</p>
<ul>
<li>Read Uncommitted 读未提交：不允许第一类更新丢失。允许脏读，不隔离事务。</li>
<li>Read Committed 读已提交：不允许脏读，允许不可重复读。</li>
<li>Repeatable Read 可重复读：不允许不可重复读。但可能出现幻读。</li>
<li>Serializable 串行化：所有的增删改查串行执行。</li>
</ul>
<p>在传统的事务隔离级别的实现中，可重复读已经能够避免了两类丢失更新，对于绝大多数的事务，只需要将<br>隔离级别设置为可重复读。</p>
<h2 id="Snapshot-isolation-amp-MVCC"><a href="#Snapshot-isolation-amp-MVCC" class="headerlink" title="Snapshot isolation &amp; MVCC"></a>Snapshot isolation &amp; MVCC</h2><p>需要明确的是，以上的ACID和隔离级别定义是在SQL规范层面的定义，不同数据库的实现方式和使用方式并不相同。上面的隔离级别标准是SQL92 基于读写锁的实现方式制定的规范。</p>
<p>为了克服并发问题，各个数据库厂商都引入了 MVCC （多版本并发控制）来提高并发度。所以实际上的事务实现与规范定义的出现了细微的差别，而这细微的差别，就是本文出现的原因。（下文主要以 Mysql innoDB 存储引擎的 MVCC 实现为主，InnoDB 中的 MVCC 为表添加了隐藏的列，打上版本号，来提供多版本功能）。</p>
<p>所以在 MVCC 中，SELECT 语句执行时，会执行快照读取（称为快照读，也称为一致性读）。如果数据被锁，直接读取 undo log 来读取其被锁前的副本。在 Read Commit 隔离级别中，快照读总是读取对应行的最新版本；如果该行被锁住，则会读取最近一次的快照。在 Repeatable Read 隔离级别中，快照读总是读取事务开始时的数据版本。</p>
<p>这种方式极大的提升了并发读取的效率，本质也非常类似乐观锁。所以这种方式实现的隔离级别与规范定义存在一定差异，在 Repeatable Read 中，这种差异导致了 innoDB 第二类更新丢失的出现。因此，使用 MVCC 实现的隔离级别也被称为快照隔离级别。</p>
<p>SI 隔离与规范的 RR 隔离级别的区别在于读取 SI 的 SELECT 语句为快照读，而传统的 SELECT 语句则为当前读（加读锁:locking read, LR）。</p>
<p>在 InnoDB 中，update, delete 执行的是加锁读，想要将 SELECT 语句也设置为加锁读，需要在语句后加上 FOR UPDATE, LOCK IN SHARE MODE。具体的加锁方式取决于用户使用的是那种查询计划：</p>
<ul>
<li>unique index with a unique search condition</li>
<li>a range-type search condition</li>
</ul>
<p>对于第一种方式，InnoDB 只对其所在的索引进行加锁，不影响其他内容。对于第二种方式，InnoDB 通过使用间隙锁（gap locks)或者 next-key locks 来实现。因为这种加锁落实到区间上，所以也有可能锁住不必要的内容。因此 InnoDB 也号称在 RR 级别上实现了 Serializable 隔离级别。</p>
<p>next-key locks 能排除大多数的幻读现象，只会存在 write skew style 的幻读。</p>
<p>回到题目最开始的问题上，因为这种不规范的事务实现，导致了在高并发情况下会存在第二类丢失更新问题。只需要在 SELECT 后面加上 FOR UPDATE 就能避免出现的问题。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://www.jianshu.com/p/71a79d838443" target="_blank" rel="noopener">事务并发的问题以及其解决方案</a></li>
<li><a href="http://www.fanyilun.me/2015/12/29/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8AMysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">事务隔离级别与 Mysql 中事务的使用</a></li>
<li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="noopener">Consistent Nonlocking Reads</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">innodb-transaction-isolation-levels</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/09/07/个人站点：Mysql-5-6-内存占用配置/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/个人站点：Mysql-5-6-内存占用配置/" itemprop="url">个人站点：Mysql 5.6 内存占用配置</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-07T22:58:09+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux-服务器/" itemprop="url" rel="index">
                    <span itemprop="name">Linux 服务器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/09/07/个人站点：Mysql-5-6-内存占用配置/" class="leancloud_visitors" data-flag-title="个人站点：Mysql 5.6 内存占用配置">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前两天刚把服务器部署上，今天就出现了异常。在 App 上看是服务器直接宕机。原本以为仅仅是服务端挂了，在服务器上使用 <code>ps aux | grep java</code> 发现进程还在，只是不服务了。打开 log 发现 Java run out of memory，导致无法创建新的线程。</p>
<p>使用 <code>top -o %MEM</code> 查看，java 占用近 200M，mysql 占用近 500 M。因为是个人用的小服务器，只有 1G 内存，吃紧得很。既然 mysql 占用了最多的内存，就让它吐出一点好了。</p>
<p>一开始猜测是 InnoDB 缓冲区过大，不过在 <code>/etc/mysql/my.cnf</code> 中发现配置的缓存已经非常小了。后来在网上发现是因为 Mysql 5.6 版本默认 GA 配置过大，导致初始需要近 400M 空间。通过下面配置，直接讲内存降到 100M 以下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performance_schema_max_table_instances=400</span><br><span class="line">table_definition_cache=400</span><br><span class="line">table_open_cache=256</span><br></pre></td></tr></table></figure>
<p>参数意义：</p>
<ul>
<li><code>performance_schema_max_table_instances</code></li>
</ul>
<p>The maximum number of instrumented table objects</p>
<p>检测的表对象的最大数目。</p>
<ul>
<li><code>table_definition_cache</code></li>
</ul>
<p>The number of table definitions (from .frm files) that can be stored in the definition cache. If you use a large number of tables, you can create a large table definition cache to speed up opening of tables. The table definition cache takes less space and does not use file descriptors, unlike the normal table cache. The minimum and default values are both 400. </p>
<p>缓存 <code>frm</code> 文件</p>
<ul>
<li><code>table_open_cache</code><br>The number of open tables for all threads. Increasing this value increases the number of file descriptors that mysqld requires. </li>
</ul>
<p><code>table_open_cache</code> 指的是缓存数据文件的描述符(Linux/Unix)相关信息</p>
<p>在 5.6 中的默认配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performance_schema_max_table_instances 12500</span><br><span class="line">table_definition_cache 1400</span><br><span class="line">table_open_cache 2000</span><br></pre></td></tr></table></figure>
<p><em>References:</em></p>
<ul>
<li><a href="http://www.cnblogs.com/yum777/p/6554901.html" target="_blank" rel="noopener">解决 Mysql 内存占用巨大问题</a></li>
<li><a href="http://blog.csdn.net/wulantian/article/details/41119755" target="_blank" rel="noopener">MySQL 5.6内存占用过高解决方案</a></li>
<li><a href="http://bbs.csdn.net/topics/390724779" target="_blank" rel="noopener">linux 下mysql内存占用过高</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/08/26/CSKS-三-、设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/CSKS-三-、设计模式/" itemprop="url">CSKS-(三)、设计模式</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-26T10:00:49+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/26/CSKS-三-、设计模式/" class="leancloud_visitors" data-flag-title="CSKS-(三)、设计模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面对对象原则"><a href="#面对对象原则" class="headerlink" title="面对对象原则"></a>面对对象原则</h1><ul>
<li>单一职责：不要存在多于一个导致类变更的原因；通俗的说，即一个类只负责一项职责；</li>
<li>里氏替换：所有引用基类的地方必须能透明地使用其子类的对象；通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能；</li>
<li>依赖倒置：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；</li>
<li>接口隔离：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上；</li>
<li>迪米特法则：一个对象应该对其他对象保持最少的了解；</li>
<li>开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭；</li>
</ul>
<h1 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h1><p><em>References</em></p>
<ul>
<li><p><a href="http://www.jianshu.com/p/dbc8a279165d" target="_blank" rel="noopener">设计模式大总汇</a></p>
</li>
<li><p>单例模式：确保整个程序中只有一个实例，并自行实例化以向整个体统提供实例</p>
</li>
<li>工厂方法模式：将实例的创建延迟到子类</li>
<li>抽象工厂模式：为创建一组相互依赖的对象提供一个接口，并将创建过程延迟到子类</li>
<li>建造者模式：将一个复杂对象的创建和表示分离开来，使得同一个创建过程可以得到不同的表示</li>
<li>原型模式：</li>
<li>迭代器模式：在不暴露内部实现的情况下，使客户可以遍历容器内部对象</li>
<li>责任联模式：将对象连成一条链，并沿着这条链传递该请求，直到有对象处理该请求位置，解决了发送方和接收方的耦合</li>
<li>桥梁模式：将抽象和实现解耦，使两者可以独立变化</li>
<li>适配器模式：将一个对象的接口转换成另一个对象期待的接口，从而使原本不匹配的对象能在一起工作</li>
<li>中介者模式：将一系列对象的交互封装起来，使其耦合松散，而且可以独立变化</li>
<li>观察者模式：定义一种1-N的关系，使得当一个对象更新时，所有依赖它的对象都能收到通知并响应</li>
<li>命令模式：将客户参数化，使得客户请求可以记录、排队，并能实现撤销，恢复等功能</li>
<li>亨元模式：使用共享对象可以有效的支持大量细粒度的对象</li>
<li>状态模式：当一个对象状态改变时改变其行为，使得对象看起来像是改变了类</li>
<li>解释器模式：定义一组语言及其解释器</li>
<li>访问者模式：定义一组接口，从而是现在不改变数据结构自身的情况下添加职责</li>
<li>装饰器模式：动态的为一个对象添加一些额外的职责，比生成子类要简单</li>
<li>代理模式：提供一种代理以控制对对象的访问</li>
<li>策略模式：定义并封装一组可以互换的算法</li>
<li>模板方法模式：定义一个算法的骨架，将一些具体步骤延迟到子类。使得子类可以不改变算法结构即重定义算法特定步骤</li>
<li>组合模式：</li>
<li>门面模式：</li>
<li>备忘录模式：</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式重点在两个方面：</p>
<ul>
<li>系统只有一个实例；</li>
<li>自行实例化并向整个系统提供这个实例；</li>
</ul>
<p>单例模式的实现上有两个重要的因素：</p>
<ul>
<li>线程安全；</li>
<li>延迟加载；</li>
</ul>
<p>延迟加载技术可以解耦依赖链与初始化顺序。如果单例在程序执行前就进行初始化，某一个单例的初始化过程中，又引用到了另一个单例，便出现了加载顺序的决议问题。而使用延迟加载技术将这种依赖过程与初始化顺序进行了自动决议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleston * sing = NULL;</span><br><span class="line">  <span class="keyword">if</span> (sing == NULL) &#123;</span><br><span class="line">    sing = <span class="keyword">new</span> Singleston;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程安全方面则根据语言不同而有所差异，以 C++ 为例，C++11 标准规定了局部静态变量初始化的线程安全特性，所以写起来非常方便：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Class ins;</span><br><span class="line">  <span class="keyword">return</span> ins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照这种写法不仅线程安全，同时还解决了依赖问题。如果不想用这种办法，也可以使用标准库提供的：<code>call_once()</code> 函数。</p>
<p>Java 在方面就要麻烦得多，我个人比较偏爱的是 DCL 这种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleston</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleston instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="keyword">synchronized</span>(Singleston.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">        instance = <span class="keyword">new</span> Singleston;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 版本的 DCL 需要注意使用 <code>volatile</code> 修饰，从 1.5 版本开始这种写法已经不存在问题了。</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式用于将一个复杂对象的建造过程和表示过程分开。这种比较适合一旦创建好后不会怎么更改的对象。在 Android 中的 <code>AlertDialg</code> 就使用这种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Builder(<span class="keyword">this</span>)</span><br><span class="line">      .setMessage(<span class="string">"are you sure?"</span>)</span><br><span class="line">      .setTitle(<span class="string">"tips"</span>)</span><br><span class="line">      .setPositiveButtion(<span class="string">"yes"</span>, <span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">          dialog.dismiss();</span><br><span class="line">          Main.<span class="keyword">this</span>.finish();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .setNegativeButton(<span class="string">"No"</span>, <span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">          dialog.dismiss();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .create()</span><br><span class="line">      .show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无独有偶，在 Java 著名网络库 Netty 中，创建 <code>Channel</code> 也是使用建造者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap b = <span class="keyword">new</span> Bootstrap();  </span><br><span class="line">b.group(group)  </span><br><span class="line">    .channel(NioSocketChannel.class)  </span><br><span class="line">    .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)  </span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line"></span><br><span class="line">ChannelFuture f = b.connect(host, port).sync();</span><br></pre></td></tr></table></figure>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>容器需要提供用户一个访问机制，而又不暴露内部细节，这种方法就叫迭代器模式。C++ 和 Java 中均有迭代器模式的影子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arrays;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">auto</span> it = arrays.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">ArrayList&lt;Integer&gt; arrays = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Iterator&lt;Integer&gt; it = arrays.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>如其名，整个处理过程就像链一样，一级一级传递下去，从而接触了发送方和接收方的耦合。责任链模式常见于各种事件处理机制，比如 Android 的事件处理机制、Win32 中的消息机制。责任链模式的显著特点是如果一个事件（消息）在当前处理逻辑中不处理，就将其传递给下一级处理逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(Message msg, Handler handle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (msg) &#123;</span><br><span class="line">    <span class="keyword">case</span> xxx: ...; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: handle.slove(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h2><p>将抽象和实现解耦的就是桥梁模式。通常在设计时，不要传播设计，而桥梁模式正好可以处理。比如一开始只有一台实验仪器，所以用单例模式来表示，某一天实验室又购进了一台新的仪器，那么之前所有引用单例的代码都要修改。而设计时如果将获取设备接口和单例分开，就没有这么多麻烦了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDevice</span> &#123;</span></span><br><span class="line">    <span class="comment">// singleston </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Device <span class="title">getByRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingleDevice.getInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>桥梁模式的另一个常见用途在 C++ 中，常用于实现减少 C++ 头文件编译负担：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AImpl</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;AImpl&gt; impl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>:AImpl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> A::<span class="keyword">do</span>() &#123;</span><br><span class="line">  impl-&gt;<span class="keyword">do</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式可以使两个不兼容的接口一起工作，有 Andoird 开发经验的一定对 Adaptor 非常熟悉，这里不细讲。</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式把两个独立对象的一系列操作封装起来，把这两个对象之间的联系解耦，这样两个对象不依赖对方，可以独立变化。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>解耦操作最好的还属观察者模式。观察者模式重新定义了对象之间的依赖关系，将原有的监听操作转变为通知操作。</p>
<p>关于使用观察者模式，比较典型的例子是控件事件的监听–在指定控件上绑定一个回调函数，事件发生的时候，控件负责调用该函数通知用户。在 Java 中大名鼎鼎的响应式库 RxJava 就是以观察者模式为基础，还解决了长期以来困扰的 Callback hell 问题。Vue.js 中实现数据绑定也是以观察者模式为基础的。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式最重要的一点就是将客户端的请求参数化，从而实现请求排队、记录回滚等。在游戏中，命令模式可以将用户对角色控制的输入进行参数化，实现死亡回放等。在服务器开发中，将客户端的请求参数化，并放入请求队列，实现流量控制。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>说到命令模式不得不提状态模式，以任务操纵为例，人在地面上可以进行跳跃，而在跳跃的过程中则不可以。那么对于相同的命令，在不同的状态下有不同的响应，这就是状态模式。状态模式可以在改变对象状态的同时改变对象的行为。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>游戏中地图大量元素存在重复的情况，大量创建相同的对象非常浪费内存，此时可以创建几个单例，让地图引用具体的单例，这就是享元模式。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>现在很多游戏的基本框架由 C/C++ 来写，具体业务逻辑则交给 lua 之类的脚本处理。如果是自己设计的脚本，那么就需要写出对应的解释器： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Value <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  Expr * left, * right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 解释器模式</span></span><br></pre></td></tr></table></figure>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>一开始我们只提供了游戏脚本解释器的解释功能，某次调试的时候希望将具体的抽象语法书打印出来，所以在每个元素类中添加了打印支持：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Value <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Value <span class="title">dump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    left-&gt;dump();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">    right-&gt;dump();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  Expr * left, * right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每当出现一个新的需求时，都要对原有的数据结构进行修改。而访问者模式为我们提供了遍历，可以在不修改数据结构的同时增加数据结构上的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Expr *ptr)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Value *ptr)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor *visitor)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expr</span> :</span> <span class="keyword">public</span> Visitable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor *visitor)</span> </span>&#123;</span><br><span class="line">    visitor-&gt;visit(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dump</span> :</span> <span class="keyword">public</span> Visitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Value * v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Expr * e)</span> </span>&#123;</span><br><span class="line">    e-&gt;left-&gt;accept(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e-&gt;c;</span><br><span class="line">    e-&gt;right-&gt;accept(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式可以在不继承对象的同时给对象增加操作。Python 中有一个装饰器的概念，比如我们要给原来的函数添加上调用记录到日志的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>与之类似的还有 Java 提供的注解功能，这里不展开。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>说到代理，常见有 VPN、HTTP Proxy ，代理模式用于控制对对象的访问。比如实现一个 RPC 功能，在客户端定义一个接口，由代理服务生成接口对应的实例。客户在调用接口时，代理服务监测并将请求转发给服务器，等到服务端计算完成并返回时，代理服务把结果返回给客户端。从客户端的角度上，这个过程和调用一个耗时的函数没有区别。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/08/26/CSKS-二-、数据库系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/CSKS-二-、数据库系统/" itemprop="url">CSKS-(二)、数据库系统</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-26T09:58:09+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/26/CSKS-二-、数据库系统/" class="leancloud_visitors" data-flag-title="CSKS-(二)、数据库系统">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><p>现在主流的数据库系统主要是关系数据库。关系数据库使用集合代数等概念和方法来处理数据库中的数据，同时数据组织成描述性的表格。关系数据库通常由三级模式两层映像组成。在具体设计数据库的时候，通常使用范式来对数据库进行约束设计。</p>
<p>近些年 NoSQL（非关系型数据库）应用也比较多，主要以 Key-Value 类数据库为主，比如 Redis。</p>
<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p><em>References</em></p>
<ul>
<li><a href="http://baike.baidu.com/link?url=IOAIJlfSxYMpboZE_on0EAaeqZbdplcD4PvK6rzlwEw_v0ulRPQXEV-3Yfvhd5aNr-0jfW8d6XDidC3O-42tElXbQ3ixxfDyfGwASgxMhxRupcFaRcNTqlhkBA0RnEMS" target="_blank" rel="noopener">关系代数</a></li>
<li><a href="http://www.hashcoding.net/2017/08/26/CSKS-%E4%B8%80-%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/#B-树">数据库底层结构 - B 树</a></li>
</ul>
<h2 id="SQL-语言"><a href="#SQL-语言" class="headerlink" title="SQL 语言"></a>SQL 语言</h2><p>SQL 语言共分为四大类：</p>
<ul>
<li>数据查询语言 DQL</li>
<li>数据操纵语言 DML</li>
<li>数据定义语言 DDL</li>
<li>数据控制语言 DCL</li>
</ul>
<h3 id="数据查询语言DQL"><a href="#数据查询语言DQL" class="headerlink" title="数据查询语言DQL"></a>数据查询语言DQL</h3><p>数据查询语言 DQL 基本结构是由 <code>SELECT</code> 子句，<code>FROM</code> 子句，<code>WHERE</code> 子句组成的查询块：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;字段名表&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;表或视图名&gt;</span><br><span class="line"><span class="keyword">WHERE</span> &lt;查询条件&gt;</span><br></pre></td></tr></table></figure>
<h3 id="数据操纵语言DML"><a href="#数据操纵语言DML" class="headerlink" title="数据操纵语言DML"></a>数据操纵语言DML</h3><p>主要有三种形式：</p>
<ul>
<li>插入：<code>INSERT</code></li>
<li>更新：<code>UPDATE</code></li>
<li>删除：<code>DELETE</code></li>
</ul>
<h3 id="数据定义语言-DDL"><a href="#数据定义语言-DDL" class="headerlink" title="数据定义语言 DDL"></a>数据定义语言 DDL</h3><p>数据定义语言 DDL 用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>/<span class="keyword">VIEW</span>/<span class="keyword">INDEX</span>/SYN/CLUSTER</span><br><span class="line"><span class="keyword">ALTER</span></span><br><span class="line"><span class="keyword">DROP</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>DDL 操作是隐性提交的！不能 rollback。</p>
</blockquote>
<h3 id="数据控制语言-DCL"><a href="#数据控制语言-DCL" class="headerlink" title="数据控制语言 DCL"></a>数据控制语言 DCL</h3><p>数据控制语言 DCL 用来授予或回收访问数据库的某种特权，并控制<br>数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p>
<ul>
<li><code>GRANT</code>：授权</li>
<li><code>ROLLBACK [WORK] TO [SAVEPOINT]</code>：回退到某一点。</li>
<li><code>COMMIT [WORK]</code>：提交</li>
</ul>
<p>回滚—<code>ROLLBACK</code> 回滚命令使数据库状态回到上次最后提交的状态。其格式为: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; ROLLBACK;</span><br></pre></td></tr></table></figure>
<p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/tomatofly/article/details/5949070" target="_blank" rel="noopener">DQL、DDL、DML、DCL</a></li>
<li><a href="http://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">SQL语言入门</a></li>
<li><a href="http://blog.csdn.net/ws0513/article/details/49980547" target="_blank" rel="noopener">drop、truncate和delete的区别</a></li>
<li><a href="http://www.cppblog.com/init/articles/204159.html" target="_blank" rel="noopener">数据库中视图的作用</a></li>
</ul>
<h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h2><p>数据库范式是指数据库中数据满足的某种约束，用来指导数据库设计。随意设计的数据库可能存在数据冗余、插入异常、更新异常、删除异常等。数据库范式用于减少或消除上述异常。</p>
<p>数据库范式分为：1NF,2NF,3NF,BCNF,4NF,5NF。通常设计时只需要考虑到 BCNF。符合高一级的范式，必定符合低一级范式。</p>
<h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p><strong>1NF的定义为：符合1NF的关系中的每个属性都不可再分</strong>。实际上，1NF 是所有关系型数据库的最基本要求，你在关系型数据库管理系统（RDBMS），例如 SQL Server，Oracle，MySQL 中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在 RDBMS 中已经存在的数据表，一定是符合 1NF 的。</p>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p><strong>函数依赖指出了一张表中属性之间的函数关系：将属性分为 X,Y 两组，对于任意的 X 满足 X 相同时 Y 一定相同，即 X 值确定的情况下，Y 的值也能确定，此时称为 X → Y</strong>。从“函数依赖”这个概念展开，还有两个概念：</p>
<ul>
<li><p>完全函数依赖：在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X’ → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 X F→ Y。</p>
</li>
<li><p>部分函数依赖假：如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X  P→ Y，</p>
</li>
</ul>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p><strong>设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码</strong>。在实际中我们通常可以理解为：假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为主码）。</p>
<p>在任意一个码中的属性称为主属性，与之对应的就是非主属性。</p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p><strong>2NF的定义为：非主属性不部分地依赖于码</strong>。第二范式要求数据具有唯一性。以学生、学校、学校地址(st,sc,addr)为例，其中学生、学校为主属性，学校地址只依赖于学校，不满足第二范式。如果新办了座学校，校内还没有学生上课，那么就无法插入数据（插入异常）；如果学校地址改变了，需要对每一条数据中的学校地址都进行更新，非常麻烦（更新异常）。</p>
<h3 id="2NF-1"><a href="#2NF-1" class="headerlink" title="2NF"></a>2NF</h3><p><strong>3NF的定义为：非主属性不传递地依赖于码</strong>。第三范式要求任何非主属性不能由其他属性派生出来。</p>
<h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p><strong>BCNF的定义为：主属性既不部分地依赖于码，也不传递地依赖于码</strong>。BCNF 要求主属性之间满足唯一且不能由其他属性派生出来。</p>
<p>关于范式的详解可以参考：<a href="https://zhuanlan.zhihu.com/p/20028672" target="_blank" rel="noopener">数据库第一二三范式到底在说什么？</a>。</p>
<h2 id="数据库完整性约束"><a href="#数据库完整性约束" class="headerlink" title="数据库完整性约束"></a>数据库完整性约束</h2><p>关系完整性是为保证数据库中数据的正确性和相容性，对关系模型提出的某种约束条件或规则。完整性通常包括域完整性，实体完整性、参照完整性和用户定义完整性，其中域完整性，实体完整性和参照完整性，是关系模型必须满足的完整性约束条件。</p>
<p>域完整性约束：域完整性是保证数据库字段取值的合理性。属性值应是域中的值，这是关系模式规定了的。除此之外，一个属性能否为 NULL，这是由语义决定的，也是域完整性约束的主要内容。域完整性约束是最简单、最基本的约束。在当今的关系 DBMS 中，一般都有域完整性约束检查功能。包括检查（CHECK）、默认值（DEFAULT）、不为空（NOT NULL）等。</p>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p><strong>实体完整性是指关系的主关键字不能重复也不能取“空值”。</strong>一个关系对应现实世界中一个实体集。现实世界中的实体是可以相互区分、识别的，也即它们应具有某种惟一性标识。在关系模式中，以主关键字作为惟一性标识，而主关键字中的属性(称为主属性)不能取空值，否则，表明关系模式中存在着不可标识的实体(因空值是“不确定”的)，这与现实世界的实际情况相矛盾，这样的实体就不是一个完整实体。按实体完整性规则要求，主属性不得取空值，如主关键字是多个属性的组合，则所有主属性均不得取空值。</p>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p><strong>参照完整性是定义建立关系之间联系的主关键字与外部关键字引用的约束条件。</strong>关系数据库中通常都包含多个存在相互联系的关系，关系与关系之间的联系是通过公共属性来实现的。所谓公共属性，它是一个关系 R (称为被参照关系或目标关系)的主关键字，同时又是另一关系 K (称为参照关系)的外部关键字。如果参照关系 K 中外部关键字的取值，要么与被参照关系 R 中某元组主关键字的值相同，要么取空值，那么，在这两个关系间建立关联的主关键字和外部关键字引用，符合参照完整性规则要求。如果参照关系 K 的外部关键字也是其主关键字，根据实体完整性要求，主关键字不得取空值，因此，参照关系 K 外部关键字的取值实际上只能取相应被参照关系 R 中已经存在的主关键字值。</p>
<h3 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h3><p>实体完整性和参照完整性适用于任何关系型数据库系统，它主要是针对关系的主关键字和外部关键字取值必须有效而做出的约束。<strong>用户定义完整性则是根据应用环境的要求和实际的需要，对某一具体应用所涉及的数据提出约束性条件</strong>。这一约束机制一般不应由应用程序提供，而应有由关系模型提供定义并检验，用户定义完整性主要包括字段有效性约束和记录有效性。</p>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p><strong>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</strong> 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。</p>
<h3 id="事务的-ACID"><a href="#事务的-ACID" class="headerlink" title="事务的 ACID"></a>事务的 ACID</h3><h4 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h4><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<h4 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h4><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。换句话说就是：事务开始和结束之间的中间状态不会被其他事务看到。</p>
<h4 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h4><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>隔离性主要涉及到事务的并发控制，根据不同的并发控制策略，可能出现脏读、不可重复读、幻读。</p>
<h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p><strong>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据</strong>。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户 A 向用户 B 转账 $100$ 元，对应 SQL 命令如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money+<span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’B’;  (此时A通知B)</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money<span class="number">-100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’A’;</span><br></pre></td></tr></table></figure>
<p>当只执行第一条 SQL 时，A 通知 B 查看账户，B 发现确实钱已到账（此时即发生了脏读），而之后无论第二条 SQL 是否执行，只要该事务不提交，则所有操作都将回滚，那么当 B 以后再次查看账户时就会发现钱其实并没有转。</p>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>不可重复读是指在对于数据库中的某个数据，<strong>一个事务范围内</strong>多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。<strong>不可重复读就是一个事务范围内多次查询结果不同</strong>。例如事务 T1 读取了某一数据，而事务 T2 立马修改了这个数据并且提交事务给数据库，事务 T1 再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<h5 id="虚读-幻读"><a href="#虚读-幻读" class="headerlink" title="虚读(幻读)"></a>虚读(幻读)</h5><p><strong>幻读是事务非独立执行时发生的一种现象</strong>。例如事务 T1 对一个表中所有的行的某个数据项做了从 $1$ 修改为 $2$ 的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为 $1$ 并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
<h4 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h4><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h3 id="事务的-4-种隔离级别"><a href="#事务的-4-种隔离级别" class="headerlink" title="事务的 4 种隔离级别"></a>事务的 4 种隔离级别</h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read uncommitted</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td>Read committed</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td>Repetable read</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td>Serializable</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
</tbody>
</table>
<p>四种隔离级别，重高到低有：</p>
<ul>
<li><code>Serializable</code>  串行化</li>
<li><code>Repeatable read</code> 可重复读</li>
<li><code>Read committed</code> 读已提交</li>
<li><code>Read uncommitted</code> 读未提交</li>
</ul>
<p><code>Serializable</code> 采用的是范围锁 <code>RangeS</code>、<code>RangeS_S</code> 模式，<strong>锁定检索范围为只读</strong>，这样就避免了幻影读问题。<code>Repeatable read</code> <strong>读取数据时加共享锁，写数据时加排他锁，都是事务提交才释放锁</strong>。读取时候不允许其他事物修改该数据，不管数据在事务过程中读取多少次，数据都是一致的，避免了不可重复读问题。<code>Read committed</code> <strong>修改时加排他锁，直到事务提交后才释放，读取时加共享锁，读取完释放</strong>。事务1读取数据时加上共享锁后（这样在事务1读取数据的过程中，其他事务就不会修改该数据），不允许任何事物操作该数据，只能读取，之后1如果有更新操作，那么会转换为排他锁，其他事务更无权参与进来读写，这样就防止了脏读问题。<code>Read uncommitted</code> 相当于不加锁。</p>
<p><em>在 MySQL 数据库中默认的隔离级别为 <code>Repeatable read</code> (可重复读)</em>。</p>
<h3 id="事务的提交和回滚"><a href="#事务的提交和回滚" class="headerlink" title="事务的提交和回滚"></a>事务的提交和回滚</h3><p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。</p>
<p>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分别说明这三种类型。</p>
<h4 id="显式提交"><a href="#显式提交" class="headerlink" title="显式提交"></a>显式提交</h4><p>用 <code>COMMIT</code> 命令直接完成的提交为显式提交。其格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; COMMIT;</span><br></pre></td></tr></table></figure>
<h4 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h4><p>用 SQL 命令间接完成的提交为隐式提交。这些命令是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span>，<span class="keyword">AUDIT</span>，<span class="keyword">COMMENT</span>，<span class="keyword">CONNECT</span>，<span class="keyword">CREATE</span>，<span class="keyword">DISCONNECT</span>，<span class="keyword">DROP</span>，<span class="keyword">EXIT</span>，<span class="keyword">GRANT</span>，<span class="keyword">NOAUDIT</span>，QUIT，<span class="keyword">REVOKE</span>，<span class="keyword">RENAME</span></span><br></pre></td></tr></table></figure>
<h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p>若把 <code>AUTOCOMMIT</code> 设置为 <code>ON</code> ，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SET AUTOCOMMIT ON;</span><br></pre></td></tr></table></figure>
<p>有时执行 SQL 语句会出现异常，又或提交事务失败，总之事务没有成功完成。这种情况下，需要把事务前面执行了的语句回滚，才能保证事务的 ACID。</p>
<p>如果出现了异常导致数据库没有执行到 <code>COMMIT</code>，用户需要手动执行 <code>ROLLBACK</code> 回滚刚才的操作。</p>
<h3 id="undo、redo-与检查点"><a href="#undo、redo-与检查点" class="headerlink" title="undo、redo 与检查点"></a>undo、redo 与检查点</h3><p>数据库刚提交的事务通常存放在缓冲区中，等到缓冲区满或者其他需要写入硬盘的时候，才写入硬盘。数据库通常用日志文件记录操作，<code>undo</code> 日志记录某数据被修改前的值，可以用来在事务失败时进行 <code>rollback</code>；<code>redo</code> 日志记录某数据块被修改后的值，可以用来恢复未写入。</p>
<p>数据库先将操作写入日志文件，然后把数据写入缓冲区。等到时机合适时才将数据持久化到硬盘上。这种顺序保证了数据库故障时恢复最后修改的操作，也可以用于 <code>rollback</code>。当进行恢复操作时，对未提交的操作执行 <code>undo</code>，对提交了的执行 <code>redo</code>。</p>
<p>在持久化时，会记录 checkpoint 发生的”时刻“。在故障回复时候，只需要 <code>redo</code>/<code>undo</code>最近的一次 <code>checkpoint</code> 之后的操作。</p>
<p><em>References</em></p>
<ul>
<li><a href="关于spring手动进行事务提交以及回滚的问题">关于spring手动进行事务提交以及回滚的问题</a></li>
<li><a href="http://www.cnblogs.com/jaejaking/p/5342285.html" target="_blank" rel="noopener">对mysql事务提交、回滚的错误理解</a></li>
<li><a href="http://blog.csdn.net/kobejayandy/article/details/50885693" target="_blank" rel="noopener">理解数据库中的undo日志、redo日志、检查点</a></li>
</ul>
<h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><p>数据库索引是对数据库中一个或多个值进行排序的结构，用于加速数据查询等。数据库索引类似与书籍附录的名词索引，在不用扫描整个数据库表的情况下，允许程序快速找到表中的数据。</p>
<p>索引加快了数据查找速度，提高系统性能。而维护索引需要使用额外的物理空间，同时插入、更新、删除时也需要对索引进行维护。</p>
<p>从底层的视角来看，索引通常以 B+ 树为数据结构。B+ 树是多路搜索树，所以能保证索引的查找速度。对于高纬度如 GIS 数据索引，可以考虑使用 <a href="http://blog.csdn.net/zhouxuguang236/article/details/7898272" target="_blank" rel="noopener">R 树</a>作为数据结构。</p>
<p>从物理空间的角度来看，索引通常分为聚簇索引和非聚簇索引。聚簇索引是指表中的数据存储顺序和索引的顺序一致；非聚簇索引正好相反。因此，聚簇索引一张表只能有一个。非聚簇索引又通常被成为辅助索引。</p>
<p>在实际的程序逻辑中，有主键索引、唯一索引和普通索引。主键索引要求内容不能为空值，唯一索引要求数据不能重复。自然的，主键索引是唯一索引的特殊情况，其要求能唯一确定具体表项。一般情况下，DBMS 会在主键上建立聚簇索引，比如 Mysql 的 Innodb。如果索引不止建立在一列上，就称之为联合索引（与之对应的成为单列索引），一般情况下，联合索引使用时通常按照最左前缀原则匹配。</p>
<p>References</p>
<ul>
<li><a href="https://www.kancloud.cn/kancloud/theory-of-mysql-index/" target="_blank" rel="noopener">Mysql 索引背后的数据结构和算法原理</a></li>
<li><a href="https://my.oschina.net/u/2250599/blog/551423" target="_blank" rel="noopener">Mysql 之辅助索引</a></li>
<li><a href="https://www.kancloud.cn/kancloud/theory-of-mysql-index/41857" target="_blank" rel="noopener">最左前缀原理与相关优化</a></li>
<li><a href="https://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">MySQL索引原理及慢查询优化</a></li>
<li><a href="http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html" target="_blank" rel="noopener">Mysql 索引优化</a></li>
<li><a href="http://blog.csdn.net/barrier9591/article/details/5060638" target="_blank" rel="noopener">索引效率优化</a></li>
<li><a href="https://www.kancloud.cn/thinkphp/mysql-design-optimalize/39320" target="_blank" rel="noopener">慢查询</a></li>
<li><a href="https://www.kancloud.cn/thinkphp/mysql-design-optimalize/39319" target="_blank" rel="noopener">mysql的最佳索引攻略</a></li>
<li><a href="http://blog.csdn.net/gzh0222/article/details/7976127" target="_blank" rel="noopener">Mysql 性能调优三部曲（慢查询、Explain 和 Profile）</a></li>
</ul>
<h1 id="锁与并发控制"><a href="#锁与并发控制" class="headerlink" title="锁与并发控制"></a>锁与并发控制</h1><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>从功能角度来看：</p>
<ul>
<li>共享锁：允许多个读，不允许写；</li>
<li>排他锁：只允许一个读写；</li>
<li><a href="http://www.jianshu.com/p/325a492a859b" target="_blank" rel="noopener">意向锁</a></li>
</ul>
<p>共享锁、排他锁通常有具体作用范围：表、页、行。有时需要给整个表加锁，加锁前需要检查有无事务对某一行加了锁，如果一行一行检测，效率是不可接受的。这种情况下，DBMS 要求事务在某子节点加上读、写锁时，要持有父节点的意向锁；后面加锁的事务只需要检查父节点的意向锁就能得知。</p>
<p>从范围角度来看：</p>
<ul>
<li>行级锁：表示只针对当前操作的行进行加锁</li>
<li>表级锁：表示对当前操作的整张表加锁</li>
<li>页级锁：介于行级锁和表级锁之间</li>
</ul>
<p>下面看看 Mysql 中的行级锁、表级锁及页级锁。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">开销</th>
<th style="text-align:center">速度</th>
<th style="text-align:center">冲突率</th>
<th style="text-align:center">粒度</th>
<th style="text-align:center">并发度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">行级锁</td>
<td style="text-align:center">最大</td>
<td style="text-align:center">最慢</td>
<td style="text-align:center">低</td>
<td style="text-align:center">最小</td>
<td style="text-align:center">最高</td>
</tr>
<tr>
<td style="text-align:center">表级锁</td>
<td style="text-align:center">小</td>
<td style="text-align:center">快</td>
<td style="text-align:center">最高</td>
<td style="text-align:center">最大</td>
<td style="text-align:center">最低</td>
</tr>
<tr>
<td style="text-align:center">页级锁</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
</tr>
</tbody>
</table>
<p><em>References</em></p>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_a1e9c7910102vkg4.html" target="_blank" rel="noopener">Mysql 共享锁、排他锁和意向锁</a></li>
<li><a href="http://www.hollischuang.com/archives/914" target="_blank" rel="noopener">MySQL中的行级锁,表级锁,页级锁</a></li>
</ul>
<h2 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h2><p>整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。<strong>在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁</strong>。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>数据库管理系统（DBMS）中的并发控制的任务是：</p>
<ol>
<li>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性；</li>
<li>统一性以及数据库的统一性；</li>
</ol>
<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段：</p>
<ol>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作；</li>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性；</li>
</ol>
<p>无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。所以，不要把乐观并发控制和悲观并发控制狭义的理解为 DBMS 中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在 DBMS 中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p>
<p>在 Mysql 中，悲观锁通过 <code>select for update</code> 实现，乐观锁则在表中加上 <code>version</code> 字段实现。</p>
<p>具体关于加锁时机可以参考<a href="http://www.importnew.com/21037.html" target="_blank" rel="noopener">深入详解乐观锁和悲观锁</a>、<a href="http://www.digpage.com/lock.html" target="_blank" rel="noopener">乐观锁、悲观锁</a>。</p>
<blockquote>
<p>事务隔离级别和乐观锁、悲观锁的关系：事务隔离级别是并发控制的整体解决方案，其实际上是综合利用各种类型的锁和行版本控制，来解决并发问题。锁是数据库并发控制的内部机制，是基础。对用户来说，只有当事务隔离级别无法解决一些并发问题和需求时，才有必要在语句中手动设置锁。</p>
</blockquote>
<h1 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h1><p>随着业务规模的不断扩大，需要选择合适的方案去应对数据规模的增长，以应对逐渐增长的访问压力和数据量。</p>
<p>关于数据库的扩展主要包括：主从复制、读写分离、数据库分库与分表。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/justdb/article/details/17331569" target="_blank" rel="noopener">MySQL 读写分离</a></li>
<li><a href="http://blog.csdn.net/hguisu/article/details/7325124" target="_blank" rel="noopener">高性能 Mysql 主从架构的复制原理及配置详解</a></li>
<li><a href="http://blog.jobbole.com/94595/" target="_blank" rel="noopener">Mysql 主从复制原理和配置</a></li>
<li><a href="http://www.jianshu.com/p/ab704b437ebd" target="_blank" rel="noopener">Mysql 主从复制(Binary log)</a></li>
<li><a href="http://www.voidcn.com/article/p-fbygsnps-rp.html" target="_blank" rel="noopener">数据库分库分表策略的具体实现方案</a></li>
<li><a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></li>
<li><a href="http://www.infoq.com/cn/articles/summary-and-key-steps-of-vip-orders-depots-table" target="_blank" rel="noopener">唯品会订单分库分表的实践总结已经关键步骤</a></li>
<li><a href="http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table" target="_blank" rel="noopener">分库分表的几种常见形式以及可能遇到的难</a></li>
</ul>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p><em>References</em></p>
<ul>
<li><a href="http://www.ha97.com/2549.html" target="_blank" rel="noopener">MySQL数据库的各种存储引擎详解</a></li>
<li><a href="http://blog.csdn.net/qh_java/article/details/14045827" target="_blank" rel="noopener">MySQL中的存储引擎讲解（InnoDB,MyISAM,Memory等各存储引擎对比）</a></li>
</ul>
<h1 id="Redis-amp-Memcached"><a href="#Redis-amp-Memcached" class="headerlink" title="Redis &amp; Memcached"></a>Redis &amp; Memcached</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Patrick</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/thinkermao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Patrick</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://www.hashcoding.net/gitmint/style/default.css">
        <script src="https://www.hashcoding.net/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("lMQDA5ivsWA2jcjJzTTImuvx-gzGzoHsz", "JIA0x48kG2WhEllWMb31Xt60");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
