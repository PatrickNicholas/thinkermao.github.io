<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato | Open Sans:300,300italic,400,400italic,700,700italic|Courier New bold:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=5.1.4">







  <meta name="keywords" content="Blog, Hashcoding.net, C++, GO, Java, Destribute, 分布式, 存储">





  <link rel="alternate" href="/atom.xml" title="Coding" type="application/atom+xml">






<meta name="description" content="C++, Go, 编译器, 分布式, 存储, 操作系统">
<meta property="og:type" content="website">
<meta property="og:title" content="Coding">
<meta property="og:url" content="http://www.hashcoding.net/page/2/index.html">
<meta property="og:site_name" content="Coding">
<meta property="og:description" content="C++, Go, 编译器, 分布式, 存储, 操作系统">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coding">
<meta name="twitter:description" content="C++, Go, 编译器, 分布式, 存储, 操作系统">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.hashcoding.net/page/2/">





  <title>Coding - 纸上得来终觉浅，绝知此事要躬行</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4c84227c882bfc8efa4a1edc9bc8f47e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">纸上得来终觉浅，绝知此事要躬行</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/08/26/CSKS-一-、数据结构和算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/CSKS-一-、数据结构和算法/" itemprop="url">CSKS-(一)、数据结构和算法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-26T09:54:05+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/26/CSKS-一-、数据结构和算法/" class="leancloud_visitors" data-flag-title="CSKS-(一)、数据结构和算法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，算法的空间复杂度反映了程序执行时消耗的空间随输入规模增长而增长的规模；时间复杂度和空间复杂度在很大程度上能很好反映出算法的优劣。</p>
<p>在数学上有三个记号用于刻画算法复杂度:</p>
<ul>
<li>大 $O$ 记号：表示函数数量级上的上界</li>
<li>大 $Ω$ 记号：与大 $O$ 记号相反，表示函数数量级上的下界</li>
<li>大 $Θ$ 记号：表示函数数量级上的一个确界</li>
</ul>
<p>通常情况下主要考虑的是算法的最坏情况，即大 $O$ 记号。</p>
<h2 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h2><p>下面给出三个记号的数学定义：</p>
<p>若存在常量 $c$ 和函数 $f(n)$，对于任意的 $n \gg 2$，均有 $T(n) \le c \times f(n)$ 成立，则表示 $f(n)$ 给出了 $T(n)$ 增长的一个渐进上界，记作 $T(n) = O(f(n))$。</p>
<p>若存在常量 $c$ 和函数 $g(n)$，对于任意的 $n \gg 2$，均有 $T(n) \ge c \times g(n)$ 成立，则表示 $g(n)$ 给出了 $T(n)$ 增长的一个渐进下界，记作 $T(n) = \Omega(g(n))$。</p>
<p>若存在常量 $c1$、$c2$ 和函数 $h(n)$，对于任意的 $n \gg 2$，均有 $c1 \times h(n) \le T(n) \le c2 \times h(n)$ 成立，则表示 $h(n)$ 给出了 $T(n)$ 增长的一个渐进下界，记作 $T(n) = Θ(h(n))$。</p>
<h2 id="P-问题和-NP-问题"><a href="#P-问题和-NP-问题" class="headerlink" title="P 问题和 NP 问题"></a>P 问题和 NP 问题</h2><p>一般地，$O(log_2n)$、$O(n)$、$O(n \times log_{2}n)$、$O(n^2)$、$O(n^3)$ 称为多项式复杂度；$O(2^n)$、$O(n!)$ 称为指数复杂度。</p>
<p>计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为 P（Polynomial，多项式）类问题，而把后者（即指数时间复杂度的算法）称为 NP（Non-Deterministic Polynomial，非确定多项式）问题。</p>
<p>多项式复杂度用于求解问题的代价是可接受的。很多问题没有多项式时间的解，比如大数分解、Hamilton 回路。虽然这些问题没有多项式时间内的解，但是可以在多项式时间内验证某个猜想是否正确。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/lanchunhui/article/details/51505016" target="_blank" rel="noopener">数据结构与算法的分析-渐进复杂度（三个记号）</a></li>
<li><a href="http://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="noopener">算法的时间复杂度和空间复杂度-总结</a></li>
</ul>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数组、链表、栈、队列等是数据结构中最常用的，且实现比较简单。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/m0_37854317/article/details/70491581" target="_blank" rel="noopener">数组、链表、栈、队列、二叉树</a></li>
<li><a href="http://www.cnblogs.com/tpys/p/3568528.html" target="_blank" rel="noopener">数组、链表、栈、队列和STL</a></li>
</ul>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集这个数据结构主要用于判断两个元素是否为同一个集合元素。这里以 <code>p[i]</code> 表示 <code>i</code> 元素所在集合，开始时每个元素各占一个集合；<code>union(i, j)</code> 操作将原有两个集合 <code>i</code>、<code>j</code> 合并为一个集合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) p[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) weight[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (i != p[i]) i = p[i];</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = find(x);</span><br><span class="line">  <span class="keyword">int</span> j = find(y);</span><br><span class="line">  <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (weight[i] &lt; weight[j]) &#123; p[i] = j; weight[j] += weight[i]; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; p[j] = i; weight[i] += weight[j]; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>init()</code> 用于初始化并查集</li>
<li><code>find()</code> 用于找到当前元素所在的集合</li>
<li><code>union()</code> 用于将两个元素的集合合并起来</li>
</ul>
<p>因为使用类似与子节点指向父节点的原理，如果合并中一直加到某个节点最下方，将导致链变长。因此使用 <code>weight</code> 记录集合权重，每次将权重小的集合加到权重大的集合后，加快了 <code>find</code> 的速度。</p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列内部由堆构成，堆类似二叉树，其中子节点均小于父节点。只要保证每次插入、删除数据时保持堆原有的性质，那么可以在 $O(1)$ 的时间复杂度内得到最小（最大）值。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/luoxn28/p/5616101.html" target="_blank" rel="noopener">优先队列原理与实现</a></li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><img src="http://www.hashcoding.net/uploads/images/2017/8/binary-tree.png" alt="二叉树"></p>
<p>二叉树是指最多有两个孩子节点的树。在计算机科学中，二叉树有几个重要的性质：</p>
<ul>
<li>二叉树第 $i$ 层最多有 $2^{i-1}$ 个节点，其中 $i \ge 1$</li>
<li>二叉树深度为 $k$，那么最多有 $2^k-1$ 个节点，其中 $k \ge 1$</li>
<li>$n_0$ 表示度为 $0$ 的节点，$n_2$ 表示度为 $2$ 的节点，那么有 $n_0=n_2+1$</li>
<li>在完全二叉树中，具有 $n$ 个节点的二叉树深度为 $\lfloor log_2(n + 1) \rfloor + 1$</li>
</ul>
<p>第一个可以不用证明。以 $l_i$ 表示第 $i$ 层有最多有多少个节点，那么第二条结论等于 $total=l_1+l_2+\cdots+l_k=1+2+\cdots+2^{i-1}=2^i-1$。</p>
<p>第三个性质需要用到其他两个公式：</p>
<ul>
<li>$n=n_0+n_1+n_2$ $n$ 表示总节点个数，$n_1$ 表示度为 $1$ 的节点的个数</li>
<li>$n-1=2n_2+n_1$ 这个公式是边的数量的恒等式</li>
</ul>
<p>两式相减可以得到第三条公式。</p>
<p>完全二叉树最后一层长度为 $1 \to 2^{i-1}$ 之间，因为 $2^i-1=n$，所以成立。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/tianlihua306/article/details/44621827" target="_blank" rel="noopener">二叉树的5个重要性质</a></li>
<li><a href="http://www.jianshu.com/p/43b6b90555ca" target="_blank" rel="noopener">二叉树</a></li>
</ul>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>假设有这样一颗二叉树，其节点值保存一个数据，而左节点的值均小于等于当前结点，右节点所有值均大于等于当前节点，那么这棵树就叫做二叉查找树。</p>
<p>在查找时，类似与二分查找，先判断是否等于当前值，然后根据大小在左右两侧进行查找。当然，因为没有其余限制，极端情况下二叉查找树会形成一条链，此时查找时间便降到 $O(n)$。所以实际使用中会对二叉查找树进行旋转操作，进行旋转的二叉查找树被成为平衡二叉树。比起普通二叉树，平衡二叉树在实现上复杂得多。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/skywang12345/p/3576328.html" target="_blank" rel="noopener">二叉查找树</a></li>
</ul>
<h4 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h4><p>AVL 树是一种平衡二叉查找树，也被称为高度平衡树。它的特点是任何两个节点的高度差最大为 $1$。</p>
<p>如果树有 $n$ 个节点，AVL 树的增删查改操作复杂度为 $log(n)$，如果插入、删除操作导致 AVL 树中某个节点不再满足上述性质，那么平衡状态就被破坏。所以要对其进行旋转操作，保证其平衡性。</p>
<p>AVL 树只有四种可能出现的不平衡状态，与之对应的，就是 $4$ 种旋转操作。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/21/2964092.html" target="_blank" rel="noopener">AVL树</a></li>
<li><a href="http://dongxicheng.org/structure/avl/" target="_blank" rel="noopener">AVL树详解</a></li>
</ul>
<blockquote>
<p>另一种二叉查找树是伸展树，伸展树有一个特点：当某个节点被访问时，伸展树会通过旋转操作使得该节点成为树根。所以再次访问这个节点时，能够迅速访问到这个节点。更多伸展树相关的请看<a href="http://www.cnblogs.com/skywang12345/p/3604238.html" target="_blank" rel="noopener">伸展树</a>。</p>
</blockquote>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html" target="_blank" rel="noopener">平衡查找树之2-3树</a></li>
<li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" target="_blank" rel="noopener">平衡查找树之红黑树</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">红黑树详解</a></li>
</ul>
<h3 id="Tire-树"><a href="#Tire-树" class="headerlink" title="Tire 树"></a>Tire 树</h3><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/Jason-Damon/archive/2012/04/15/2450100.html" target="_blank" rel="noopener">Tire 树</a></li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/mushroom/p/4100087.html" target="_blank" rel="noopener">算法数据结构(一)-B树</a></li>
<li><a href="http://blog.csdn.net/dazhong159/article/details/7963846" target="_blank" rel="noopener">B、B+、B* 树</a></li>
<li><a href="http://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="noopener">从 B、B+、B* 树谈到 R 树</a></li>
</ul>
<h2 id="区间信息维护与查询"><a href="#区间信息维护与查询" class="headerlink" title="区间信息维护与查询"></a>区间信息维护与查询</h2><p>有时会需要在区间上进行操作，比如区间最值、区间和等。</p>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>树状数组提供了一种查询和维护区间和的方式。</p>
<h4 id="low-bit"><a href="#low-bit" class="headerlink" title="low_bit"></a>low_bit</h4><p>进一步将树状数组前，得讲讲 <code>low_bit</code>，<code>low_bit</code> 用于求出数值二进制表示中的最后一个 $1$ 所表示的数值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low_bit</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; (c ^ (c - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从二进制的角度可以清晰地观察到原理：</p>
<blockquote>
<p>以 15(1110) 为例，15-1(1101)，15^(15-1)(0011)，所以<code>low_bit(15)</code>(0010)</p>
</blockquote>
<hr>
<p>树状数组用 $c[i]$ 记录 $a[i-low_bit(i)+1]+…+a[i]$ 的信息。那么想要前 $i$ 个数据的和就可以用下面的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ret += c[i];</span><br><span class="line">    i -= low_bit(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到前 $i$ 个数据和为 $a[1]+a[2]+…+a[i]$，将其划分为两部分 $a[1]+a[2]+…+a[i-low_bit(i)]$ 和 $a[i-low_bit(i)+1]+…+a[i]$，后一部分等价于 $c[i]$。现在就将求和转换为求前 $i-low_bit(i)$ 项加上 $c[i]$ 的和。递归地运用，就能得到具体值。</p>
<p>树状数组同时还允许修改操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= length) &#123;</span><br><span class="line">    c[i] += d;</span><br><span class="line">    i += low_bit(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里算法将等价于执行<code>a[i] += d</code>，其中<code>length</code>为数据长度最大值。当修改了元素值后，树状数组维护的信息也应修改。因为 $c[i]$ 等于 $a[i-low_bit(i)+1]+…+a[i]$，而 $c[i+low_bit(i)]$ 的区间范围为：$[i+low_bit(i)-low_bit(i+low_bit(i))+1, i+low_bit(i)]$，其中 $low_bit(i+low_bit(i))$ 显然等于 $low_bit(i) &lt;&lt; 1$，所以等价于 $[i-low_bit(i)+1, i+low_bit(i)] &gt; [i-low_bit(i)+1, i]$。要保证树状数组信息正确，必须在修改 $c[i]$ 后同时修改 $c[i+low_bit(i)]$ 所在值。</p>
<p>有了两个操作后，就能完成区间查询操作，比如查询[3,5]的和，可以使用 $sum(5)-sum(2)$。</p>
<p>当然，树状数组需要进行初始化，如何初始化？使用<code>add(i, a[i])</code>。可以简单得出树状数组初始化操作耗时 $O(n \times log_2n)$，查询操作耗时 $O(log_2n)$。</p>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>树状数组适合查询区间值。其主要思想是在数据集上维护一颗二叉树，二叉树叶子节点对应一个具体数据，而父节点表示左右节点对应的集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1,4]</span><br><span class="line">[1,2][3,4]</span><br><span class="line">[1][2][3][4]</span><br></pre></td></tr></table></figure>
<p>如上所示，最下方为其数据集，而上方为对应的父节点。现在用每个父节点维护其子节点对应区间的信息（最大值、最小值、求和）。那么如果要查询某个区间内容比如 <code>[1,3]</code>，可以将集合分为 <code>[1,2][3]</code> 两部分，因此每次查询会停留在区间被完全覆盖的节点上，从而实现快速查询。</p>
<p>同树状数组一致，当更新某个数据时，同样需要更新其上方包含该区间的节点的信息。线段树还可以对一个区间进行快速操作，比如整个区间加上某个值。实现方式很简单，在每个节点处加上一个额外的信息，在进行操作时，如果区间完整覆盖了当前区间，那么就把操作添加到当前额外信息上。当然，后续查询中如果查到的区间小于该节点的区间怎么办？那就需要把额外信息往下传递。</p>
<h3 id="Sparse-Table"><a href="#Sparse-Table" class="headerlink" title="Sparse Table"></a>Sparse Table</h3><p>如果仅仅需要查询区间最值，且初始化后数据不会改变，那么使用 sparse table 是不错的选择。</p>
<p>sparse table 的思路是使用函数 $f(i, j)$ 表示从 $i$ 开始长度为 $2^j$ 的一段元素中的最小值（最大值）。显然有 $f(i, j)=min(f(i, j-1), f(i+2^{j-1}, j-1))$ 成立。观察到总共有 $n$ 个数据，而每个数据表示长度最多为 $log(n)$，所以总共初始化耗时 $O(n \times log_2(n))$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) d[i][<span class="number">0</span>] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt; n; ++i) </span><br><span class="line">      d[i][j] = min(d[i][j<span class="number">-1</span>], d[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当构造好了 table 后如何查询呢？比方说想要找到区间 $[L, R]$ 的最值，这时需要找到一个区间满足$2^k \le R-L+1$，其中 $k$ 为满足前面不等式的最大整数，那么就可以通过区间 $[L, L+2^k]$ 和 $[R-2^k+1, R]$ 的最值进行比较得到（即 $f(L, k)$ 和 $f(R-z^k+1, k)$，因为求最值，所以区间重叠不影响结果）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span> &lt;&lt; (k+<span class="number">1</span>) &lt;= r-l+<span class="number">1</span>) k++;</span><br><span class="line">  <span class="keyword">return</span> min(d[l][k], d[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成预处理后，查询操作可以在常量时间内完成。</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>这里列出了常见的十大排序算法</p>
<table>
<thead>
<tr>
<th>算法</th>
<th style="text-align:center">空间</th>
<th style="text-align:center">稳定</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td style="text-align:center">in</td>
<td style="text-align:center">stable</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">- </td>
</tr>
<tr>
<td>插入排序</td>
<td style="text-align:center">in</td>
<td style="text-align:center">stable</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">- </td>
</tr>
<tr>
<td>选择排序</td>
<td style="text-align:center">in</td>
<td style="text-align:center">unstable</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:center">out</td>
<td style="text-align:center">stable</td>
<td style="text-align:center">$O(nlog(n))$</td>
<td style="text-align:center">$O(n)$ </td>
</tr>
<tr>
<td>快速排序</td>
<td style="text-align:center">in</td>
<td style="text-align:center">unstable</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">in</td>
<td style="text-align:center">unstable</td>
<td style="text-align:center">$O(nlog(n))$</td>
<td style="text-align:center">- </td>
</tr>
<tr>
<td>计数排序</td>
<td style="text-align:center">out</td>
<td style="text-align:center">stable</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">- </td>
</tr>
<tr>
<td>桶排序</td>
<td style="text-align:center">out</td>
<td style="text-align:center">stable</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">- </td>
</tr>
<tr>
<td>基数排序</td>
<td style="text-align:center">out</td>
<td style="text-align:center">stable</td>
<td style="text-align:center">$O((n+k)d)$</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>希尔排序</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>解释：</p>
<ul>
<li>stable：表示排序前后值相同的元素相对位置不变</li>
<li>unstable：与上面相反</li>
<li>In-place：表示排序算法可以在原有数据空间上执行</li>
<li>Out-place：表示排序算法需要额外的空间来执行</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是通过两两交换，像水中的泡泡一样，小的先冒出来，大的后冒出来。具体实现为：从第一个到最后一个扫描，每次按一定顺序排列相邻的两个元素；执行一次后，找到一个最大元素，将查找范围减一后重复执行上一部；执行多次后，达到有序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>])</span><br><span class="line">      swap(a, j, j + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序将数据分为前后两个部分：</p>
<ul>
<li>按照某种顺序有序部分</li>
<li>无序部分</li>
</ul>
<p>每次将无序部分的第一个数据与有序部分进行比较并交换，这样朝着开始方向移动，直到找到第一个大于或小于该数据的值。</p>
<p>插入排序比较适合用于“少量元素的数组”。其实插入排序的复杂度和逆序对的个数一样，当数组倒序时，逆序对的个数为 $\frac{n(n-1)}{2}$，因此插入排序复杂度为 $O(n^2)$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j<span class="number">-1</span>]); j--)</span><br><span class="line">    swap(a, j, j<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序的速度直接是逆序对的个数，而冒泡排序中执行“交换“的次数是逆序对的个数，因此冒泡排序执行的时间至少是逆序对的个数，因此插入排序的执行时间至少比冒泡排序快。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每次找一个最小值。具体实现为每次在未排序数据中找到一个最值，并加到以排序数据首部或尾部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">int</span> idx = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[idx] &lt; a[j])</span><br><span class="line">      idx = j;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(a, i, idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>运用分治法思想解决排序问题。实现中将原有数据分为两个部分，递归调用自己，最后得到了两份有序的数据，然后将两份有序数据合并。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [l, r)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *tmp, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">  sort(a, tmp, l, mid);</span><br><span class="line">  sort(a, tmp, mid, r);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = l, j = mid, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; r - l; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; mid) tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) tmp[k++] = a[j++];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; a[j]) tmp[k++] = a[j++];</span><br><span class="line">    <span class="keyword">else</span> tmp[k++] = a[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; r - l; k++) </span><br><span class="line">    a[l + k] = tmp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序是 <code>out-place sort</code>，与快速排序相比，需要很多额外空间；通常情况下，归并和快排渐进复杂度一致，不过归并排序系数大于快排，所以通常认为归并排序慢于快排。</p>
<p>插入排序适合对小数组进行排序，所以可以使用插入排序对归并排序进行改进。以数组长度为 $k$ 时采用插入排序，则渐进复杂度为 $O(nk+nlog(n/k))$，如果保证 $k=log(n)$，那么有 $O(nlog(n))$。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思想也是分治法。具体做法是选择一个元素作为 <code>pivot</code>，并用 <code>pivot</code> 将数据分为大于 <code>pivot</code> 和小于 <code>pivot</code> 的两部分。然后分别对这两部分递归调用自己，此时得到的数据便是有序的。</p>
<p>在数组已经有序时，快排的时间复杂度为 $O(n^2)$。通常使用随机化（shuffle array 或者 randomized select pivot）来改进，使得期望运行时间为 $O(nlog(n))$。</p>
<p>当输入数组的所有元素都一样时，不管是快速排序还是随机化快速排序的复杂度都为 $O(n^2)$，使用三向切分技术可以使这种情况下的复杂度为 $O(n)$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [l, r)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lt = l, gt = r;</span><br><span class="line">  <span class="keyword">int</span> pivot = a[l];</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (a[++lt] &lt; pivot) <span class="keyword">if</span> (lt &gt;= r) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">while</span> (pivot &lt; a[--gt]) <span class="keyword">if</span> (gt &lt;= l) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (lt &gt;= gt) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, lt, gt);</span><br><span class="line">  &#125;</span><br><span class="line">  swap(a, gt, l);</span><br><span class="line">  <span class="keyword">return</span> gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [l, r)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> part = partition(a, l, r);</span><br><span class="line">  sort(a, l, part);</span><br><span class="line">  sort(a, part + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在算法一书中还介绍了一种快排的优化算法：三向切分。其核心思想是将原有的分成两部分转换为分成三部分：小于、等于、大于。具体实现需要依赖于下面的数据（以递增排序为例）：</p>
<ul>
<li><code>lt</code> 表示当前不小于 <code>pivot</code> 的第一个元素</li>
<li><code>i</code> 表示未排序的第一个元素</li>
<li><code>gt</code> 表示大于 <code>pivot</code> 的第一个元素</li>
</ul>
<p>根据上面的，分析过程中数据布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[l 小于pivot |lt 等于pivot |i 未排序 |gt 大于pivot r)</span><br></pre></td></tr></table></figure>
<p>此时选中第一个i进行操作：</p>
<ul>
<li>如果 $a[i] == pivot$ 则 $i=i+1$</li>
<li>如果 $a[i] &gt; pivot$ 则交换 $a[–gt]$ 和 $a[i]$</li>
<li>如果 $a[i] &lt; pivot$则交换 $a[i++]$ 和 $a[lt++]$</li>
</ul>
<p>每次操作完成后，仍然保持了原有的数据格式。重复该过程直到$i==gt$ 则表示 <code>partition</code> 操作完成，现在只需要对 $[l, lt)$ 和 $[gt, r)$ 部分进行排序即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> lt = l, i = l+<span class="number">1</span>, gt = r;</span><br><span class="line">  <span class="keyword">int</span> pivot = a[l];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">    <span class="keyword">int</span> cmp = a[i] - pivot;</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) swap(a, --gt, i);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) swap(a, i++, lt++);</span><br><span class="line">    <span class="keyword">else</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a, l, lt);</span><br><span class="line">  sort(a, gt, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>运用了最小堆、最大堆这个数据结构，而堆还能用于构建优先队列。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/morewindows/article/details/6709644/" target="_blank" rel="noopener">堆与堆排序</a></li>
</ul>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序有很大的局限性，<strong>其要求数据范围比较小，能枚举</strong>。具体实现思路是将其按照数据数据大小，直接分配一个固定位置。</p>
<p>一般情况下计数排序复杂度为 $O(n+k)$，当$k=O(n)$时，计数排序时间为$O(n)$，其中 $k$ 表示数据范围，$n$ 表示数据长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b[n+<span class="number">1</span>], c[k+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[a[i<span class="number">-1</span>]]++;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) c[i] += c[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i) b[c[a[i<span class="number">-1</span>]]--] = a[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = b[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><img src="http://www.hashcoding.net/uploads/images/2017/6/桶排序.jpg" alt="桶排序"></p>
<p>算法：将元素按照范围依次分散到多个桶中，此时桶的范围是有序的。再对每个桶进行排序，最后得到的数据就是有序的。</p>
<p>当分布不均匀时，全部元素都分到一个桶中，则 $O(n^2)$，当然也可以将插入排序换成堆排序、快速排序等，这样最坏情况就是 $O(nlog(n))$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *b[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> l[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> idx = a[i] % <span class="number">10</span>;</span><br><span class="line">    将a[i]插入到b[idx]中</span><br><span class="line">    l[idx]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) </span><br><span class="line">    otherSort(b[i], l[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>桶排序的缺点是：</p>
<ul>
<li>首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从 $0$ 到 $m-1$，那就需要 $m$ 个桶，这个桶数组就要至少 $m$ 个空间。</li>
<li>其次待排序的元素都要在一定的范围内等等。</li>
</ul>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>这里假定每位的排序是计数排序。而计数排序是稳定的，所以对部分有序的数据排序，得到的结果仍然满足部分有序。话句话说，如果第 $k+1$ 位有序，对第 $k$ 位进行计数排序后，得到的结果仍然在 $k+1$ 位有序。将原有数据每一位依次排序，最后得到的结果能保证有序。</p>
<p>计数排序复杂度为 $O((n+k)d)$。</p>
<ul>
<li>$d$ 表示位数</li>
<li>$k$ 表示数据范围</li>
<li>$n$ 表示长度</li>
</ul>
<p>当 $d$ 为常数、$k=O(n)$时，效率为$O(n)$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中counter用于对第i位排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; ++i) &#123;</span><br><span class="line">    counter_sort(a, i, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是利用插入排序在有序时速度快的特点。以 $k$ 为间隔对数据进行排序，直到 $k=1$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n/<span class="number">3</span>) k = k*<span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; N; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= k &amp;&amp; a[j] &lt; a[j-k]; j -= k)</span><br><span class="line">        swap(a, j, j-k);</span><br><span class="line">    &#125;</span><br><span class="line">    k /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>对于<strong>有序且可以随机访问</strong>的数据，要判断数据中是否含有某个值，可以使用 $O(log(n))$ 的二分查找。</p>
<p>对于一个给定的区间 $[l, r)$，我们判断 $mid=\frac{l+r}{2}$ 是否为目标值，是表示找到，否则没有找到。没有找到时，判断值和 $val[mid]$ 和目标值的大小，如果目标值小于中间值，则实际值应该能在左边区间 $[l, mid)$ 中找到，否则应该在 $[mid + 1, r)$ 中查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [l, r)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt; val) r = mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; val) l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三分查找"><a href="#三分查找" class="headerlink" title="三分查找"></a>三分查找</h3><p>二分查找适用于单调函数中逼近求解某点的值。如果遇到凸性或凹形函数时，可以用三分查找求那个凸点或凹点。</p>
<p>假设我们要找一个凸点，给了区间 $[l, r]$ 和函数 $f(x)$，下面找出中点 $mid=(l+r)/2$，以及 $[mid,r]$ 的中点 $mmid=(mid+r)/2$。通过比较 $f(mid)$ 与 $f(mmid)$ 的大小来缩小范围，当最后 $L=R-1$ 时，再比较下这两个点的值，我们就找到了答案。</p>
<p>当 $f(mid) &gt; f(mmid)$ 的时候，我们可以断定 $mmid$ 一定在最值点的右边。假设 $mmid$ 在最值点的左边，则 $mid$ 也一定在最值点的左边，又由 $f(mid) &gt; f(mmid)$ 可推出 $mmid &lt; mid$，与已知矛盾，故假设不成立。所以，此时可以将 $R = mmid$ 来缩小范围。</p>
<p>当 $f(mid) &lt; f(mmid)$ 的时候，我们可以断定 $mid$ 一定在最值点的左边。反证法：假设 $mid$ 在最值点的右边，则 $mmid$ 也一定在最值点的右边，又由 $f(mid) &lt; f(mmid)$ 可推出 $mid &gt; mmid$，与已知矛盾，故假设不成立。同理，此时可以将 $L = mid$ 来缩小范围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">//找凸点   </span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r<span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="keyword">int</span> mid  = (l+r)/<span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">int</span> mmid = (mid+r)/<span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">if</span> (f(mid) &gt; f(mmid))  </span><br><span class="line">            r = mmid;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            l = mid;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> f(l) &gt; f(r) ? l : r;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><p>树已经在前面<a href="#树">数据结构-树</a>中介绍了。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表类似于数组的使用方式，通过 <code>key</code> 找到对应的 <code>value</code>。使用散列查找算法分为两步：</p>
<ol>
<li>用散列函数将 <code>key</code> 映射到数组的索引上</li>
<li>处理索引（hash）冲突</li>
</ol>
<p>散列函数选取非常重要，因为好的散列函数能够将数据均匀的分布在数组上。这里重点看冲突的处理，冲突处理主要有两种方式：</p>
<ol>
<li>链地址法</li>
<li>线性探测法（开放地址法）</li>
</ol>
<p><strong>在散列表使用中，由于冲突的存在，散列表除了要保存value外，也要保存key</strong>。查找时，需要对 <code>key</code> 进行比对，成功时才是真正定位到了具体数据上。</p>
<p>链地址法将数组看作一个个桶，具体的数据通过链表链接到桶后。java 中的 <code>HashMap</code> 便是使用的链地址法。而线性探测法是发生冲突时重新选择一个新的 <code>hash</code> 值作为索引，直到找到空位为止。</p>
<p>当散列表中存储数据到达一定限制后，就要调整散列表大小。比如线性探测法中，如果 <code>存储键的数目N=数组大小M</code>，那么永远也找到一个新的空位存放当前元素。这里需要介绍<strong>负载因子（load factor），表示散列表空间使用率</strong>。在 <code>HashMap</code> 中的负载因子默认为 <code>0.75</code>，<code>桶的大小M*loadFactor</code> 得到容量调整的 <code>阈值(threshold)</code>。所以当 <code>键的数量N大于桶大小M*0.75</code> 后， <code>HashMap</code> 会调整容量大小。具体调整多少呢？在 Java 中默认是两倍，因为散列表桶大小默认是16，而 <code>HashMap</code> 又使用 <code>hash</code> 值模上桶大小比如 <code>key.hashcode() &amp; (length - 1)</code> 作为桶索引。（只有在 <code>length</code> 为2的倍数时，<code>&amp;</code> 结果和 <code>%</code> 结果一致，如果将容量扩充为其他数量而非2的倍数，那么 <code>&amp;</code> 得到的索引值可能就不是均匀的分布在数组上了）。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://www.vvbin.com/?p=376" target="_blank" rel="noopener">为什么求模运算要用素数（质数）—— 哈希表设计</a></li>
<li><a href="http://blog.csdn.net/qq_24489717/article/details/51189619" target="_blank" rel="noopener">Hash时取模为什么要模质数</a></li>
<li><a href="http://blog.csdn.net/acdreamers/article/details/11820651" target="_blank" rel="noopener">字符串Hash的原理与应用</a></li>
<li><a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="noopener">HashMap 的实现原理</a></li>
<li><a href="http://blog.csdn.net/u011240877/article/details/53358305" target="_blank" rel="noopener">HashMap 转红黑树</a></li>
</ul>
<h3 id="Hash-树"><a href="#Hash-树" class="headerlink" title="Hash 树"></a>Hash 树</h3><p>在 Hash 表中通常使用素数作为模运算的因子，对于一个 Hash 值，如果素数为 $x$，那么能将 Hash 值域分为 $x$ 块。再这个基础上，再做一次取模，如果用素数 $y$ 且 $y \ne x$，那么就将值域分为了 $x \times y$ 块。依次类推，形成一颗树状的表，称为 Hash 树。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/ynkdyx/article/details/8094124" target="_blank" rel="noopener">简单理解 Hash 树</a></li>
<li><a href="http://blog.csdn.net/yang_yulei/article/details/46337405" target="_blank" rel="noopener">HASH树</a></li>
</ul>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图由顶点(vertex, node)和边(edge)组成。假设定点集合为 V，边集合为 E，那么图可以表示为 G(V, E)，连接两点 u 和 v 的边用 e(u, v) 表示。图分为有向图和无向图，分别表示边是否有指向性。实际应用中，还会给边赋予各种各样的属性。比较具有代表性的有权值(cost)，此时称图为带权图。</p>
<h2 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h2><p>对于无向图，两个定点之间如果有边连接，那么就认为<strong>两点相邻</strong>。相邻定点的序列称为<strong>路径</strong>。起点和终点重合时，路径被称为<strong>圈</strong>。任意两个点都存在路径的叫做<strong>连通图</strong>。定点的边数叫做这个<strong>顶点的度</strong>。我们称没有圈的连通图为<strong>树</strong>，没有圈的非连通图为<strong>森林</strong>。对于树，边数正好等于顶点数减一，这是一个等价条件。</p>
<p>对于有向图，起点为顶点 V 的边为 V 的边集。边集数目等于定点<strong>出度</strong>，重点为定点V的边的数目等于定点的<strong>入度</strong>。如果有向图没有圈，那么该图称为DAG(Directed Acyclic Graph)。</p>
<p><a href="https://www.byvoid.com/zhs/blog/biconnect" target="_blank" rel="noopener">图的割点、桥与双连通分支</a></p>
<h2 id="图的表示方法"><a href="#图的表示方法" class="headerlink" title="图的表示方法"></a>图的表示方法</h2><p>图常见的表示方法有两种：</p>
<ul>
<li>邻接矩阵；</li>
<li>邻接表。</li>
</ul>
<p>两种方法各有优缺点，适合不同的算法。接下来，记顶点和边的集合为 V 和 E ，|V| 和 |E| 分别表示顶点和边的个数，另外，将顶点编号为 $0 \cdots |V|-1$。</p>
<p>邻接矩阵使用 $|V| \times |V|$ 的二维数组来表示图，其中 $g[i][j]$ 表示顶点 $i$ 和顶点 $j$ 的关系，比如是否连接，或者边的权值。需要注意的是，如果图存在重边或者自环，如果使用的是无权图，那么用 $g[i][j]$ 表示边数即可，对于带权图则无法表示。同时，对于稀疏图，会存在这大量浪费空间的情况，比如表示一颗树，只需要记录 $|V|-1$ 条边，而实际上花费了 $|V|*|V|$ 的空间。</p>
<p>使用邻接表则完美解决上述情况，邻接表将边保存到对应的顶点处，向链表一样，指向其他顶点。使用邻接表只需要花费 $O(|V|+|E|)$的空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vertex</span> &#123;</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;vertex*&gt; edge;</span><br><span class="line">  <span class="comment">//顶点属性</span></span><br><span class="line">&#125;;</span><br><span class="line">vertex G[Nodes];</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> from, to, cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[Nodes];</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/hibernate6/archive/2012/01/17/2521942.html" target="_blank" rel="noopener">等价、偏序、全序</a></li>
<li><a href="http://blog.jobbole.com/108351/" target="_blank" rel="noopener">拓扑排序详解</a></li>
</ul>
<h2 id="联通分量"><a href="#联通分量" class="headerlink" title="联通分量"></a>联通分量</h2><h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><p><em>References</em></p>
<ul>
<li><a href="https://www.byvoid.com/zht/blog/scc-tarjan/" target="_blank" rel="noopener">有向圖強連通分量的Tarjan算法</a></li>
<li><a href="http://www.acmerblog.com/strongly-connected-components-6099.html" target="_blank" rel="noopener">求强连通分量-Kosaraju算法</a></li>
</ul>
<h3 id="双联通分量"><a href="#双联通分量" class="headerlink" title="双联通分量"></a>双联通分量</h3><p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/fuyukai/article/details/51039788" target="_blank" rel="noopener">Tarjan算法之-割、桥</a></li>
<li><a href="http://blog.csdn.net/fuyukai/article/details/51303292" target="_blank" rel="noopener">Tarjan算法之-双联通分量</a></li>
</ul>
<h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/ECJTUACM-873284962/p/6613379.html" target="_blank" rel="noopener">离线-Tarjan-LCA</a></li>
<li><a href="http://blog.csdn.net/liangzhaoyang1/article/details/52549822" target="_blank" rel="noopener">在线-Sparse Table-LCA</a></li>
<li><a href="http://blog.csdn.net/Janis_z/article/details/52937631?locationNum=6&amp;fps=1" target="_blank" rel="noopener">在线-倍增法-LCA</a></li>
</ul>
<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/acSzz/archive/2012/09/05/2672472.html" target="_blank" rel="noopener">2-sat 讲解</a>  </li>
</ul>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>所谓最短路径，是指给定两个顶点，找到以这两个顶点为起点和重点的路径中，边权值最小的路径。而单源最短路径则是固定一个顶点，求该点到其他所有定点的最短路的问题。</p>
<p>单元最短路径的算法有两种：1、Bellman-ford；2、Dijkstra 。</p>
<h3 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h3><p>记从顶点 $s$ 出发，到顶点 $i$ 的最短距离为 $d[i]$，那么有：$d[i]=min(d[j]+weight(j, i)|e(j,i) \in E)$ 成立。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> from; <span class="keyword">int</span> to; <span class="keyword">int</span> cost; &#125;;</span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="keyword">int</span> d[MAX_V];</span><br><span class="line"><span class="keyword">int</span> V, E;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bellman_ford</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; ++i) d[i] = INF;</span><br><span class="line">  d[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">bool</span> update = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">      edge e = es[i];</span><br><span class="line">      <span class="keyword">if</span> (d[e.from] != INF &amp;&amp; d[e.to] &gt; d[e.from] + e.cost) &#123;</span><br><span class="line">        d[e.to] = d[e.from] + e.cost;</span><br><span class="line">        update = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!update) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法就叫做 Bellman-ford 算法，如果图中不存在从点 $s$ 可达的负圈，那么路径一定不会经过任一点两次，所以最外层循环最多执行 $|V|-1$ 次。所以总的时间复杂度为 $|V| \times |E|$。如果存在负圈，那么 $|V|$ 次一定还会更新 $d$ 的值，所以可以用此判断是否有负圈。</p>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>如果图中不存在负权边，那么可以用 Dijkstra 算法来求单源最短路径。在 Bellman-ford 算法中，如果 $d[j]$ 不是点 $j$ 到起点的最短路径，那么 $d[i]=d[j]+cost(j,i)$ 自然得到的也不是最短路径。而 Dijsktra 算法正好解决了这个问题，它将顶点分为两部分，一部分已经找到了最短距离，另一部分没找到。每次计算时，在还不是最短距离的集合中找到最短的那条，加到已经找到的集合中去。</p>
<p>那么如何更新距离呢？实际上只需要找到未使用过的顶点中的某个 $j$，和已经最短的顶点 $i$，保证 $d[i]+cost(i, j)=d[j]$ 比其余顶点都短，那么得到的 $d[j]$ 就是 $s$ 到 $j$ 的最短路径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> to, cost; &#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V, E;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAX_V];</span><br><span class="line"><span class="keyword">int</span> d[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt;&gt; que;</span><br><span class="line">  fill(d, d+V, INF);</span><br><span class="line">  d[s] = <span class="number">0</span>;</span><br><span class="line">  que.push(P(<span class="number">0</span>, s));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    P p = que.top(); que.pop();</span><br><span class="line">    <span class="keyword">int</span> v = p.second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); ++i) &#123;</span><br><span class="line">      edge e = G[v][i];</span><br><span class="line">      <span class="keyword">if</span> (d[e.to] &gt; d[v] + e.cost) &#123;</span><br><span class="line">        d[e.to] = d[v] + e.cost;</span><br><span class="line">        que.push(P(d[e.to], e.to));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的算法在每次循环中，找出已经找到最短路径中距离 $s$ 点最短的点，然后更新与该点相邻的点的距离。这个算法的复杂度是 $O(|E| \times log(|V|))$。</p>
<h3 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h3><p>求解所有两点间的最短路的问题叫做任意两点间的最短路问题。Floyd-Warshall 算法可以在 $|V| \times |V| \times |V|$ 的时间里求得所有点的最短路径长度，同 Bellman-Ford 算法一样，可以处理负边的情况。该算法主要利用公式：$d[i][j]=min(d[i][j], d[i][k]+d[k][j])$ 的不断更新来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[MAX_V][MAX_V];</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">warshall_floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; V; ++k) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; ++j)</span><br><span class="line">        d[i][j] = min(d[i][j], d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>给定一个图，在图上找到一棵树，那么这棵树被称为生成树。如果树的边权是所有树中最短的，这棵树被称为最短生成树。最小生成树求解有两种算法。</p>
<h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>Prim 算法和 Dijkstra 算法类似，均是从一个顶点出发，不断地添加边的算法。具体思路是假设一颗只包含一个顶点 $v$ 的树 $T$，然后贪心地选取 $T$ 和其他顶点之间相连的权值最小的边，并把它加到 $T$ 中。不断的进行该操作，直到所有节点均在 $T$ 中。其复杂度为 $O(V*V)$：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[MAX_V][MAX_V];</span><br><span class="line"><span class="keyword">int</span> mincost[MAX_V];</span><br><span class="line"><span class="keyword">bool</span> used[MAX_V];</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; ++i) &#123;</span><br><span class="line">    mincost[i] = INF;</span><br><span class="line">    used[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mincost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!used[u] &amp;&amp; (v == <span class="number">-1</span> || mincost[u] &lt; mincost[v])) v = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    used[v] = <span class="literal">true</span>;</span><br><span class="line">    res += mincost[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">      mincost[u] = min(mincost[u], cost[v][u]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>Kruskal 算法是按照边的权值的顺序从小到大看一遍。Kruskal 在边的排序上最花时间，算法复杂度为 $O(|E| \times log(|E|))$。Kruskal 使用并查集，每次找到未使用的最小的边时，首先判断是否在一个集合。在一个集合就啥也不做，否则就把两者所在的集合合并。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> u, v, cost; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> edge &amp;e1, <span class="keyword">const</span> edge &amp;e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="keyword">int</span> V, E;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sort(es, es + E, comp);</span><br><span class="line">  init_union_find(V);</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">    edge e = es[i];</span><br><span class="line">    <span class="keyword">if</span> (!same(e.u, e.v)) &#123;</span><br><span class="line">      unite(e.u, e.v);</span><br><span class="line">      res += e.cost;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><p><em>References</em></p>
<ul>
<li><a href="http://www.renfei.org/blog/bipartite-matching.html" target="_blank" rel="noopener">二分图的最大匹配、完美匹配和匈牙利算法</a></li>
<li><a href="http://www.cnblogs.com/kuangbin/archive/2012/08/19/2646535.html" target="_blank" rel="noopener">二分图最佳匹配</a></li>
</ul>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><p><em>References</em></p>
<ul>
<li><a href="http://www.acmerblog.com/ford-fulkerson-6135.html" target="_blank" rel="noopener">Ford-Fulkerson</a></li>
<li><a href="http://www.cnblogs.com/smartweed/p/5865727.html" target="_blank" rel="noopener">网络流详解</a></li>
</ul>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p>求解最大公约数问题可以使用辗转相除法。辗转相除法实际上由一个等价公式推出：$gcd(a, b)=gcd(b, a \mod b)$，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>最大公约数与最小公倍数在数学上存在联系：$lcm(a, b) = \dfrac{a \times b}{gcd(a, b)}$ 。只要计算出 $gcd(a, b)$，通过上式可计算 $lcm(a, b)$。</p>
<h2 id="素数判断"><a href="#素数判断" class="headerlink" title="素数判断"></a>素数判断</h2><p>恰好有两个<a href="http://baike.baidu.com/link?url=H6FcG9LNr4dOcDhM9iUypySTe4SoA1hrwqku9pITHu_vhKwNS9Z6RDq8BJiQVZtkqOK3Hccj4VAVnWjEHXV6LDADhmlL1-HBykMrhKjWz__" target="_blank" rel="noopener">约数</a>的整数被称为素数。如果 $d$ 是数 $n$ 的约数，那么 $\dfrac{n}{d}$ 也是 $n$ 的约数。因此只需要检查 $2 \to \sqrt{n}$ 范围内的整数就够了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法适合查询一次，如果查询多次，有另一种办法。埃氏筛法可以枚举 $n$ 以内的素数，其主要思路是将 $2 \to n$范围内的数据都写下来。其中最小的数字是 $2$，然后将所有 $2$ 的倍数全部删去。依次类推，将剩余的最小数字 $m$ 的倍数全部删去，最后得到的便是 $2 \to n$ 内所有的素数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">  is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">      prime[p++] = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i) is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速幂实际上应用了二进制优化的思想。对于 $k^m$ 有 $k^{1+2+\cdots+i=m}=k^1 \times k^2 \times \cdots \times k^i$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">    x = x * x; </span><br><span class="line">    m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/linyujun/p/5194142.html" target="_blank" rel="noopener">数论四大定理</a></li>
<li><a href="http://www.acmerblog.com/extend-gcd-5610.html" target="_blank" rel="noopener">扩展欧几里得算法</a></li>
<li><a href="http://www.cnblogs.com/shawn-ji/p/5674772.html" target="_blank" rel="noopener">关于取模运算和求逆元</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/06/13/Computer-Science-Knowledge-System/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/13/Computer-Science-Knowledge-System/" itemprop="url">Computer Science Knowledge System</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-13T23:52:08+08:00">
                2017-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/13/Computer-Science-Knowledge-System/" class="leancloud_visitors" data-flag-title="Computer Science Knowledge System">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p><a href="http://www.hashcoding.net/2017/08/26/CSKS-%E4%B8%80-%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">CSKS-(一)、数据结构和算法</a></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><a href="http://www.hashcoding.net/2017/08/26/CSKS-%E4%BA%8C-%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">CSKS-(二)、数据库系统</a></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>操作系统是管理和控制计算机硬件与软件资源的计算机程序，功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，改善人机界面，为其它应用软件提供支持，让计算机系统所有资源最大限度地发挥作用，提供各种形式的用户界面，使用户有一个好的工作环境，为其它软件的开发提供必要的服务和相应的接口等。</p>
<p>操作系统主要有五大功能：处理机管理（CPU）、进程管理、内存管理、设备管理和文件系统管理。</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>进程时用户提交给操作系统运行的最小单元。在学术上，进程是具有一定功能的程序关于某个数据集合上的一次运行活动，是系统进行资源调度和分配的一个独立单位。除了进程，操作系统还提供了更小粒度的调度对象-线程。线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。一个进程可以有多个线程，多个线程也可以并发执行。</p>
<p>一般情况下，系统按照以下流程创建一个进程：</p>
<ol>
<li>分配、初始化 PCB </li>
<li>初始化机器寄存器</li>
<li>拷贝、初始化内存页表</li>
<li>从硬盘加载程序代码到内存</li>
<li>将进程加入就绪队列</li>
<li>进程调度时，选择该进程并切换到用户态开始执行进程</li>
</ol>
<p>系统通过快速切换进程，让每一个进程都有一定的时间片来响应用户提交的请求；在用户的视角，好像每个进程都在同时执行一样。系统切换进程的方法叫做进程调度算法，基本的调度算法有：先来先服务、时间片轮转、短作业优先、优先级调度以及多级反馈队列调度。</p>
<p>除了进程切换，操作系统还负责管理进程的虚拟内存。一般情况下，系统会在硬盘上开辟一个空间作为交换区，用于在物理内存不足时选择性地交换部分虚拟页，以开辟出足够的物理空间。用于选择交换的页面的算法称为页面置换算法。基本的页面置换算法有：FIFO、第二次机会、时钟轮转、LRU 和 NRU。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/kxdblog/p/4798401.html" target="_blank" rel="noopener">操作系统常用调度算法-cnblogs</a></li>
<li><a href="http://www.cnblogs.com/edisonchou/p/5003694.html" target="_blank" rel="noopener">操作系统核心原理-3.进程原理（上）：进程概要</a></li>
<li><a href="http://www.cnblogs.com/edisonchou/p/5020681.html" target="_blank" rel="noopener">操作系统核心原理-3.进程原理（中）：进程调度</a></li>
<li><a href="http://www.cnblogs.com/shijingjing07/p/5611579.html" target="_blank" rel="noopener">虚拟内存详解-cnblogs</a></li>
<li><a href="http://www.cnblogs.com/ranjiewen/p/7141696.html" target="_blank" rel="noopener">操作系统学习-内存管理</a></li>
<li><a href="http://www.cnblogs.com/ranjiewen/p/7158267.html" target="_blank" rel="noopener">操作系统学习-虚拟内存</a></li>
</ul>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>线程之间共享内存，但拥有各自不同的运行栈；进程之间则相互隔离。线程之间并发需要解决的是线程同步问题，进程之间则是通信问题。</p>
<p>线程之间同步由四种基本操作提供：</p>
<ul>
<li>原子操作</li>
<li>互斥量</li>
<li>信号量</li>
<li>条件变量</li>
</ul>
<p>在以上四种基本操作的基础上，形成了高级通信工具。如：阻塞队列，共享内存等。</p>
<p>一般情况下，原子变量用于构造乐观锁，比如 <code>spinlock</code> 。其他情况下使用条件变量和互斥量结合起来足够完成任务，同时还不容易出错。如果使用信号量，需要在自己的程序里也维护计数值，而信号量本身也需要维护计数值，需要用户自己进行维护。</p>
<p>与信号量相比，互斥量增减了所有权的概念；锁住的互斥量只能由上锁的线程解开。信号量则没有这些限制。条件变量与信号量相比，没有了数量限制，资源数量隐含在程序的逻辑中。</p>
<p>信号量与另外两者的区别主要在于“同步”一词，同步可以看作两部分：一部分是等待数据的“事件”或者“通知”；另一部分是保护数据的“临界区”。信号量直接满足这两个功能，互斥锁与信号量各满足一部分。在 <code>do one thing and do it best</code> 的指导下，更建议使用后两者。linux 内核曾将信号量作为同步原语，后来将之换为了互斥锁，需要“通知”的场景则换成了条件变量，不仅代码变简单了，速度也上去了。</p>
<p>进程之间通信常用的方式有：</p>
<ul>
<li>管道</li>
<li>共享内存</li>
<li>信号</li>
<li>消息队列</li>
<li>socket</li>
<li>RPC(Remote Process Call)</li>
</ul>
<p>其中管道、信号、共享内存和消息队列只能运行在一台机器上，而 socket 和 RPC 则提供了远程支持。当然，也有在 socket 或 RPC 基础上实现消息队列的。一般需要实现进程间通信，可以直接考虑 socket 或 RPC，毕竟以后的业务场景有可能扩展到多机。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/edisonchou/p/5022508.html" target="_blank" rel="noopener">操作系统核心原理-3.进程原理（下）：进程通信</a></li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>
<p>死锁产生的四个条件（有一个条件不成立，则不会产生死锁）</p>
<ol>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>
<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>
</ol>
<p>只要上述一个条件不成立，就不会产生死锁，所以解决死锁的基本方法有：：预防死锁、避免死锁、检测死锁、解除死锁。其常用策略为：鸵鸟策略、预防策略、避免策略、检测与解除死锁。</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><em>References</em></p>
<ul>
<li><a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux man</a></li>
<li><a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts.php" target="_blank" rel="noopener">第十二章、學習 Shell Scripts</a></li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><a href="http://www.jianshu.com/p/8013477d344a" target="_blank" rel="noopener">计算机网网络总结</a></p>
<h2 id="从-URL-到页面的过程"><a href="#从-URL-到页面的过程" class="headerlink" title="从 URL 到页面的过程"></a>从 URL 到页面的过程</h2><p>// TODO:</p>
<h2 id="分层与协议"><a href="#分层与协议" class="headerlink" title="分层与协议"></a>分层与协议</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP 是面向连接的、可靠的流式通信传输协议；UDP 是无连接的、不可靠的通信协议。</p>
<p><a href="http://blog.163.com/li_xiang1102/blog/static/607140762011111103213616/" target="_blank" rel="noopener">Nagle 算法</a><br><a href="http://www.cnblogs.com/zhaoyl/archive/2012/09/20/2695799.html" target="_blank" rel="noopener">糊涂窗口综合症和 Nagle 算法</a><br><a href="https://my.oschina.net/xinxingegeya/blog/485643" target="_blank" rel="noopener">Nagle &amp; Delayed ACK</a><br><a href="http://blog.csdn.net/wdscq1234/article/details/52430382" target="_blank" rel="noopener">Delayed ACK</a><br><a href="http://www.hashcoding.net/2017/05/26/Linux-TCP-%E7%BC%96%E7%A8%8B/">Linux TCP 编程</a></p>
<p>拥塞控制<br>流量控制<br>滑动窗口</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p><a href="http://blog.codingnow.com/2016/03/reliable_udp.html" target="_blank" rel="noopener">可靠 UDP 传输</a></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP（超文本传输协议，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。是用于从 WWW 服务器传输超文本到本地浏览器的传输协议。默认使用 80 端口，HTTP 客户端发起一个请求，建立一个到服务器指定端口（默认是 80 端口）的 TCP 连接。</p>
<p>HTTP 连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。HTTP/1.0 是第一个在通讯中指定版本号的 HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。HTTP/1.1 是当前版本，持久连接被默认采用，并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。 HTTP／2.0 在 HTTP 1.x 的基础上，大幅度的提高了 web 性能，减少了网络延迟。HTTP1.0 和 1.1 在之后很长的一段时间内会一直并存，这是由于网络基础设施更新缓慢所决定的。</p>
<p>关于更多 HTTP 协议的基础信息，可以看<a href="http://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="noopener">HTTP基础</a>、<a href="http://www.jianshu.com/p/178da1e2903c" target="_blank" rel="noopener">HTTP 请求方法和幂等性探究</a>、<a href="http://www.cnblogs.com/weidagang2046/archive/2011/06/04/2063696.html" target="_blank" rel="noopener">理解 HTTP 幂等性</a>。</p>
<p>HTTP 以 TCP 作为传输协议，自然要面临链接管理的问题，<a href="http://www.jianshu.com/p/f424eb4175ac" target="_blank" rel="noopener">HTTP连接管理</a>、<a href="http://www.jianshu.com/p/1102f00002ff" target="_blank" rel="noopener">谈谈 HTTP 连接管理</a>。</p>
<p>另外，随着网络访问量的提升，性能瓶颈问题开始出现。HTTP 对于这部分问题的解决办法是：对固定的资源进行缓存。HTTP 缓存通常分为：强制缓存、对比缓存。关于 HTTP 缓存的具体内容参考：<a href="http://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">HTTP缓存机制</a>。</p>
<p>最后，关于 HTTP 协议中常见的两种攻击方式：<a href="https://segmentfault.com/a/1190000007059639" target="_blank" rel="noopener">用大白话谈谈XSS与CSRF</a>。</p>
<p><em>References</em></p>
<ul>
<li><a href="https://imququ.com/post/http2-resource.html" target="_blank" rel="noopener">HTTP 2.0 资料汇总</a></li>
</ul>
<h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><p><a href="https://segmentfault.com/a/1190000002554673" target="_blank" rel="noopener">SSL/TLS 原理详解</a>。</p>
<h2 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h2><p>// TODO:</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="CAP-理论和-BASE-理论"><a href="#CAP-理论和-BASE-理论" class="headerlink" title="CAP 理论和 BASE 理论"></a>CAP 理论和 BASE 理论</h3><p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/chen77716/article/details/30635543" target="_blank" rel="noopener">CAP 理论</a></li>
<li><a href="http://blog.csdn.net/dc_726/article/details/42784237" target="_blank" rel="noopener">CAP 理论和最终一致性</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25933039?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">最终一致性实现方式</a></li>
<li><a href="http://www.cnblogs.com/duanxz/p/5229352.html" target="_blank" rel="noopener">CAP 理论和 BASE 理论</a></li>
</ul>
<h3 id="一致性-Hash"><a href="#一致性-Hash" class="headerlink" title="一致性 Hash"></a>一致性 Hash</h3><p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">每天进步一点点——五分钟理解一致性哈希算法(consistent hashing)</a></li>
<li><a href="http://www.cnblogs.com/lpfuture/p/5796398.html" target="_blank" rel="noopener">一致性Hash算法原理</a></li>
<li><a href="http://www.blogjava.net/hello-yun/archive/2012/10/10/389289.html" target="_blank" rel="noopener">一致性Hash算法Java实现</a></li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><a href="http://www.hashcoding.net/2017/08/26/CSKS-%E4%B8%89-%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">CSKS-(三)、设计模式</a></p>
<h1 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/itmr_liu/article/details/51869905" target="_blank" rel="noopener">C++11 标准基本数据类型</a></li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/BeyondAnyTime/archive/2012/08/23/2652696.html" target="_blank" rel="noopener">C++11 四种类型转换</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27966225" target="_blank" rel="noopener">C++笔记 · C++类型转换</a></li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><em>References</em></p>
<ul>
<li><a href="www.hashcoding.net/2017/03/02/Effective-C-Accustoming-Yourself-to-C/">Accustoming Yourself to C++</a></li>
<li><a href="www.hashcoding.net/2017/03/02/Effective-c-Constructors-Destructors-and-Assignment-Operators/">Constructors,Destructors,and Assignment Operators</a></li>
<li><a href="www.hashcoding.net/2017/03/05/Effective-C-Resource-management/">Resource management</a></li>
<li><a href="www.hashcoding.net/2017/03/05/Effective-C-Designs-Implements/">Designs &amp; Implements</a></li>
<li><a href="www.hashcoding.net/2017/03/05/Effective-C-Exception-safe-code/">Exception-safe code</a></li>
<li><a href="www.hashcoding.net/2017/01/15/C-%E5%AF%B9%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">C++对象线程安全</a></li>
</ul>
<h3 id="C-疑难解答"><a href="#C-疑难解答" class="headerlink" title="C++ 疑难解答"></a>C++ 疑难解答</h3><p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/origin_lee/article/details/40541053" target="_blank" rel="noopener">取余和取模</a></li>
<li><a href="http://blog.csdn.net/solstice/article/details/5139302" target="_blank" rel="noopener">带符号整数的除法和余数</a></li>
<li><a href="http://0xffffff.org/2016/02/11/38-c++-concurrency/" target="_blank" rel="noopener">C++并发编程那些事</a></li>
<li><a href="http://blog.csdn.net/booirror/article/details/45057689" target="_blank" rel="noopener">深入理解右值引用-move语义和完美转发</a></li>
<li><a href="http://www.cnblogs.com/jianxinzhou/p/3994248.html" target="_blank" rel="noopener">C++完全总结</a></li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="类加载原理"><a href="#类加载原理" class="headerlink" title="类加载原理"></a>类加载原理</h3><p>Java和其他语言不同的是，Java是运行于Java虚拟机(JVM)。这就意味着编译后的代码是以一种和平台无关的格式保存的，而不是某种特定的机器上运行的格式。这种格式和传统的可执行代码格式有很多重要的区别。具体来说，不同于C或者Ｃ++程序，Java程序不是一个独立的可执行文件，而是由很多分开的类文件组成，每个类文件对应一个Java类。另外，<strong>这些类文件并不是马上加载到内存，而是当程序需要的时候才加载</strong>。类加载器就是Java虚拟机中用来把类加载到内存的工具。</p>
<p>Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能。虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>类装载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤：</p>
<ol>
<li>装载：查找和导入Class文件；</li>
<li>链接：把类的二进制数据合并到JRE中；<ul>
<li>校验：检查载入Class文件数据的正确性；</li>
<li>准备：给类的静态变量分配存储空间；</li>
<li>解析：将符号引用转成直接引用；</li>
</ul>
</li>
<li>初始化：对类的静态变量，静态代码块执行初始化操作</li>
</ol>
<h4 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h4><ol>
<li>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用 <code>new</code> 关键字实例化对象的时候，读取或设置一个类的静态字段（被 <code>final</code> 修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个主类。</li>
</ol>
<p>只有上述四种情况会触发初始化，也称为对一个类进行主动引用，除此以外，所有其他方式都不会触发初始化，称为被动引用。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java 中数据类型分为两种：基本数据类型，引用数据类型。</p>
<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><p>基础数据类型由数值型、字符型和布尔型组成，其中数值型有：</p>
<ul>
<li>byte </li>
<li>short</li>
<li>int </li>
<li>long </li>
<li>float </li>
<li>double </li>
</ul>
<p>字符型：<code>char</code> 可以表示任意有 <code>unicode</code> 编码的值，2字节长度。布尔型 <code>boolean</code> 表示逻辑运算类型。</p>
<p><code>char</code> 本质上是 UTF-16 定常编码，换而言之，<code>char</code> 中只能存放 <code>UTF-16</code> 编码下只占2字节长度的字符。</p>
<h5 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h5><p><strong>自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换</strong>。由于实际开发中这样的类型转换很多，所以 Java 语言在设计时，没有为该操作设计语法，而是由 JVM 自动完成。</p>
<p>转换规则：从存储范围小的类型到存储范围大的类型。<br>具体规则为：byte→short(char)→int→long→float→double</p>
<p>也就是说 byte 类型的变量可以自动转换为 short 类型，示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>  b  =  <span class="number">10</span>;</span><br><span class="line"><span class="keyword">short</span>  sh  =  b;</span><br></pre></td></tr></table></figure>
<p>这里在赋值时，JVM 首先将 <code>b</code> 的值转换为 <code>short</code> 类型，然后再赋值给 <code>sh</code>。<br>在类型转换时可以跳跃。示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>  b1  =  <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span>  n  =  b1;</span><br></pre></td></tr></table></figure>
<p>类型转换中可能存在着坑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">0</span>;</span><br><span class="line">a = a + <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">a += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>执行 <code>+1</code> 时，<code>a</code> 被转换为整形，然后做加法，赋值给 <code>a</code> 时类型不一致，需要强制类型转换；而 <code>+=</code> 则由编译器内部实现 <code>+1</code> 逻辑。</p>
<blockquote>
<p>注意问题:在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失。</p>
</blockquote>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p><strong>强制类型转换，也称显式类型转换，是指必须书写代码才能完成的类型转换</strong>。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种损失时才进行该类型的转换。</p>
<p>转换规则:从存储范围大的类型到存储范围小的类型。<br>具体规则为：double→float→long→int→short(char)→byte<br>语法格式为：(转换到的类型)需要转换的值</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>  d  =  <span class="number">3.10</span>;</span><br><span class="line"><span class="keyword">int</span>  n  =  (<span class="keyword">int</span>)d;</span><br></pre></td></tr></table></figure>
<p>这里将 <code>double</code> 类型的变量 <code>d</code> 强制转换成 <code>int</code> 类型，然后赋值给变量 <code>n</code>。需要说明的是小数强制转换为整数，采用的是<strong>去 1 法</strong>，也就是无条件的舍弃小数点的所有数字，则以上转换出的结果是 <code>3</code>。整数强制转换为整数时取数字的低位，例如 <code>int</code> 类型的变量转换为 <code>byte</code> 类型时，则只去 <code>int</code> 类型的低 <code>8</code> 位(也就是最后一个字节)的值。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  n  =  <span class="number">123</span>;</span><br><span class="line"><span class="keyword">byte</span>  b  =  (<span class="keyword">byte</span>)n;</span><br><span class="line"><span class="keyword">int</span>  m  =  <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">byte</span>  b1  =  (<span class="keyword">byte</span>)m;</span><br></pre></td></tr></table></figure>
<p>则 <code>b</code> 的值还是 <code>123</code>，而 <code>b1</code> 的值为 <code>-46</code>。<code>b1</code> 的计算方法如下：<code>m</code> 的值转换为二进制是 <code>10011010010</code>，取该数字低 <code>8</code> 位的值作为 <code>b1</code> 的值，则 <code>b1</code> 的二进制值是 <code>11010010</code>，按照机器数的规定，最高位是符号位，<code>1</code> 代表负数，在计算机中负数存储的是补码，则该负数的原码是 <code>10101110</code>，该值就是十进制的 <code>-46</code>。</p>
<blockquote>
<p>注意问题:强制类型转换通常都会存储精度的损失，所以使用时需要谨慎。</p>
</blockquote>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>引用数据类型有三大类：</p>
<ul>
<li>接口</li>
<li>对象</li>
<li>数组</li>
</ul>
<p>引用数据类型也存在着自动转换和强制类型转换，自动转换负责将子类对象转换成父类对象，强制转换则将父类对象转换成子类对象。</p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p><code>java.lang</code> 包在使用的时候无需显示导入，编译时由编译器自动导入。<code>Object</code> 类是类层次结构的根，Java 中所有的类从根本上都继承自这个类。<code>Object</code> 类是 Java 中唯一没有父类的类。其他所有的类，包括标准容器类，比如数组，都继承了 <code>Object</code> 类中的方法。</p>
<p><code>Object</code> 类中有如下方法：</p>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h4><p><code>clone</code> 方法<strong>创建并返回对象的一份拷贝</strong>，其原型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br></pre></td></tr></table></figure>
<p>这个方法有两点比较特殊的：</p>
<ul>
<li>使用这个方法的类必须实现 <code>java.lang.Cloneable</code> 接口，否则会抛出 <code>CloneNotSupportedException</code> 异常。<code>Cloneable</code> 接口中不包含任何方法，所以实现它时只要在类声明中加上 <code>implements</code> 语句即可；</li>
<li>这个方法是 <code>protected</code> 修饰的，覆写 <code>clone()</code> 方法的时候需要写成 <code>public</code>，才能让类外部的代码调用；</li>
</ul>
<h4 id="equals-Object-obj"><a href="#equals-Object-obj" class="headerlink" title="equals(Object obj)"></a>equals(Object obj)</h4><p><code>equals</code> 方法等价于 <code>==</code> 运算符，用于判断两个对象是否指向同一个对象。</p>
<blockquote>
<p>在 Java 中，<code>==</code> 运算符默认使用<strong>引用语义</strong>，即比较两个对象是否引用同一对象；C/C++ 相反，默认使用<strong>值语义</strong>，比较内部数据是否相同。</p>
</blockquote>
<p><code>Object</code> 类中的 <code>equals()</code> 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即 <code>Object</code> 类中的 <code>equals()</code> 方法等价于 <code>==</code>，只有当继承 <code>Object</code> 的类覆写（<code>override</code>）了 <code>equals()</code> 方法之后，继承类实现了用 <code>equals()</code> 方法比较两个对象是否相等，才可以说 <code>equals()</code> 方法与 <code>==</code> 不同。比如 <code>String</code> 类覆写了 <code>equals()</code> 方法，实现了<strong>值语义</strong>。</p>
<p><code>equals()</code> 方法需要具有如下特点：</p>
<ul>
<li>自反性：任何非空引用 <code>x</code>，<code>x.equals(x)</code>返回为 <code>true</code>;</li>
<li>对称性：任何非空引用 <code>x</code> 和 <code>y</code>，<code>x.equals(y)</code> 返回 <code>true</code> 当且仅当 <code>y.equals(x)</code> 返回 <code>true</code>;</li>
<li>传递性：任何非空引用 <code>x</code> 和 <code>y</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code>，并且 <code>y.equals(z)</code> 返回 <code>true</code>，那么 <code>x.equals(z)</code> 返回 <code>true</code>。</li>
<li>一致性：两个非空引用 <code>x</code> 和 <code>y</code>，<code>x.equals(y)</code> 的多次调用应该保持一致的结果，（前提条件是在多次比较之间没有修改 <code>x</code> 和 <code>y</code> 用于比较的相关信息）。</li>
<li>约定：对于任何非空引用 <code>x</code>，<code>x.equals(null)</code> 应该返回为 <code>false</code>。</li>
<li>并且覆写 <code>equals()</code> 方法时，应该同时覆写 <code>hashCode()</code> 方法，反之亦然。</li>
</ul>
<p>前面三个特点属于<strong>等价关系</strong>需要满足的条件，所以<strong>对于任何非空引用，<code>equals()</code> 方法定义了该引用上的等价关系</strong>。</p>
<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h4><p><code>hashCode()</code> 返回当前对象的 <code>hash code</code>，原型如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int	hashCode()</span><br></pre></td></tr></table></figure>
<p>这个方法返回一个整型值（hash code value），如果两个对象被 <code>equals()</code> 方法判断为相等，那么它们就应该拥有同样的hash code。</p>
<p><code>Object</code> 类的 <code>hashCode()</code> 方法为不同的对象返回不同的值，<code>Object</code> 类的 <code>hashCode</code> 值表示的是对象的地址。</p>
<p><code>hashCode</code> 方法需要满足一定条件：</p>
<ol>
<li>一致性：<code>hashCode()</code> 方法多次执行结果应该相同（未修改时）；</li>
<li>当你覆写了 <code>equals()</code> 方法之后，必须也覆写 <code>hashCode()</code> 方法，反之亦然；</li>
<li>如果 <code>equals()</code> 判断两个对象不相等，那么它们的 <code>hashCode()</code> 方法就应该返回不同的值（未强制要求）；</li>
</ol>
<p>两个对象用 <code>equals()</code> 方法比较返回 <code>false</code>，它们的 <code>hashCode</code> 可以相同也可以不同。</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p><code>toString()</code> 方法返回对象的 <code>String</code> 表示。当打印引用，如调用 <code>System.out.println()</code> 时，会自动调用对象的 <code>toString()</code> 方法，打印出引用所指的对象的 <code>toString()</code> 方法的返回值，因为每个类都直接或间接地继承自 <code>Object</code>，因此每个类都有 <code>toString()</code> 方法。</p>
<p><code>Object</code> 类中的 <code>toString()</code> 方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/iamzhoug37/p/4279151.html" target="_blank" rel="noopener">Java finalize() 方法详解</a></li>
</ul>
<h4 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h4><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/lianghui66/archive/2012/12/03/2799134.html" target="_blank" rel="noopener">Java getClass() 方法详解</a></li>
</ul>
<h4 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h4><p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/zimo2013/article/details/40181349" target="_blank" rel="noopener">Java Object wait()、notify()、notifyAll()</a></li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><em>References</em></p>
<ul>
<li><a href="http://www.jianshu.com/p/c8ac39183522" target="_blank" rel="noopener">Java 泛型基础</a></li>
<li><a href="https://www.zhihu.com/question/20400700" target="_blank" rel="noopener">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a></li>
<li><a href="http://www.jianshu.com/p/4caf2567f91d" target="_blank" rel="noopener">Java 泛型进阶</a></li>
<li><a href="http://www.jianshu.com/p/b99a40c1f760" target="_blank" rel="noopener">浅谈 Java 泛型</a></li>
</ul>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>数组比较特殊，其有一个 <code>length</code> 成员，表示数组长度。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://www.iteye.com/news/28296" target="_blank" rel="noopener">Java 数组操作</a></li>
<li><a href="http://www.jianshu.com/p/355d6416c26c" target="_blank" rel="noopener">Java Arrays 详解</a></li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><em>References</em></p>
<ul>
<li><a href="http://www.cnblogs.com/springcsc/archive/2009/12/03/1616326.html" target="_blank" rel="noopener">String 类常用方法详解</a></li>
<li><a href="http://www.cnblogs.com/lwbqqyumidi/p/4060845.html" target="_blank" rel="noopener">String 类详解</a></li>
<li><a href="http://blog.csdn.net/kingzone_2008/article/details/9220691" target="_blank" rel="noopener">String StringBuffer StringBuilder 详解</a></li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><code>Collection</code>是Java中的集合类的一个抽象接口，在其上有更具体的接口实现：<code>Set</code>和<code>List</code>。</p>
<p><em>References</em></p>
<ul>
<li><a href="http://www.jianshu.com/p/f23ec9da6ecf" target="_blank" rel="noopener">Java Collection 详解</a></li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><code>Set</code>中方法与<code>Collection</code>一致。</p>
<ol>
<li><p><code>HashSet</code>：内部数据结构是哈希表，是不同步的。<code>Set</code>集合中元素都必须是唯一的，<code>HashSet</code>作为其子类也需保证元素的唯一性。<br> 判断元素唯一性的方式：<br> 通过存储对象（元素）的<code>hashCode</code>和<code>equals</code>方法来完成对象唯一性的。<br> 如果对象的<code>hashCode</code>值不同，那么不用调用<code>equals</code>方法就会将对象直接存储到集合中；<br> 如果对象的<code>hashCode</code>值相同，那么需调用<code>equals</code>方法判断返回值是否为<code>true</code>，<br> 若为<code>false</code>, 则视为不同元素，就会直接存储；<br> 若为<code>true</code>， 则视为相同元素，不会存储。</p>
<p> PS：如果要使用<code>HashSet</code>集合存储元素，该元素的类必须覆盖<code>hashCode</code>方法和<code>equals</code>方法。一般情况下，如果定义的类会产生很多对象，通常都需要覆盖<code>equals</code>，<code>hashCode</code>方法。建立对象判断是否相同的依据。</p>
</li>
<li><p><code>TreeSet</code>：保证元素唯一性的同时可以对内部元素进行排序，是不同步的。<br> 判断元素唯一性的方式：<br> 根据比较方法的返回结果是否为0，如果为0视为相同元素，不存；如果非0视为不同元素，则存。<br> <code>TreeSet</code>对元素的排序有两种方式：<br> 方式一：使元素（对象）对应的类实现<code>Comparable</code>接口，覆盖<code>compareTo</code>方法。这样元素自身具有比较功能。<br> 方式二：使<code>TreeSet</code>集合自身具有比较功能，定义一个类实现<code>Comparable</code>接口覆盖其<code>compareTo</code>方法。（相当于自定义了一个比较器）将该类对象作为参数传递给<code>TreeSet</code>集合的构造函数。（<code>TreeSet(Comparator&lt;? super E&gt; c)</code>）</p>
</li>
</ol>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code>保存具有映射关系的数据，因此<code>Map</code>集合里保存着两组值，一组值用来保存<code>Map</code>里的<code>key</code>,一组用来保存<code>Map</code>里的<code>value</code>,<code>key</code>和<code>value</code>可以是任何引用类型的数据。</p>
<p><code>Map</code>里的<code>key</code>不允许重复，<code>value</code>可以重复。<code>key</code>和<code>value</code>之间存在单向的一对一的关系，通过指定的<code>key</code>，总能找到唯一的、确定的<code>value</code>。</p>
<h5 id="HashMap与HashTable"><a href="#HashMap与HashTable" class="headerlink" title="HashMap与HashTable"></a>HashMap与HashTable</h5><p><code>HashMap</code>与<code>HashTable</code>都是<code>Map</code>的典型实现类，他们之间的关系类似于<code>ArrayList</code>和<code>Vector</code>：<code>HashTable</code>是一个古老的<code>Map</code>实现类，在JDK1.0时就出现了。<br>主要区别：</p>
<ol>
<li><p><code>HashTable</code>是一个线程安全的<code>Map</code>实现，但是<code>HashMap</code>是线程不安全的实现，<code>HashMap</code>的性能要比<code>HashTable</code>高一些，尽量避免使用<code>HashTable</code>,多个线程访问一个<code>Map</code>对象又要保证线程安全时，可以使用<code>Collections</code>中的方法把<code>HashMap</code>变成线程安全的。</p>
</li>
<li><p><code>HashTable</code>不允许使用<code>null</code>作为<code>key</code>和<code>value</code>,如果试图把<code>null</code>加入<code>HashTable</code>中，将会引发空指针异常。</p>
</li>
</ol>
<h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p><code>TreeMap</code>是<code>Map</code>的子接口<code>SortedMap</code>的的实现类，与<code>TreeSet</code>类似的是<code>TreeMap</code>也是基于红黑树对<code>TreeMap</code>中所有的<code>key</code>进行排序，从而保证<code>key-value</code>处于有序状态，<code>TreeMap</code>也有两种排序方式：</p>
<ol>
<li><p>自然排序：<code>TreeMap</code>的所有<code>key</code>必须实现<code>Comparable</code>接口，而且所有<code>key</code>应该是同一类的对象，否则会抛出<code>ClassCastException</code>.</p>
</li>
<li><p>定制排序：创建<code>TreeMap</code>时，传入一个<code>Comparator</code>对象，该对象负责对<code>TreeMap</code>中所有的<code>key</code>进行排序。<br>由于<code>TreeMap</code>支持内部排序，所以通常要比<code>HashMap</code>和<code>HashTable</code>慢。</p>
</li>
</ol>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p><code>Queue</code>模拟了队列这种数据结构，队列通常是“先进先出”的数据结构，通常不允许随机访问队列中的元素。</p>
<p><code>Queue</code>常用的实现类：<code>LinkedList</code>和<code>PriorityQueue</code>。</p>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p><code>LinkedList</code>它不仅实现了<code>List</code>接口还实现了<code>Dueue</code>接口(双端队列，既具有队列的特征，也具有栈的特征)，<code>Dueue</code>接口是<code>Queue</code>的子接口。</p>
<h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p><code>PriorityQueue</code>保存队列元素的的顺序并不是按照加入队列的顺序，而是按照队列元素大小进行重新排序。所以当调用<code>peek</code>和<code>poll</code>方法来取队列中的元素的时候，并不是先取出来队列中最小的元素。从这个意义上来看，<code>PriorityQueue</code>已经违反了队列的基本规则。<code>PriorityQueue</code>不允许插入<code>null</code>元素。</p>
<h3 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h3><p><em>References</em></p>
<ul>
<li><a href="http://blog.csdn.net/defonds/article/details/44021605/" target="_blank" rel="noopener">Java 并发工具包 <code>java.util.concurrent</code> 用户指南</a></li>
</ul>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><em>References</em></p>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">Python3 教程</a></li>
</ul>
<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><p><em>References</em></p>
<ul>
<li><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="noopener">系统设计入门</a></li>
</ul>
<h1 id="Others-1"><a href="#Others-1" class="headerlink" title="Others"></a>Others</h1><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p><em>References</em></p>
<ul>
<li><a href="http://blog.leanote.com/post/freewalk/Markdown-语法手册" title="Markdown-语法手册" target="_blank" rel="noopener">Markdown-语法手册</a></li>
<li><a href="http://einverne.github.io/markdown-style-guide/zh.html" target="_blank" rel="noopener">Markdown-书写风格指南</a></li>
</ul>
<h2 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h2><p><em>References</em></p>
<ul>
<li><a href="http://lixingcong.github.io/2016/04/04/LaTex-intro/" target="_blank" rel="noopener">Latex 数学公式</a></li>
</ul>
<h2 id="需要补充"><a href="#需要补充" class="headerlink" title="需要补充"></a>需要补充</h2><p>分布式架构：（了解原理就行，如果真的有实践经验更好）<br>CAP原理和BASE理论。<br>Nosql与KV存储（redis，hbase，mongodb，memcached等）<br>服务化理论（包括服务发现、治理等，zookeeper、etcd、springcloud微服务、）<br>负载均衡（原理、cdn、一致性hash）<br>RPC框架（包括整体的一些框架理论，通信的netty，序列化协议thrift，protobuff等）<br>消息队列（原理、kafka，activeMQ，rocketMQ）<br>分布式存储系统（GFS、HDFS、fastDFS）、存储模型（skipList、LSM等）<br>分布式事务、分布式锁等                        </p>
<p>大数据与数据分析：<br>hadoop生态圈(hive、hbase、hdfs、zookeeper、storm、kafka)<br>spark体系<br>语言：python、R、scala<br>搜索引擎与技术<br>机器学习算法：<br>模型和算法很多。<br>其他工具的理论和使用：<br>这个更多了，问的多的比如git、docker、maven/gradle、Jenkins等等</p>
<p><a href="https://zhuanlan.zhihu.com/p/23713529" target="_blank" rel="noopener">常见面试题整理–数据库篇</a><br><a href="https://zhuanlan.zhihu.com/p/23755202" target="_blank" rel="noopener">常见面试题整理–操作系统篇</a><br><a href="http://www.importnew.com/22083.html" target="_blank" rel="noopener">Java 面试题全集-上</a><br><a href="http://www.importnew.com/22087.html" target="_blank" rel="noopener">Java 面试题全集-下</a><br><a href="https://zhuanlan.zhihu.com/p/23526961" target="_blank" rel="noopener">常见面试题整理 Python 概念篇</a><br><a href="https://zhuanlan.zhihu.com/p/23582996" target="_blank" rel="noopener">常见面试题整理 Python 代码篇</a><br><a href="https://zhuanlan.zhihu.com/p/24001696" target="_blank" rel="noopener">常见面试题整理–计算机网络篇</a><br><a href="http://www.jianshu.com/p/7274615afea6" target="_blank" rel="noopener">计算机网络基础面试题</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/06/12/LeetCode-85-Maximal-Rectangle/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/12/LeetCode-85-Maximal-Rectangle/" itemprop="url">LeetCode - 85 Maximal Rectangle</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-12T19:33:29+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">LeetCode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/12/LeetCode-85-Maximal-Rectangle/" class="leancloud_visitors" data-flag-title="LeetCode - 85 Maximal Rectangle">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://leetcode.com/problems/maximal-rectangle/#/description" target="_blank" rel="noopener">85. Maximal Rectangle</a></p>
<p>首先看题意，题目需要求出由0和1组成的2Dmatrix中，全由1组成的矩形最大面积为多少。比如下面的矩形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br></pre></td></tr></table></figure>
<p>最大面积为 6。</p>
<p>在做这提前，需要看看前一题：<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/#/description" target="_blank" rel="noopener">84. Largest Rectangle in Histogram</a>。这道题目是求出柱状图中可以摆放下的最大矩形。</p>
<p>如何求解？仔细观察可以发现，像 <code>576</code> 这样的数据，可以看作中间高，两边低。而具体面积则由数据个数 * 选取区间中最矮的高度决定。所以完全可以把这几个变为：<code>555</code>、<code>7</code>和<code>66</code>这样的形式，然后再从中选出最大的。</p>
<p>所以这道题的简单解法是从头到尾扫一次，每次遇到递减时，将多出的部分计算后给扔掉，那么扔掉后的数据则仍然是递增的。比如<code>576</code>，当扫描到<code>6</code>时，计算得<code>7</code>，并将<code>7</code>改为<code>6</code>，得到<code>566</code>继续计算。这样，得到了中间去掉部分能组成的最大面积，和最后剩下的递增数组进行比较。对于单调递增的数据，也好算，减少宽度，增加高度就能算出来。所以代码部分如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        stack&lt;int&gt; stack;</span><br><span class="line">        int max_ = 0;</span><br><span class="line">        for (auto i : heights) &#123;</span><br><span class="line">            if (stack.empty())</span><br><span class="line">                stack.push(i);</span><br><span class="line">            else &#123;</span><br><span class="line">                int l = stack.top();</span><br><span class="line">                if (l &lt;= i) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    int count = 1;</span><br><span class="line">                    while (!stack.empty() &amp;&amp; stack.top() &gt; i) &#123;</span><br><span class="line">                        int t = stack.top();</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        if (t * count &gt; max_) &#123;</span><br><span class="line">                            max_ = t * count;</span><br><span class="line">                        &#125;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">                        stack.push(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!stack.empty()) &#123;</span><br><span class="line">            int count = stack.size();</span><br><span class="line">            for (int i = 1; i &lt;= count; ++i) &#123;</span><br><span class="line">                int t = stack.top();</span><br><span class="line">                stack.pop();</span><br><span class="line">                if (t * i &gt; max_)</span><br><span class="line">                    max_ = t * i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在回到计算matrix中的矩形问题上来。用一行将矩形分割成两半，上面部分和下面部分。遮住下面部分，那么看到的就是一个<code>Histogram</code>，则可以使用上面一题的解法来做。将行往下挪，如果出现了(1/0/1)这样的列数据，不再是一个<code>Histogram</code>，那么可以认为0以上部分全为0，得到<code>Histogram</code>。所以题目答案为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if (matrix.empty() || matrix[0].empty()) return 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        vector&lt;int&gt; heights(matrix[0].size(), 0);</span><br><span class="line">        for (int i = 0; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; matrix[0].size(); ++j) &#123;</span><br><span class="line">                heights[j] = (matrix[i][j] == &apos;0&apos;) ? 0 : heights[j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            max = std::max(largestRectangleArea(heights), max);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        stack&lt;int&gt; stack;</span><br><span class="line">        int max_ = 0;</span><br><span class="line">        for (auto i : heights) &#123;</span><br><span class="line">            if (stack.empty())</span><br><span class="line">                stack.push(i);</span><br><span class="line">            else &#123;</span><br><span class="line">                int l = stack.top();</span><br><span class="line">                if (l &lt;= i) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    int count = 1;</span><br><span class="line">                    while (!stack.empty() &amp;&amp; stack.top() &gt; i) &#123;</span><br><span class="line">                        int t = stack.top();</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        if (t * count &gt; max_) &#123;</span><br><span class="line">                            max_ = t * count;</span><br><span class="line">                        &#125;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">                        stack.push(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!stack.empty()) &#123;</span><br><span class="line">            int count = stack.size();</span><br><span class="line">            for (int i = 1; i &lt;= count; ++i) &#123;</span><br><span class="line">                int t = stack.top();</span><br><span class="line">                stack.pop();</span><br><span class="line">                if (t * i &gt; max_)</span><br><span class="line">                    max_ = t * i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/06/04/SO-REUSEADDR-SO-REUSEPORT-异同/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/04/SO-REUSEADDR-SO-REUSEPORT-异同/" itemprop="url">SO_REUSEADDR & SO_REUSEPORT 异同</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-04T11:26:20+08:00">
                2017-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/06/04/SO-REUSEADDR-SO-REUSEPORT-异同/" class="leancloud_visitors" data-flag-title="SO_REUSEADDR & SO_REUSEPORT 异同">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2018-1-15 日更新：这里贴上 <code>man 7 socket</code> 中对 <code>SO_REUSEADDR</code> 和 <code>SO_REUSEPORT</code> 的说明，大有裨益。</p>
<ul>
<li><code>SO_REUSEADDR</code></li>
</ul>
<p>Indicates  that  the rules used in validating addresses supplied in a <code>bind</code>(2) call should allow<br>reuse of local addresses.  For <code>AF_INET</code> sockets this means that a socket may bind,  except  when<br>there  is  an active listening socket bound to the address.  When the listening socket is bound<br>to <code>INADDR_ANY</code> with a specific port then it is not possible to bind to this port for  any  local<br>address.  Argument is an integer boolean flag.</p>
<ul>
<li><code>SO_REUSEPORT</code> (since Linux 3.9)</li>
</ul>
<p>Permits  multiple <code>AF_INET</code> or <code>AF_INET6</code> sockets to be bound to an identical socket address.  <strong>This<br>option must be set on each socket (including the first socket) prior to calling <code>bind</code>(2) on  the<br>socket</strong>.   To prevent port hijacking, all of the processes binding to the same address must have<br>the same effective UID.  This option can be employed with both TCP and UDP sockets.</p>
<p>For TCP sockets, this option allows <code>accept</code>(2) load distribution in a multi-threaded  server  to<br>be  improved  by using a distinct listener socket for each thread.  This provides improved load<br>distribution as compared to traditional techniques such using a single <code>accept</code>(2)ing thread that<br>distributes  connections,  or  having  multiple threads that compete to <code>accept</code>(2) from the same<br>socket.</p>
<p>For UDP sockets, the use of this option can provide better distribution of  incoming  datagrams<br>to  multiple processes (or threads) as compared to the traditional technique of having multiple<br>processes compete to receive datagrams on the same socket.</p>
<p><strong>写在前面，本文转载自网络：<a href="http://blog.chinaunix.net/uid-28587158-id-4006500.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-28587158-id-4006500.html</a> ，请保留出处。</strong></p>
<p>文章内容来源于stackoverflow上的回答，写的很详细<a href="http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t" target="_blank" rel="noopener">http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t</a></p>
<p>虽然不同的系统上socket的实现方式有一些差异，但都来源于对BSD socket的实现，因此在讨论其它系统之前了解BSD socket的实现是非常有益的。首先我们需要了解一些基本知识，一个TCP/UDP连接是被一个五元组确定的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&lt;protocol&gt;, &lt;src addr&gt;, &lt;src port&gt;, &lt;dest addr&gt;, &lt;dest port&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>因此，任何两个连接都不可能拥有相同的五元组，否则系统将无法区别这两个连接。</p>
<p>当使用<code>socket()</code>函数创建套接字的时候，我们就指定了该套接字使用的protocol(协议)，<code>bind()</code>函数设置了源地址和源端口号，而目的地址和目的端口号则由<code>connect()</code>函数设定。尽管允许对UDP进行”连接”（在某些情况下这对应用程序的设计非常有帮助）但由于UDP是一个无连接协议，UDP套接字仍然可以不经连接就使用。”未连接”的UDP套接字在数据被第一次发送之前并不会绑定，只有在发送的时候被系统自动绑定，因此未绑定的UDP套接字也就无法收到（回复）数据。未绑定的TCP也一样，它将在连接的时候自动绑定。</p>
<p>如果你明确绑定一个socket，把它绑定到端口0是可行的，它意味着”any port”(“任意端口”)。<strong>由于一个套接字无法真正的被绑定到系统上的所有端口，那么在这种情况下系统将不得不选择一个具体的端口号（指的是”any port”）</strong>。源地址使用类似的通配符，也就是”any address” （IPv4中的0.0.0.0和IPv6中的::）。<strong>和端口不同的是，一个套接字可以被绑定到任意地址(any address)，这里指的是本地网络接口的所有地址</strong>。由于socket无法在连接的时候同时绑定到所有源IP地址，因此当接下来有一个连接过来的时候，系统将不得不挑选一个源IP地址。考虑到目的地址和路由表中的路由信息，系统将会选择一个合适的源地址，并将任意地址替换为一个选定的地址作为源地址。</p>
<p>默认情况下，任意两个socket都无法绑定到相同的源IP地址和源端口(即源地址和源端口号均相同)。只要源端口号不相同，那么源地址实际上没什么关系。将socketA绑定到地址A和端口X （A:X)，socketB绑定到地址B和端口Y (B:Y)，只要<code>X != Y</code>，那么这种绑定都是可行的。然而当<code>X == Y</code>的时候只要<code>A != B</code>，这种绑定方式也仍然可行，比如：一个FTP server的socketA绑定为192.168.0.1:21而属于另一个FTP server的socketB绑定为 10.0.0.1:21，这两个绑定都将成功。记住：<strong>一个socket可能绑定到本地”any address”。例如一个socket绑定为 0.0.0.0:21，那么它同时绑定了所有的本地地址，在这种情况下，不论其它的socket选择什么特定的IP地址，它们都无法绑定到21端口，因为0.0.0.0和所有的本地地址都会冲突。</strong></p>
<p>上面说的对所有主流操作系统都是一样的。当涉及到地址重用的时候，OS之间的差异就显现出来了，正如之前所说的那样，其它的实现方案都来源于BSD的实现，因此我们首先从BSD说起。</p>
<h1 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h1><h2 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h2><p>如果在绑定一个socket之前设置了<code>SO_REUSEADDR</code>，除非两个socket绑定的源地址和端口号都一样，那么这两个绑定都是可行的。也许你会疑惑这跟之前的有什么不一样？<strong>关键是<code>SO_REUSEADDR</code>改变了在处理源地址冲突时对通配地址(“any ip address”)的处理方式</strong>。</p>
<p>当没有设置<code>SO_REUSEADDR</code>的时候，socketA先绑定到0.0.0.0:21，然后socketB绑定到192.168.0.1:21的时候将会失败(<code>EADDRINUSE</code>错误)，因为0.0.0.0意味着”任意本地IP地址”，也就是”所有本地IP地址“，因此包括192.168.0.1在内的所有IP地址都被认为是已经使用了。但是在设置<code>SO_REUSEADDR</code>之后socketB的绑定将会成功，因为0.0.0.0和192.168.0.1事实上不是同一个IP地址，一个是代表所有地址的通配地址，另一个是一个具体的地址。注意上面的表述对于socketA和socketB的绑定顺序是无关的，没有设置<code>SO_REUSEADDR</code>，它们将失败，设置了<code>SO_REUSEADDR</code>，它将成功。</p>
<p>下面给出了一个表格列出了所有的可能组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SO_REUSEADDR       socketA        socketB       Result</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">  ON/OFF       192.168.0.1:21   192.168.0.1:21    Error (EADDRINUSE)</span><br><span class="line">  ON/OFF       192.168.0.1:21      10.0.0.1:21    OK</span><br><span class="line">  ON/OFF          10.0.0.1:21   192.168.0.1:21    OK</span><br><span class="line">   OFF             0.0.0.0:21   192.168.1.0:21    Error (EADDRINUSE)</span><br><span class="line">   OFF         192.168.1.0:21       0.0.0.0:21    Error (EADDRINUSE)</span><br><span class="line">   ON              0.0.0.0:21   192.168.1.0:21    OK</span><br><span class="line">   ON          192.168.1.0:21       0.0.0.0:21    OK</span><br><span class="line">  ON/OFF           0.0.0.0:21       0.0.0.0:21    Error (EADDRINUSE)</span><br></pre></td></tr></table></figure>
<p>上面的表格假定socketA已经成功绑定，然后创建socketB绑定给定地址在是否设置<code>SO_REUSEADDR</code>的情况下的结果。Result代表socketB的绑定行为是否会成功。如果第一列是ON/OFF，那么SO_REUSEADDR的值将是无关紧要的。</p>
<p><strong>现在我们知道<code>SO_REUSEADDR</code>对通配地址有影响，但这不是它唯一影响到的方面。还有一个众所周知的影响同时也是大多数人在服务器程序上使用<code>SO_REUSEADDR</code>的首要原因</strong>。为了了解其它<code>SO_REUSEADDR</code>重要的使用方式，我们需要深入了解TCP协议的工作方式。</p>
<p>一个socket有一个发送缓冲区，当调用<code>send()</code>函数成功后，这并不意味着所有数据都真正被发送出去了，它只意味着数据都被送到了发送缓冲区中。对于UDP socket来说，如果不是立刻发送的话，数据通常也会很快的发送出去，但对于TCP socket，在数据加入到缓冲区和真正被发送出去之间的时延会相当长。这就导致当我们<code>close</code>一个TCP socket的时候，可能在发送缓冲区中保存着等待发送的数据(由于<code>send()</code>成功返回，因此你也许认为数据已经被发送了)。如果TCP的实现是立刻关闭socket，那么所有这些数据都会丢失而你的程序根本不可能知道。TCP被称为可靠协议，像这种丢失数据的方式就不那么可靠了。这也是为什么当我们<code>close</code>一个TCP socket的时候，如果它仍然有数据等待发送，那么该socket会进入TIME_WAIT状态。这种状态将持续到数据被全部发送或者发生超时。</p>
<p>在内核彻底关闭socket之前等待的总时间(不管是否有数据在发送缓冲区中等待发送)叫做Linger Time。Linger Time在大部分系统上都是一个全局性的配置项而且在默认情况下时间相当长(在大部分系统上是两分钟)。当然对于每个socket我们也可以使用socket选项<code>SO_LINGER</code>进行配置，可以将等待时间设置的更长一点儿或更短一点儿甚至禁用它。禁用Linger Time绝对是一个坏主意，虽然优雅的关闭socket是一个稍微复杂的过程并且涉及到来回的发送数据包(以及在数据包丢失后重发它们)，并且这个过程还受到Linger Time的限制。如果禁用Linger Time，socket可能丢失的不仅仅是待发送的数据，而且还会粗暴的关闭socket，在绝大部分情况下，都不应该这样使用。如何优雅的关闭TCP连接的细节不在这里进行讨论，如果你想了解更多，我建议你阅读：<a href="http://www.freesoft.org/CIE/Course/Section4/11.html" target="_blank" rel="noopener">http://www.freesoft.org/CIE/Course/Section4/11.html</a>。而且如果你用<code>SO_LINGER</code>禁用了Linger Time,而你的程序在显式的关闭socket之前就终止的话，BSD(其它的系统也有可能)仍然会等待，而不管已经禁用了它。这种情况的一个例子就是你的程序调用了<code>exit()</code>(在小的服务器程序很常见)或者进程被信号杀死(也有可能是进程访问了非法内存而终止)。这样的话，不管在什么情况下，你都无法对某一个socket禁用linger了。</p>
<p>问题在于，系统是怎样看待<code>TIME_WAIT</code>状态的？如果<code>SO_REUSEADDR</code>还没有设置，一个处在<code>TIME_WAIT</code>的socket仍然被认为绑定在源地址和端口，任何其它的试图在同样的地址和端口上绑定一个socket行为都会失败直到原来的socket真正的关闭了，这通常需要等待Linger Time的时长。所以不要指望在一个socket关闭后立刻将源地址和端口绑定到新的socket上，在绝大部分情况下，这种行为都会失败。然而，在设置了<code>SO_REUSEADDR</code>之后试图这样绑定(绑定相同的地址和端口)仅仅只会被忽略，而且你可以将相同的地址绑定到不同的socket上。<strong>注意当一个socket处于<code>TIME_WAIT</code>状态，而你试图将它绑定到相同的地址和端口，这会导致未预料的结果，因为处于<code>TIME_WAIT</code>状态的socket仍在”工作”，幸运的是这种情况极少发生</strong>。</p>
<p>对于<code>SO_REUSEADDR</code>你需要知道的最后一点是只有在你想绑定的socket开启了地址重用(address reuse)之后上面的才会生效，不过这并不需要检查之前已经绑定或处于<code>TIME_WAIT</code>的socket在它们绑定的时候是否也设置这个选项。也就是说，绑定的成功与否只会检查当前<code>bind</code>的socket是否开启了这个标志，不会查看其它的socket。</p>
<h2 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a>SO_REUSEPORT</h2><p><code>SO_REUSEPORT</code>的含义与绝大部分人对<code>SO_REUSEADDR</code>的理解一样。基本上说来，<code>SO_REUSEPORT</code>允许你将多个socket绑定到相同的地址和端口只要它们在绑定之前都设置了<code>SO_REUSEPORT</code>。如果第一个绑定某个地址和端口的socket没有设置<code>SO_REUSEPORT</code>，那么其他的socket无论有没有设置<code>SO_REUSEPORT</code>都无法绑定到该地址和端口直到第一个socket释放了绑定。</p>
<p><code>SO_REUSEPORT</code>并不表示<code>SO_REUSEADDR</code>。这意味着如果一个socket在绑定时没有设置<code>SO_REUSEPORT</code>，那么同预期的一样，其它的socket对相同地址和端口的绑定会失败，但是如果绑定相同地址和端口的socket正处在<code>TIME_WAIT</code>状态，新的绑定也会失败。当有个socket绑定后处在<code>TIME_WAIT</code>状态(释放时)时，为了使得其它socket绑定相同地址和端口能够成功，需要设置<code>SO_REUSEADDR</code>或者在这两个socket上都设置<code>SO_REUSEPORT</code>。当然，在socket上同时设置<code>SO_REUSEPORT</code>和<code>SO_REUSEADDR</code>也是可行的。</p>
<p>关于<code>SO_REUSEPORT</code>除了它在被添加到系统的时间比<code>SO_REUSEPORT</code>晚就没有其它需要说的了，这也是为什么在有些系统的socket实现上你找不到这个选项，因为这些系统的代码都是在这个选项被添加到BSD之前fork了BSD，这样就不能将两个socket绑定到真正相同的“地址” (address+port)。</p>
<h2 id="Connect-Returning-EADDRINUSE"><a href="#Connect-Returning-EADDRINUSE" class="headerlink" title="Connect() Returning EADDRINUSE?"></a>Connect() Returning EADDRINUSE?</h2><p>绝大部分人都知道<code>bind()</code>可能失败返回<code>EADDRINUSE</code>，然而当你开始使用地址重用(address reuse)，你可能会碰到奇怪的情况:<code>connect()</code> 失败返回同样的错误<code>EADDRINUSE</code>。怎么会出现这种情况了? 一个远端地址(remote address)毕竟是<code>connect</code>添加到socket上的，怎么会已经被使用了? 将多个socket连接到相同的远端地址从来没有出现过这样的情况，这是为什么了？</p>
<p>正如我在开头说过的，一个连接是被一个五元组定义的。同样我也说了任意两个连接的五元组不能完全一样，因为这样的话内核就没办法区分这两个连接了。然而，在地址重用的情况下，你可以把同协议的两个socket绑定到完全相同的源地址和源端口，这意味着五元组中已经有三个元素相同了(协议，源地址，源端口)。如果你尝试将这些socket连接到同样的目的地址和目的端口，你就创建了两个完全相同的连接。这是不行的，至少对TCP不行(UDP实际上没有真实的连接)。如果数据到达这两个连接中的任何一个，那么系统将无法区分数据到底属于谁。因此当源地址和源端口相同时，目的地址或者目的端口必须不同，否则内核无法进行区分，这种情况下，<code>connect()</code>将在第二个socket尝试连接时返回<code>EADDRINUSE</code>。</p>
<h2 id="Multicast-Address-多播地址"><a href="#Multicast-Address-多播地址" class="headerlink" title="Multicast Address(多播地址)"></a>Multicast Address(多播地址)</h2><p>大部分人都会忽略多播地址的存在，但它们的确存在。单播地址(unicast address)用于单对单通信，多播地址用于单对多通信。大部分人在他们学习了IPv6后才注意到多播地址的存在，但在IPv4中多播地址就有了，尽管它们在公共互联网上用的并不多。</p>
<p>对多播地址来说，<code>SO_REUSEADDR</code>的含义发生了改变，因为它允许多个socket绑定到完全一样的多播地址和端口，也就是说，对多播地址<code>SO_REUSEADDR</code>的行为与<code>SO_REUSEPORT</code>对单播地址完全一样。事实上，对于多播地址，对<code>SO_REUSEADDR</code>和<code>SO_REUSEPORT</code>的处理完全一样，对所有多播地址，<code>SO_REUSEADDR</code>也就意味着<code>SO_REUSEPORT</code>。</p>
<h1 id="FreeBSD-OpenBSD-NetBSD"><a href="#FreeBSD-OpenBSD-NetBSD" class="headerlink" title="FreeBSD/OpenBSD/NetBSD"></a>FreeBSD/OpenBSD/NetBSD</h1><p>它们都是很晚的时候衍生自原生BSD的系统，它们与原生BSD的选项和行为都一样。</p>
<h1 id="MacOS-X"><a href="#MacOS-X" class="headerlink" title="MacOS X"></a>MacOS X</h1><p>MacOS X的内核就是一个BSD类型的UNIX，基于很新的BSD代码，甚至Mac OS 10.3的发布与FreeBSD 5都是同步的，因此MacOS与BSD一样提供相同的选项，处理行为也一样。</p>
<h1 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h1><p>IOS只是在内核上稍微修改了MacOS，因此选项和处理行为也和MacOS一样。</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>在linux 3.9之前，只存在选项<code>SO_REUSEADDR</code>。除了两个重要的差别，大体上与BSD一样。第一个差别：当一个监听(listening)TCP socket绑定到通配地址和一个特定的端口，无论其它的socket或者是所有的socket(包括监听socket)都设置了<code>SO_REUSEADDR</code>，其它的TCP socket都无法绑定到相同的端口(BSD中可以)，就更不用说使用一个特定地址了。这个限制并不用在非监听TCP socket上，当一个监听socket绑定到一个特定的地址和端口组合，然后另一个socket绑定到通配地址和相同的端口，这样是可行的。第二个差别: 当把<code>SO_REUSEADDR</code>用在UDP socket上时，它的行为与BSD上<code>SO_REUSEPORT</code>完全相同，因此两个UDP socket只要都设置了<code>SO_REUSEADDR</code>，那么它们可以绑定到相同的地址和端口。</p>
<p>Linux 3.9加入了<code>SO_REUSEPORT</code>。这个选项允许多个socket(TCP or UDP)不管是监听socket还是非监听socket只要都在绑定之前都设置了它，那么就可以绑定到完全相同的地址和端口。为了阻止”port 劫持”(Port hijacking)有一个特别的限制：所有希望共享源地址和端口的socket都必须拥有相同的有效用户id(effective user ID)。因此一个用户就不能从另一个用户那里”偷取”端口。另外，内核在处理<code>SO_REUSEPORT</code> socket的时候使用了其它系统上没有用到的”特别魔法”：对于UDP socket，内核尝试平均的转发数据报，对于TCP监听socket，内核尝试将新的客户连接请求(由<code>accept</code>返回)平均的交给共享同一地址和端口的socket(监听socket)。这意味着在其他系统上socket收到一个数据报或连接请求或多或少是随机的，但是linux尝试优化分配。例如：一个简单的服务器程序的多个实例可以使用<code>SO_REUSEPORT</code> socket实现一个简单的负载均衡，因为内核已经把复制的分配都做了。</p>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>尽管整个Android系统与大多数linux发行版都不一样，但是它的内核是个稍加修改的linux内核，因此它的<code>SO_REUSEADDR</code>和<code>SO_REUSEPORT</code>与linux一样。</p>
<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>windows上只有<code>SO_REUSEADDR</code>选项，没有<code>SO_REUSEPORT</code>。在windows上设置了<code>SO_REUSEADD</code>R的socket其行为与BSD上设定了<code>SO_REUSEPORT</code>和<code>SO_REUSEADDR</code>的行为大致一样，只有一个差别：一个设置了<code>SO_REUSEADDR</code>的socket总是可以绑定到已经被绑定过的源地址和源端口，不管之前在这个地址和端口上绑定的socket是否设置了<code>SO_REUSEADDR</code>没有。这种行为在某种程度上有些危险因为它允许一个应用程序从别的应用程序上”偷取”已连接的端口。不用说，这对安全性有极大的影响，Microsoft意识到了这个问题，就加入了另一个socket选项: <code>SO_EXECLUSIVEADDRUSE</code>。设置了<code>SO_EXECLUSIVEADDRUSE</code>的socket确保一旦绑定成功，那么被绑定的源端口和地址就只属于这一个socket，其它的socket不能绑定，甚至他们使用了<code>SO_REUSEADDR</code>也没用。</p>
<h1 id="Solaris"><a href="#Solaris" class="headerlink" title="Solaris"></a>Solaris</h1><p>Solaris是SunOS的后羿，SunOS起源于BSD，SunOS 5和之后的版本则基于SVR4，然而SVR4是BSD，System V和Xenix的集合体，所以从某种程度上说，Solaris也是BSD的分支，而且是相当早的一个分支。这就导致了Solaris只有<code>SO_REUSEADDR</code>而没有<code>SO_REUSEPORT</code>。Solaris上SO_REUSEADDR的行为与BSD的非常相似。从我知道的来看，在Solaris上没办法实现<code>SO_REUSEPORT</code>的行为，也就是说，想把两个socket绑定到相同的源地址和端口上是不可能的。</p>
<p>与Windows类似，Solaris也有一个选项提供互斥绑定，这个选项叫<code>SO_EXCLBIND</code>。如果在一个socket在绑定之前设置这个选项，那么在其他的socket上设置<code>SO_REUSEADDR</code>将没有任何影响。比如socketA绑定了一个通配地址，socketB设置了<code>SO_REUSEADDR</code>并且绑定到一个非通配地址和相同的端口，那么这个绑定将成功，除非socketA设置了<code>SO_EXCLBIND</code>，在这种情况下，socketB的绑定将失败不管它是否设定了<code>SO_REUSEADDR</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/06/02/关于CPU-Cache-程序猿需要知道的那些事/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/02/关于CPU-Cache-程序猿需要知道的那些事/" itemprop="url">关于CPU Cache -- 程序猿需要知道的那些事</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-02T20:02:22+08:00">
                2017-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/06/02/关于CPU-Cache-程序猿需要知道的那些事/" class="leancloud_visitors" data-flag-title="关于CPU Cache -- 程序猿需要知道的那些事">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部 作者：卢钧轶(cenalulu) 本文原文地址：<a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">http://cenalulu.github.io/linux/all-about-cpu-cache/</a></p>
</blockquote>
<p>写在开头：<strong>本文系转载，所以以原有博文为主，以斜体注：开头表示添加内容</strong>。</p>
<p>先来看一张本文所有概念的一个思维导图</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/6/mind_map.png" alt="mind map"></p>
<h1 id="为什么要有CPU-Cache"><a href="#为什么要有CPU-Cache" class="headerlink" title="为什么要有CPU Cache"></a>为什么要有CPU Cache</h1><p>随着工艺的提升最近几十年CPU的频率不断提升，而受制于制造工艺和成本限制，目前计算机的内存主要是DRAM并且在访问速度上没有质的突破。因此，CPU的处理速度和内存的访问速度差距越来越大，甚至可以达到上万倍。这种情况下传统的CPU通过FSB直连内存的方式显然就会因为内存访问的等待，导致计算资源大量闲置，降低CPU整体吞吐量。同时又由于内存数据访问的热点集中性，在CPU和内存之间用较为快速而成本较高的SDRAM做一层缓存，就显得性价比极高了。</p>
<h1 id="为什么要有多级CPU-Cache"><a href="#为什么要有多级CPU-Cache" class="headerlink" title="为什么要有多级CPU Cache"></a>为什么要有多级CPU Cache</h1><p>随着科技发展，热点数据的体积越来越大，单纯的增加一级缓存大小的性价比已经很低了。因此，就慢慢出现了在一级缓存(L1 Cache)和内存之间又增加一层访问速度和成本都介于两者之间的二级缓存(L2 Cache)。下面是一段从 <a href="http://cenalulu.github.io/linux/all-about-cpu-cache/(www.akkadia.org/drepper/cpumemory.pdf" target="_blank" rel="noopener">What Every Programmer Should Know About Memory</a>) 中摘录的解释：</p>
<blockquote>
<p>Soon after the introduction of the cache the system got more complicated. The speed difference between the cache and the main memory increased again, to a point that another level of cache was added, bigger and slower than the first-level cache. Only increasing the size of the first-level cache was not an option for economical rea- sons.</p>
</blockquote>
<p>此外，又由于程序指令和程序数据的行为和热点分布差异很大，因此L1 Cache也被划分成L1i (i for instruction)和L1d (d for data)两种专门用途的缓存。 下面一张图可以看出各级缓存之间的响应时间差距，以及内存到底有多慢！</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/6/latency.png" alt="latency"></p>
<h1 id="什么是Cache-Line"><a href="#什么是Cache-Line" class="headerlink" title="什么是Cache Line"></a>什么是Cache Line</h1><p>Cache Line可以简单的理解为CPU Cache中的最小缓存单位。目前主流的CPU Cache的Cache Line大小都是64Bytes。假设我们有一个512字节的一级缓存，那么按照64B的缓存单位大小来算，这个一级缓存所能存放的缓存个数就是 <code>512/64 = 8</code> 个。具体参见下图：</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/6/cache_line.png" alt="cache line"></p>
<p>为了更好的了解Cache Line，我们还可以在自己的电脑上做下面这个有趣的实验。</p>
<p>下面这段C代码，会从命令行接收一个参数作为数组的大小创建一个数量为N的int数组。并依次循环的从这个数组中进行数组内容访问，循环10亿次。最终输出数组总大小和对应总执行时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">long timediff(clock_t t1, clock_t t2) &#123;</span><br><span class="line">    long elapsed;</span><br><span class="line">    elapsed = ((double)t2 - t1) / CLOCKS_PER_SEC * 1000;</span><br><span class="line">    return elapsed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int array_size=atoi(argv[1]);</span><br><span class="line">    int repeat_times = 1000000000;</span><br><span class="line">    long array[array_size];</span><br><span class="line">    for(int i=0; i&lt;array_size; i++)&#123;</span><br><span class="line">        array[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int j=0;</span><br><span class="line">    int k=0;</span><br><span class="line">    int c=0;</span><br><span class="line">    clock_t start=clock();</span><br><span class="line">    while(j++&lt;repeat_times)&#123;</span><br><span class="line">        if(k==array_size)&#123;</span><br><span class="line">            k=0;</span><br><span class="line">        &#125;</span><br><span class="line">        c = array[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end =clock();</span><br><span class="line">    printf(&quot;%lu\n&quot;, timediff(start,end));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们把这些数据做成折线图后就会发现：总执行时间在数组大小超过64Bytes时有较为明显的拐点（当然，由于博主是在自己的Mac笔记本上测试的，会受到很多其他程序的干扰，因此会有波动）。原因是当数组小于64Bytes时数组极有可能落在一条Cache Line内，而一个元素的访问就会使得整条Cache Line被填充，因而值得后面的若干个元素受益于缓存带来的加速。而当数组大于64Bytes时，必然至少需要两条Cache Line，继而在循环访问时会出现两次Cache Line的填充，由于缓存填充的时间远高于数据访问的响应时间，因此多一次缓存填充对于总执行的影响会被放大，最终得到下图的结果：</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/6/cache_line_size2.png" alt="cache_line_size2"></p>
<p>如果读者有兴趣的话也可以在自己的linux或者MAC上通过 <code>gcc cache_line_size.c -o cache_line_size</code> 编译，并通过 <code>./cache_line_size</code> 执行。</p>
<p>了解Cache Line的概念对我们程序猿有什么帮助？ 我们来看下面这个C语言中常用的循环优化例子 下面两段代码中，第一段代码在C语言中总是比第二段代码的执行速度要快。具体的原因相信你仔细阅读了Cache Line的介绍后就很容易理解了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    for(int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        int num;    </span><br><span class="line">        //code</span><br><span class="line">        arr[i][j] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    for(int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        int num;    </span><br><span class="line">        //code</span><br><span class="line">        arr[j][i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CPU-Cache-是如何存放数据的"><a href="#CPU-Cache-是如何存放数据的" class="headerlink" title="CPU Cache 是如何存放数据的"></a>CPU Cache 是如何存放数据的</h1><h2 id="你会怎么设计Cache的存放规则"><a href="#你会怎么设计Cache的存放规则" class="headerlink" title="你会怎么设计Cache的存放规则"></a>你会怎么设计Cache的存放规则</h2><p>我们先来尝试回答一下那么这个问题：</p>
<blockquote>
<p>假设我们有一块4MB的区域用于缓存，每个缓存对象的唯一标识是它所在的物理内存地址。每个缓存对象大小是64Bytes，所有可以被缓存对象的大小总和（即物理内存总大小）为4GB。那么我们该如何设计这个缓存？</p>
</blockquote>
<p>如果你和博主<em>(注：原文博主)</em>一样是一个大学没有好好学习基础/数字电路的人的话，会觉得最靠谱的的一种方式就是：Hash表。把Cache设计成一个Hash数组。内存地址的Hash值作为数组的Index，缓存对象的值作为数组的Value。每次存取时，都把地址做一次Hash然后找到Cache中对应的位置操作即可。 这样的设计方式在高等语言中很常见，也显然很高效。因为Hash值得计算虽然耗时(10000个CPU Cycle左右)，但是相比程序中其他操作（上百万的CPU Cycle）来说可以忽略不计。而对于CPU Cache来说，本来其设计目标就是在几十CPU Cycle内获取到数据。如果访问效率是百万Cycle这个等级的话，还不如到Memory直接获取数据。当然，更重要的原因是在硬件上要实现Memory Address Hash的功能在成本上是非常高的。</p>
<h2 id="为什么Cache不能做成Fully-Associative"><a href="#为什么Cache不能做成Fully-Associative" class="headerlink" title="为什么Cache不能做成Fully Associative"></a>为什么Cache不能做成Fully Associative</h2><p>Fully Associative 字面意思是全关联。在CPU Cache中的含义是：如果在一个Cache集内，任何一个内存地址的数据可以被缓存在任何一个Cache Line里，那么我们成这个cache是Fully Associative。从定义中我们可以得出这样的结论：给到一个内存地址，要知道他是否存在于Cache中，需要遍历所有Cache Line并比较缓存内容的内存地址。而Cache的本意就是为了在尽可能少得CPU Cycle内取到数据。那么想要设计一个快速的Fully Associative的Cache几乎是不可能的。</p>
<h2 id="为什么Cache不能做成Direct-Mapped"><a href="#为什么Cache不能做成Direct-Mapped" class="headerlink" title="为什么Cache不能做成Direct Mapped"></a>为什么Cache不能做成Direct Mapped</h2><p>和Fully Associative完全相反，使用Direct Mapped模式的Cache给定一个内存地址，就唯一确定了一条Cache Line。设计复杂度低且速度快。那么为什么Cache不使用这种模式呢？让我们来想象这么一种情况：一个拥有1M L2 Cache的32位CPU，每条Cache Line的大小为64Bytes。那么整个L2Cache被划为了 <code>1M/64=16384</code> 条Cache Line。我们为每条Cache Line从0开始编上号。同时32位CPU所能管理的内存地址范围是 <code>2^32=4G</code>，那么Direct Mapped模式下，内存也被划为 <code>4G/16384=256K</code> 的小份。也就是说每256K的内存地址共享一条Cache Line。但是，这种模式下每条Cache Line的使用率如果要做到接近100%，就需要操作系统对于内存的分配和访问在地址上也是近乎平均的。而与我们的意愿相反，为了减少内存碎片和实现便捷，操作系统更多的是连续集中的使用内存。这样会出现的情况就是0-1000号这样的低编号Cache Line由于内存经常被分配并使用，而16000号以上的Cache Line由于内存鲜有进程访问，几乎一直处于空闲状态。这种情况下，本来就宝贵的1M二级CPU缓存，使用率也许50%都无法达到。</p>
<h2 id="什么是N-Way-Set-Associative"><a href="#什么是N-Way-Set-Associative" class="headerlink" title="什么是N-Way Set Associative"></a>什么是N-Way Set Associative</h2><p>为了避免以上两种设计模式的缺陷，N-Way Set Associative <em>(注：也称为 N-Way M-Set Associative)</em>缓存就出现了。他的原理是把一个缓存按照N个Cache Line作为一组（set），缓存按组划为等分。</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/6/set.jpg" alt="set"></p>
<p><em>cache 由 set 组成， set 由 line 组成， line 由 vaild bit,tag,data组成。其中data是真正要缓存的内存地址中的数据，而tag则是用来搜索cache line的标签。</em></p>
<p>这样一个64位系统的内存地址在4MB二级缓存中就划成了三个部分（见下图），低位6个bit表示在Cache Line中的偏移量，中间12bit表示Cache组号（set index），剩余的高位46bit就是内存地址的唯一id。这样的设计相较前两种设计有以下两点好处：<em>(注：此处原博主假设为16-Way组相连)</em></p>
<ul>
<li>给定一个内存地址可以唯一对应一个set，对于set中只需遍历16个元素就可以确定对象是否在缓存中（Full Associative中比较次数随内存大小线性增加）</li>
<li>每 <code>2^18(256K)*16(way)=4M</code> 的连续热点数据才会导致一个set内的conflict（Direct Mapped中512K的连续热点数据就会出现conflict）</li>
</ul>
<p><img src="http://www.hashcoding.net/uploads/images/2017/6/addr_bits.png" alt="addr_bits"></p>
<p><em>注：此处相当于 16-Way 64K-set Associative</em></p>
<h3 id="为什么N-Way-Set-Associative的Set段是从低位而不是高位开始的"><a href="#为什么N-Way-Set-Associative的Set段是从低位而不是高位开始的" class="headerlink" title="为什么N-Way Set Associative的Set段是从低位而不是高位开始的"></a>为什么N-Way Set Associative的Set段是从低位而不是高位开始的</h3><p>下面是一段从<a href="http://danluu.com/3c-conflict/#fn3" target="_blank" rel="noopener">How Misaligning Data Can Increase Performance 12x by Reducing Cache Misses</a>摘录的解释：</p>
<blockquote>
<p>The vast majority of accesses are close together, so moving the set index bits upwards would cause more conflict misses. You might be able to get away with a hash function that isn’t simply the least significant bits, but most proposed schemes hurt about as much as they help while adding extra complexity.</p>
</blockquote>
<p>由于内存的访问通常是大片连续的，或者是因为在同一程序中而导致地址接近的（即这些内存地址的高位都是一样的）。所以如果把内存地址的高位作为set index的话，那么短时间的大量内存访问都会因为set index相同而落在同一个set index中，从而导致cache conflicts使得L2, L3 Cache的命中率低下，影响程序的整体执行效率。</p>
<h3 id="了解N-Way-Set-Associative的存储模式对我们有什么帮助"><a href="#了解N-Way-Set-Associative的存储模式对我们有什么帮助" class="headerlink" title="了解N-Way Set Associative的存储模式对我们有什么帮助"></a>了解N-Way Set Associative的存储模式对我们有什么帮助</h3><p>了解N-Way Set的概念后，我们不难得出以下结论：<code>2^(6Bits &lt;Cache Line Offset&gt; + 12Bits &lt;Set Index&gt;) = 2^18 = 256K</code>。即在连续的内存地址中每256K都会出现一个处于同一个Cache Set中的缓存对象。也就是说这些对象都会争抢一个仅有16个空位的缓存池（16-Way Set）。而如果我们在程序中又使用了所谓优化神器的“内存对齐”的时候，这种争抢就会越发增多。效率上的损失也会变得非常明显。具体的实际测试我们可以参考：<a href="http://danluu.com/3c-conflict/#fn3" target="_blank" rel="noopener">How Misaligning Data Can Increase Performance 12x by Reducing Cache Misses</a> 一文。 这里我们引用一张<a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">Gallery of Processor Cache Effects</a> 中的测试结果图，来解释下内存对齐在极端情况下带来的性能损失。</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/6/assoc_big1.png" alt="assoc_big1"></p>
<p>该图实际上是我们上文中第一个测试的一个变种。纵轴表示了测试对象数组的大小。横轴表示了每次数组元素访问之间的index间隔。而图中的颜色表示了响应时间的长短，蓝色越明显的部分表示响应时间越长。从这个图我们可以得到很多结论。当然这里我们只对内存带来的性能损失感兴趣。有兴趣的读者也可以阅读<a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">原文</a>分析理解其他从图中可以得到的结论。</p>
<p>从图中我们不难看出图中每1024个步进，即每<code>1024*4</code>即4096Bytes，都有一条特别明显的蓝色竖线。也就是说，只要我们按照4K的步进去访问内存(内存根据4K对齐），无论热点数据多大它的实际效率都是非常低的！按照我们上文的分析，如果4KB的内存对齐，那么一个240MB的数组就含有61440个可以被访问到的数组元素；而对于一个每256K就会有set冲突的16Way二级缓存，总共有<code>256K/4K=64</code>个元素要去<em>(注：从整个缓存中)</em>争抢16个空位，总共有<code>61440/64=960</code>个这样的元素。那么缓存命中率只有1%，自然效率也就低了。</p>
<p>除了这个例子，有兴趣的读者还可以查阅另一篇国人对Page Align导致效率低的实验：<a href="http://evol128.is-programmer.com/posts/35453.html" target="_blank" rel="noopener">http://evol128.is-programmer.com/posts/35453.html</a></p>
<p>想要知道更多关于内存地址对齐在目前的这种CPU-Cache的架构下会出现的问题可以详细阅读以下两篇文章：</p>
<ul>
<li><a href="http://danluu.com/3c-conflict/" target="_blank" rel="noopener">How Misaligning Data Can Increase Performance 12x by Reducing Cache Misses</a></li>
<li><a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">Gallery of Processor Cache Effects</a></li>
</ul>
<h1 id="Cache淘汰策略"><a href="#Cache淘汰策略" class="headerlink" title="Cache淘汰策略"></a>Cache淘汰策略</h1><p>在文章的最后我们顺带提一下CPU Cache的淘汰策略。常见的淘汰策略主要有LRU和Random两种。通常意义下LRU对于Cache的命中率会比Random更好，所以CPU Cache的淘汰策略选择的是LRU。当然也有些实验显示<a href="http://danluu.com/2choices-eviction/" target="_blank" rel="noopener">在Cache Size较大的时候Random策略会有更高的命中率</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CPU Cache对于程序猿是透明的，所有的操作和策略都在CPU内部完成。但是，了解和理解CPU Cache的设计、工作原理有利于我们更好的利用CPU Cache，写出更多对CPU Cache友好的程序</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">Gallery of Processor Cache Effects</a><br><a href="http://danluu.com/3c-conflict/" target="_blank" rel="noopener">How Misaligning Data Can Increase Performance 12x by Reducing Cache Misses</a><br><a href="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Memory/introCache.html" target="_blank" rel="noopener">Introduction to Caches</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/05/26/Linux-TCP-编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/Linux-TCP-编程/" itemprop="url">Linux TCP 编程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T18:28:19+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/05/26/Linux-TCP-编程/" class="leancloud_visitors" data-flag-title="Linux TCP 编程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TCP(Transmission Control Protocol) 是由 IETF 的 RFC 793 定义的一种<strong>面向连接的、可靠的、基于字节流的</strong>传输层通信协议。</p>
<h1 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h1><p>TCP 数据被封装在一个 IP 数据报中，如下图所示：</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/5/TCP%E5%9C%A8IP%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85.png" alt="TCP数据在IP数据报中的封装"></p>
<p>下图是 TCP 首部的数据格式，如果不计任选字段，它通常是20个字节：</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/5/TCP包首部.png" alt="TCP包首部"></p>
<p>下面介绍重要的几个数据：</p>
<ul>
<li>32位序号：表示数据当前发送的第一个字节在字节流中的序号</li>
<li>32位确认号：表示发送端所期望收到的下一个序号，因此该序号位上一次收到的序号加一</li>
<li>6个特殊标志bit: (按照排列顺序)<ul>
<li>URG: 紧急指针有效</li>
<li>ACK：确认序号有效</li>
<li>PSH：接收方应该尽快将这个报文段交给应用层</li>
<li>RST：重建连接</li>
<li>SYN：同步序号，用来发起一个连接</li>
<li>FIN：发送端完成任务，关闭发送端到接收端连接</li>
</ul>
</li>
</ul>
<p>其余的解释请参考 TCP/IP 协议详解。</p>
<h1 id="TCP-连接的状态图"><a href="#TCP-连接的状态图" class="headerlink" title="TCP 连接的状态图"></a>TCP 连接的状态图</h1><p><img src="http://www.hashcoding.net/uploads/images/2017/5/TCP状态转换.png" alt="TCP状态图"></p>
<h1 id="TCP-连接的建立与终止"><a href="#TCP-连接的建立与终止" class="headerlink" title="TCP 连接的建立与终止"></a>TCP 连接的建立与终止</h1><p>TCP 是一个<strong>面向连接的</strong>通信协议，这要求通信双方在进行通信之前，需要先建立其连接。在常见的客户端、服务器模式的程序中，通常是服务器绑定端口，并在该端口上监听客户端连接请求；客户端主动向服务器发起连接请求，待服务器响应后，双方建立起一条通信链路。</p>
<h2 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h2><p>TCP 连接建立时通信双方的分组报文如下图所示：</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/5/TCP三路握手.png" alt="TCP 三路握手"></p>
<p>如图所示，客户端发起 <code>connect</code>，此时客户端发送 <code>SYN</code> 报文；服务端使用 <code>accept</code> 接受该连接请求，同时反馈 <code>SYN</code> 和 <code>ACK</code>；等到客户端相应了 <code>ACK</code>后，双方建立起完整连接。</p>
<p>将上述过程映射到 TCP 状态图上进行观察，在服务器端：</p>
<ul>
<li>刚开始服务器处于 <code>CLOSED</code> 状态</li>
<li>服务器初始化时绑定了具体的端口，并使用 <code>listen</code> 监听该端口，进入了 <code>LISTEN</code> 状态</li>
<li>服务端接收到了来自客户端的 <code>SYN</code> 请求，发送 <code>SYN</code> 和 <code>ACK</code> 给客户端，然后进入 <code>SYN_RCVD</code> 状态</li>
<li>当服务端接收到了客户端紧接着到达的 <code>ACK</code> 时，进入 <code>ESTABLISHED</code> 状态</li>
</ul>
<p>客户端方面：</p>
<ul>
<li>刚开始同样处于 <code>CLOSED</code> 状态</li>
<li>应用主动调用 <code>CONNECT</code> 发起连接，发送 <code>SYN</code> 给服务器，然后进入 <code>SYN_SEND</code> 状态</li>
<li>当接受到服务器的 <code>SYN</code> 和 <code>ACK</code> 后，发送对应的 <code>ACK</code> 给服务器，并进入 <code>ESTABLISHED</code> 状态</li>
</ul>
<p>当双方都进入 <code>ESTABLISHED</code> 状态时，表示连接已经建立成功。</p>
<p>当然，客户端在发送了 <code>SYN</code> 后，等待超时，并重试几次后，便会触发 <code>Timeout</code> 进入 <code>CLOSED</code>，在应用层则表示为 <code>connect</code> 失败。</p>
<h2 id="同时建立连接"><a href="#同时建立连接" class="headerlink" title="同时建立连接"></a>同时建立连接</h2><p>与常见的模式不同的是，TCP 允许连接双方同时发起建立连接的请求。此时分组报文如下图所示：</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/5/TCP同时建立连接.png" alt="TCP同时建立连接"></p>
<p>连接双方同时发送 <code>SYN</code> 到对方，然后同样地返回 <code>SYN</code> 和 <code>ACK</code> 给对方。将该过程对应到状态图中：</p>
<ul>
<li>刚开始同样处于 <code>CLOSED</code> 状态</li>
<li>应用主动调用 <code>CONNECT</code> 发起连接，发送 <code>SYN</code> 给服务器，然后进入 <code>SYN_SEND</code> 状态</li>
<li>接收到 <code>SYN</code> 后进入 <code>SYN-RCVD</code> 状态</li>
<li>接收到 <code>ACK</code> 后建立连接，进入 <code>ESTABLISHED</code> 状态</li>
</ul>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p><code>FIN</code> 用于通知对方关闭本方向的连接。由于 TCP 是一个<strong>全双工的</strong>通信协议，像管道一样，支持关闭某一方向上的连接，所以在 TCP 中关闭连接需要双方都发送 <code>FIN</code> 报文。此时分组报文如下图所示：</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/5/TCP关闭时的分组交换.png" alt="TCP关闭时的分组交换"></p>
<p>当某一方关闭连接时，发送 <code>FIN</code> 给另一方，对方回复 <code>ACK</code> 后，同时也发送 <code>FIN</code>；等到双方都收到最后的 <code>ACK</code> 后，连接关闭。当然，<strong>如果另一方只回复了 <code>ACK</code> 而没有发起 <code>FIN</code>，则表示对方仍然想要发送数据，这种情况称为 TCP 的半关闭</strong>。只有当双方都发送了 <code>FIN</code> 并接收到对方的 <code>ACK</code> 后，才算真正的连接关闭。所以上图中 Server 端的 <code>FIN</code> 包可以在接收到 Client 的 <code>FIN</code> 包后，隔一段时间再发送。</p>
<p>在状态图中对应了主动关闭和被动关闭，首先观察主动关闭：</p>
<ul>
<li>当应用使用 <code>close</code> 后，发送 <code>FIN</code> 给对方，并由 <code>ESTABLISHED</code> 状态进入 <code>FIN_WAIT_1</code> 状态</li>
<li>如果收到 <code>ACK</code> 后，进入 <code>FIN_WAIT_2</code> 状态</li>
<li>此时等待对方的 <code>FIN</code> 到达，并发送 <code>ACK</code> 给对方，进入 <code>TIME_WAIT</code> 状态</li>
<li>如果在 <code>FIN_WAIT_1</code> 状态直接接收到 <code>FIN</code> 和 <code>ACK</code>，则直接进入 <code>TIME_WAIT</code> 状态</li>
<li><code>TIME_WAIT</code> 状态等待了 2 MSL 后，进入 <code>CLOSED</code> 状态，此时连接关闭</li>
</ul>
<p>被动关闭则简单得多：</p>
<ul>
<li>当收到对方的 <code>FIN</code> 后，发送 <code>ACK</code> 并由 <code>ESTABLISHED</code> 进入 <code>CLOSE_WAIT</code> 状态</li>
<li>等到用户层发出 <code>close</code> 后，发送 <code>FIN</code> 同时进入 <code>LAST_ACK</code> 状态</li>
<li>等到接收到对方的 <code>ACK</code> 后，进入 <code>CLOSED</code> 状态，连接关闭</li>
</ul>
<p><code>TIME_WAIT</code> 状态可能时状态图中最不易懂的地方，它也被称为 <code>2 MSL</code> 状态。每一个具体 TCP 实现必须选择一个报文段最大生存时间 MSL(Maximum Segment Lifetime)，表示任何报文段被丢弃前能在网络中存活的时间。当 TCP 执行主动关闭并发送了 <code>ACK</code> 给对方进入 <code>TIME_WAIT</code> 状态后，该连接必须在 <code>TIME_WAIT</code> 状态停留 2 倍的 MSL 。这样可以保证 TCP 在超时后再次发送最后的 <code>ACK</code> 以防止这个 <code>ACK</code> 丢失。使用 2 MSL 的另外一点是，当前的 <code>socket</code> 关闭后，可能立即被用于建立另一个 TCP 连接，而网络中可能存在着尚未到达具有 <code>TIME_WAIT</code> 状态一方的包，需要保证这些包不会影响到接下来即将建立的连接。2 MSL 的时间间隔中不允许 <code>socket</code> 被重新使用，同时也能够保证消耗掉网络中的包。所以 <code>TIME_WAIT</code> 状态存在有两个理由：</p>
<ul>
<li>可靠地实现 TCP 全双工连接的终止</li>
<li>允许老的重复的包在网络中消逝</li>
</ul>
<blockquote>
<p>关于保证 TCP 超时后再次发送最后的 <code>ACK</code> 进行补充：<a href="https://www.zhihu.com/question/27564314/answer/162476313#" target="_blank" rel="noopener">在tcp协议中处于last_ack状态的连接，如果一直收不到对方的ack，会一直处于这个状态吗？- 知乎</a></p>
</blockquote>
<h2 id="同时关闭"><a href="#同时关闭" class="headerlink" title="同时关闭"></a>同时关闭</h2><p>如 TCP 同时打开一样，TCP 也存在同时关闭状态，此时双方均进入 <code>FIN_WAIT_1</code> 状态，并再接收到 <code>FIN</code> 后进入 <code>CLOSING</code> 状态。等到接收到 <code>ACK</code> 后，则进入 <code>TIME_WAIT</code> 状态。</p>
<h2 id="TCP-复位"><a href="#TCP-复位" class="headerlink" title="TCP 复位"></a>TCP 复位</h2><p>在 TCP 首部中 <code>RST</code> 位表示表示复位，用来异常的关闭连接，在 TCP 的设计中它是不可或缺的。发送 <code>RST</code> 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 <code>RST</code> 包。而接收端收到 <code>RST</code> 包后，也不必发送 <code>ACK</code> 包来确认。TCP 处理程序会在自己认为的异常时刻发送 <code>RST</code> 包。 </p>
<p>下面来分析一下 TCP 中 <code>RST</code> 包出现的主要场景。</p>
<h3 id="到不存在的端口的连接请求"><a href="#到不存在的端口的连接请求" class="headerlink" title="到不存在的端口的连接请求"></a>到不存在的端口的连接请求</h3><p>产生复位的一种常见情况是当连接请求到达时，目的端口没有进程在监听。例如，A 向 B 发起连接，但 B 之上并未监听相应的端口，这时 B 操作系统上的 TCP 处理程序会发 <code>RST</code> 包。</p>
<h3 id="异常终止一个连接"><a href="#异常终止一个连接" class="headerlink" title="异常终止一个连接"></a>异常终止一个连接</h3><p>终止一个连接的正常方式是一方发送 <code>FIN</code>，这也成为有序释放，因为在所有排队数据都已经发送之后才发送 <code>FIN</code> ，正常情况下没有数据丢失。但是也可以使用 <code>RST</code> 来直接释放一个连接，这种方式称为异常释放。使用异常终止有两个有点：</p>
<ul>
<li>丢弃任何待发送数据并立即发送复位报文段</li>
<li><code>RST</code> 的接收方会区分另一端是异常还是正常关闭</li>
</ul>
<h3 id="检测半打开连接"><a href="#检测半打开连接" class="headerlink" title="检测半打开连接"></a>检测半打开连接</h3><p>如果一方已经关闭或异常终止而另一方还不知道，这样的 TCP 连接被称为<strong>半打开</strong>的。比如系统断电而不是正常结束就可能造成半打开的连接。如果发生异常的一方重启后重新连接到远程服务，则会发生错误，此时远程服务器会发送 <code>RST</code> 关闭此连接。比如，AB 正常建立连接了，正在通讯时，A 向 B 发送了 <code>FIN</code> 包要求关连接，B 发送 <code>ACK</code> 后，网断了，A 通过若干原因放弃了这个连接（例如进程重启）。网通了后，B 又开始发数据包，A 收到后表示压力很大，不知道这野连接哪来的，就发了个 <code>RST</code> 包强制把连接关了，B 收到后会出现 <code>connect reset by peer</code> 错误。</p>
<h1 id="Socket-TCP-编程"><a href="#Socket-TCP-编程" class="headerlink" title="Socket TCP 编程"></a>Socket TCP 编程</h1><p>Socket 中文称为套接字，用于应用程序发出或相应网络请求。POSIX 提供了一套 Socket 编程标准 API，在进一步之前，先看看 Socket TCP 编程流程：</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/5/TCP流程.png" alt="TCP Socket 编程流程"></p>
<p>简单的 Socket 编程流程如上图所示，创建了 <code>socket</code> 后的客户端通过 <code>connect</code> 操作连接到了处于 <code>listen</code> 的服务器；当服务器使用 <code>accept</code> 接受新的连接请求后，双方建立起了连接，通过 <code>read</code> 和 <code>write</code> 传输数据；最后使用 <code>close</code> 来关闭连接。</p>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>进一步深入了解如何使用 socket 编程前，先来看看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;error.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct sockaddr *PSA;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) </span><br><span class="line">&#123;</span><br><span class="line">    int fd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;socket&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in addr;</span><br><span class="line">    memset(&amp;addr, 0, sizeof(addr));</span><br><span class="line">    addr.sin_len = sizeof(addr);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(8080);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line"></span><br><span class="line">    if (connect(fd, (PSA) &amp;addr, sizeof(addr)) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;connect&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // do something</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是客户端，以及下面的服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;error.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct sockaddr *PSA;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) </span><br><span class="line">&#123;</span><br><span class="line">    int fd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;socket&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in addr;</span><br><span class="line">    memset(&amp;addr, 0, sizeof(addr));</span><br><span class="line">    addr.sin_len = sizeof(addr);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(8080);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    if (bind(fd, (PSA) &amp;addr, sizeof(addr)) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;bind&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (listen(fd, 10) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;listen&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in clientaddr;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int clientfd = accept(fd, (PSA) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        // do something</span><br><span class="line">        close(clientfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>这两段代码随手写的，没有经过验证。</em></p>
<p>上述代码是一个基本的客户端服务器 socket 编程模板，它展示了 socket 编程常用的 API 的用法。下面来看看如何使用 socket 编程 API。</p>
<h2 id="套接字地址"><a href="#套接字地址" class="headerlink" title="套接字地址"></a>套接字地址</h2><p>每一个 socket 对象在使用时都需要和一个具体的 socket 地址绑定，而每一个协议簇都有自己的套接字地址结构。这些结构以 <code>sockaddr</code> 开头，并以协议簇的唯一后缀结尾。</p>
<p>socket API 兼容多种协议簇。在实现上以一种通用套接字地址结构作为所有套接字地址的基类。（实际上在C语言中可以使用 <code>void*</code> 作为参数，不过 socket API 定义在 ANSI C 之前，此时还没有 <code>void*</code>。）</p>
<h3 id="通用套接字地址结构"><a href="#通用套接字地址结构" class="headerlink" title="通用套接字地址结构"></a>通用套接字地址结构</h3><p>在 <code>&lt;sys/socket.h&gt;</code> 头文件中定义了一个通用的套接字地址结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr &#123;</span><br><span class="line">    uint8_t sa_len;</span><br><span class="line">    sa_family_t sa_family;</span><br><span class="line">    char sa_data[14];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于应用开发人员来说，需要的是使用 API 时，强制将其他协议簇的地址结构指针转换为通用地址结构指针。也就是说：<strong>通用 socket 地址结构唯一的作用就是用于对特定协议的地址结构执行强制类型转换，以统一类型</strong>。</p>
<h3 id="IPv4-地址结构"><a href="#IPv4-地址结构" class="headerlink" title="IPv4 地址结构"></a>IPv4 地址结构</h3><p>在实际编程中容易接触到的时 IP 协议簇，而 IP 协议簇又分为 IPv4 和 IPv6 两个版本。先看 IPv4 的 socket 地址结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct in_addr &#123;</span><br><span class="line">    in_addr_t s_addr;   /* 32 bit IPv4 address,</span><br><span class="line">        in network byte ordered */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    uint8_t sin_len;        /* length of structure (16) */</span><br><span class="line">    sa_family_t sin_family; /* AF_INET */</span><br><span class="line">    in_port_t sin_port;     /* 16 bit port number，in network byte ordered */</span><br><span class="line">    struct in_addr sin_addr;/* 32 bit IPv4 address */</span><br><span class="line">    char sin_zero[8];       /* unused */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构定义在文件 <code>&lt;netinet/in.h&gt;</code> 中，编程人员主要关心：<code>sin_family</code>、<code>sin_addr</code> 和 <code>sin_port</code>。<code>sin_family</code> 表示使用的使用的协议簇。<code>sin_addr</code> 和 <code>sin_port</code> 表示具体的 socket 地址，<strong>需要注意两者的数据都必须是网络字节序</strong>。关于网络字节序可以参考<a href="https://blog.csdn.net/houwei544/article/details/8592996" target="_blank" rel="noopener">网络字节序-CSDN</a>。</p>
<h3 id="IPv6-地址结构"><a href="#IPv6-地址结构" class="headerlink" title="IPv6 地址结构"></a>IPv6 地址结构</h3><p>IPv6 地址结构和 IPv4 地址结构定义在同一文件中，其内部布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct in6_addr &#123;</span><br><span class="line">    uint8_t s6_addr; /* 128 bit IPv6 address,</span><br><span class="line">        in network byte ordered */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in6 &#123;</span><br><span class="line">    uint8_t sin6_len;   /* length of structure (28) */</span><br><span class="line">    sa_family_t sin6_family;    /* AF_INET6 */</span><br><span class="line">    in_port_t sin6_port;        /* port */</span><br><span class="line">    uint32_t sin6_flowinfo;     /* flow information */</span><br><span class="line">    struct in6_addr sin6_addr;  /* IPv6 address */</span><br><span class="line">    uint32_t sin6_scope_id;     /* set of interfaces for a scope */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="地址相关-API"><a href="#地址相关-API" class="headerlink" title="地址相关 API"></a>地址相关 API</h3><p>在使用的时候，需要在网络字节序和本地字节序之间进行转换，而 POSIX 提供了对应的字节序转换方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line"></span><br><span class="line">// 主机到网络</span><br><span class="line">uint16_t htons(uint16_t val);</span><br><span class="line">uint32_t htonl(uint32_t val);</span><br><span class="line"></span><br><span class="line">// 网络到主机</span><br><span class="line">uint16_t ntohs(uint16_t val);</span><br><span class="line">uint32_t ntohl(uint32_t val);</span><br></pre></td></tr></table></figure>
<p>除了提供字节序转换方法外，标准还提供了点分制地址到网络序的二进制值之间进行转换的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">int inet_aton(const char *cp, struct in_addr *inp);</span><br><span class="line">in_addr_t inet_addr(const char *cp);</span><br><span class="line">in_addr_t inet_network(const char *cp);</span><br><span class="line">char *inet_ntoa(struct in_addr in);</span><br></pre></td></tr></table></figure>
<p><code>inet_aton</code> 把 <code>cp</code> 对应的点分制的地址转换为网络地址并保存在 <code>inp</code> 中，如果地址正确则返回非零，否则返回0。 </p>
<p><code>inet_addr</code> 则是直接返回网络二进制地址，如果地址错误返回 <code>INADDR_NONE</code>。</p>
<p><code>inet_network</code> 和 <code>inet_addr</code> 一样，但是返回的地址是主机序的二进制地址，如果错误返回 -1。</p>
<p><code>inet_ntoa</code> 这个函数和前面的函数作用相反，是将网络序二进制地址转换为点分制的地址。需要注意的是如果再次调用该函数返回的 <code>buffer</code> 会被覆盖。</p>
<p>上面部分的内容是针对 IPv4 地址，对于 IPv6，标准提供了新的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int inet_pton(int af, const char *src, void *dst);</span><br><span class="line">const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</span><br></pre></td></tr></table></figure>
<p>这两个函数同时支持 IPv4 和 IPv6 ，所以在使用中，建议使用这两个函数替代原有的函数。对于第一个参数 <code>af</code> 表示具体的协议：<code>AF_INET</code> 和 <code>AF_INET6</code>，如果不是这两个值，则返回一个错误，并将 <code>errno</code> 设置成 <code>EAFNOSUPPORT</code>。</p>
<p>第一个函数尝试转换字符串对应的地址，并将得到的二进制数据保存到 <code>dst</code>，若成功返回 1，否则表示对应的 <code>family</code> 协议的字符串不是有效的，返回 0。</p>
<p>第二个函数进行了相反的转换，<code>size</code> 用于保存目标存储单元的大小，用于防止缓冲区溢出。标准定义了一个具体的数值来帮助开辟缓冲区空间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line"></span><br><span class="line">#define INET_ADDRSTRLEN     16</span><br><span class="line">#define INET6_ADDRSTRLEN    46</span><br></pre></td></tr></table></figure>
<p>如果缓冲区过小，那么返回一个空指针，并将 <code>errno</code> 设置为 <code>ENOSPC</code>。调用成功后，返回 <code>dst</code> 。</p>
<p>// TODO: IPv4 和 IPv6 混合</p>
<h2 id="socket-API"><a href="#socket-API" class="headerlink" title="socket API"></a>socket API</h2><h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket 函数"></a>socket 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;   </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>
<p>使用 <code>socket</code> 函数创建一个通信的 socket，并返回其描述符。</p>
<p><code>domain</code> 参数指定具体通行领域，用来告知具体的通信协议，TCP 中使用到了：<code>AF_INET</code> 和 <code>AF_INET6</code>。<code>type</code> 参数指定通信的语义，TCP 中主要关心 <code>SOCK_STREAM</code> —— 提供顺序，可靠的双向基于连接的字节流。可能支持带外数据传输机制。<code>protocol</code> 参数在此处只需要填 <code>IPPROTO_TCP</code>，表示使用 TCP 传输协议。</p>
<blockquote>
<p> Since  Linux  2.6.27,  the type argument serves a second purpose: in addition to specifying a socket type, it may include the bitwise OR of any of the following values, to modify the behavior of <code>socket()</code>:</p>
<p><code>SOCK_NONBLOCK</code>   Set the <code>O_NONBLOCK</code> file status flag on the new open file description.  Using this flag  saves extra calls to <code>fcntl</code> to achieve the same result.</p>
<p><code>SOCK_CLOEXEC</code>    Set  the  close-on-exec (<code>FD_CLOEXEC</code>) flag on the new file descriptor.  See the description of the <code>O_CLOEXEC</code> flag in <code>open</code> for reasons why this may be useful.</p>
</blockquote>
<p>当函数成功后，将返回新套接字的文件描述符。出错时返回-1，并适当设置 <code>errno</code>。<code>errno</code> 的具体错误值可能如下：</p>
<ul>
<li>EAFNOSUPPORT 该实现不支持指定的地址族。</li>
<li>EINVAL 未知协议或协议族不可用或类型中的标记无效。</li>
<li>EMFILE 已达到打开文件描述符数的限制。</li>
<li>ENOBUFS or ENOMEM 内存不足可用。在释放足够的资源之前，无法创建套接字。</li>
<li>EPROTONOSUPPORT 该域中不支持协议类型或指定的协议。</li>
</ul>
<h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;          </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<p><code>bind</code> 将由 <code>addr</code> 指定的地址分配给文件描述符 <code>sockfd</code> 引用的套接字。<code>addrlen</code> 指定 <code>addr</code> 指向的地址结构的大小（以字节为单位）。 传统上，这个操作称为“为套接字分配名称”。通常需要在 <code>SOCK_STREAM</code> 套接字接收（<code>accept</code>）连接之前使用 <code>bind</code> 分配本地地址。当函数成功后，将返回新套接字的文件描述符。成功返回 0 ，出错时返回-1，并适当设置 <code>errno</code>。<code>errno</code> 的具体错误值可能如下：</p>
<ul>
<li>EADDRINUSE 地址已经被使用了。                                                                    </li>
<li>EBADF  <code>sockfd</code> 不是不可用。                                                                        </li>
<li>EINVAL 当前 socket 已经绑定过地址了。或者 <code>addrlen</code> 错误，或者 <code>addr</code> 不是合法的地址。</li>
<li>ENOTSOCK <code>sockfd</code> 不是一个 socket 描述符。                                                  </li>
</ul>
<p>在通常的使用中，客户端程序没有调用 <code>bind</code> 直接使用 <code>connect</code> 创建连接，因为 socket 从系统内部选择一个端口组成 <code>addr</code> ，并将之与对应的 socket 绑定。<strong>也就是说，<code>bind</code>并不是仅仅用于 <code>listen</code>，也可以配合 <code>connect</code> 使用</strong>。如果没有使用 <code>bind</code> 绑定地址，可以使用 <code>getsockname</code> 获取地址信息。</p>
<h3 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;          </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<p><code>connect</code> 系统调用将文件描述符 <code>sockfd</code> 引用的套接字连接到 <code>addr</code> 指定的地址。<code>addrlen</code> 参数指定 <code>addr</code> 的大小。对于 TCP ，<code>connect</code> 触发三路握手，并在建立连接成功或者发生错误时返回，其中可能有以下几种情况：</p>
<ul>
<li>EADDRINUSE 地址已经被使用了。                                                                    </li>
<li>EBADF  <code>sockfd</code> 不是不可用。</li>
<li>timeout 如果 TCP 没有收到 SYN 分节的响应，则返回 ETIMEOUT。</li>
<li>reset 如果对方相应的时 RST ，表示服务器主机在我们指定的端口上没有程序监听，这是一种硬错误(hard error)，此时返回 ECONNREFUSED。</li>
<li>unreachable 如果目标主机不在当前网络中，发生了 ICMP 错误，则认为是一种软错误(soft error)，并返回 EHOSTUNREACH 或 ENETUNRECH 错误。</li>
</ul>
<p>如果 <code>connect</code> 出现错误而失败，则不能再重新使用，需要使用 <code>close</code> 关闭。如果需要重新连接，则需要从头创建描述符。</p>
<h3 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a>listen 函数</h3><p><code>listen</code> 函数仅仅由 TCP 服务器调用，它做两件事情：</p>
<ol>
<li>将 <code>socket</code> 建立的主动 socket （默认为主动）转换为被动的 socket，因此此 socket 可以使用 <code>accept</code> 来接收到来的连接请求。然后 socket 对应的状态由 <code>CLOSED</code> 状态变为 <code>LISTEN</code> 状态</li>
<li>它指定了 socket 在内核中的排队连接的数量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure>
<p><code>sockfd</code> 为对应的 socket 描述符。<code>backlog</code> 参数定义 <code>sockfd</code> 的挂起连接队列可能的最大长度。 如果连接请求在队列已满时到达，则客户端可能会收到带有 <code>ECONNREFUSED</code> 指示的错误，或者如果底层协议支持重传，则该请求可能会被忽略，以便以后重新尝试连接成功。</p>
<p>在 UNP 一书中说：内核为任何一个监听套接字维护两个队列。</p>
<ul>
<li>未完成连接队列：其中的套接字表示正在完成三路握手过程。这些套接字此时处于 <code>SYN_RCVD</code> 状态。</li>
<li>已经完成队列：表示这些套接字已经完成了三路握手过程，处于 <code>ESTABLISHED</code> 状态，等到 <code>accept</code> 读取。</li>
</ul>
<p>成功返回 0 ，出错时返回-1，并适当设置 <code>errno</code>。<code>errno</code> 的具体错误值可能如下：</p>
<ul>
<li>EADDRINUSE 地址已经被使用了。                                                                    </li>
<li>EBADF  <code>sockfd</code> 不是不可用。                                                     </li>
<li>ENOTSOCK <code>sockfd</code> 不是一个 socket 描述符。   </li>
<li>EOPNOTSUPP <code>sockfd</code> 对应的 socket 不支持 <code>listen</code> 操作。</li>
</ul>
<h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a>accept 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;     </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>
<p><code>accept</code> 函数从 <code>sockfd</code> 的<em>已经完成队列</em>中取出 socket。<code>addr</code> 表示接受的远程地址，<code>addrlen</code> 则是地址空间长度。在成功时，这些系统调用返回一个非负整数，它是接受的套接字的描述符。 出错时返回-1，并适当设置errno。在 linux 中还有一个新版本的函数 <code>accept4</code>：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; #define _GNU_SOURCE             /* See feature_test_macros(7) */</span><br><span class="line">&gt; #include &lt;sys/socket.h&gt;</span><br><span class="line">&gt; int accept4(int sockfd, struct sockaddr  *addr, socklen_t *addrlen, int flags);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>If flags is 0, then accept4() is the same as accept().  The following values can be bitwise ORed in flags to obtain different behavior:</p>
<ul>
<li><p>SOCK_NONBLOCK   Set  the O_NONBLOCK file status flag on the new open file description.  Using this flag saves extra calls to fcntl(2) to achieve the same result.</p>
</li>
<li><p>SOCK_CLOEXEC    Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the  description  of the O_CLOEXEC flag in open(2) for reasons why this may be useful.</p>
</li>
</ul>
</blockquote>
<h3 id="getsockname-和-getpeername-函数"><a href="#getsockname-和-getpeername-函数" class="headerlink" title="getsockname 和 getpeername 函数"></a>getsockname 和 getpeername 函数</h3><p>这两个函数分别返回与某个 socket 关联的本地地址，以及远程地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int getsockname(int sockfd, int sockaddr *localaddr, socklen_t *addrlen);</span><br><span class="line">int getpeername(int sockfd, int sockaddr *remoteaddr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>
<p>两个函数的用法一致。如果正确返回 0 ，错误返回 -1，并设置 <code>errno</code>。</p>
<h3 id="关闭-socket-连接"><a href="#关闭-socket-连接" class="headerlink" title="关闭 socket 连接"></a>关闭 socket 连接</h3><p>终止 socket 连接的通常方法是使用 <code>close</code> 函数，不过 <code>close</code> 函数有两个限制，而 <code>shutdown</code> 则可以避免：</p>
<ul>
<li><code>close</code> 只是将引用计数减一，只有计数为 0 时才关闭套接字。而 <code>shutdown</code> 则可以不管引用技术直接触发 TCP 的正常连接终止序列。</li>
<li><code>close</code> 会将读写两个方向的连接都关闭，而某些情况下 TCP 需要保持一方的连接。而 <code>shutdown</code> 则可以关闭某一方的连接，也就是 TCP 的半关闭状态。</li>
</ul>
<p><code>shutdown</code> 函数的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int shutdown(int sockfd, int how);</span><br></pre></td></tr></table></figure>
<p>该函数的行为依赖于 <code>how</code> 的值：</p>
<ul>
<li>SHUT_RD 关闭本端的读这一半，socket 不再接收新数据，同时丢弃缓冲区中的数据。</li>
<li>SHUT_WR 关闭写的这一半，当前缓冲区的数据将被发送。此时进程无法再对该 socket 进行写操作。</li>
<li>SHUT_RDWR 将读写都关闭，这等价于先调用 <code>shutdown(fd, SHUT_RD)</code> 然后调用 <code>shutdown(fd, SHUT_WR)</code>。</li>
</ul>
<p>要注意，<strong><code>shutdown(fd, SHUT_RDWR)</code>仅仅是断开了 socket 连接，但是并不意味着 socket 被关闭了，此时还需要调用 <code>close(fd)</code> 来释放文件描述符，否则会造成描述符泄露</strong> 。</p>
<h2 id="socket-options"><a href="#socket-options" class="headerlink" title="socket options"></a>socket options</h2><p>有多种办法获取或设置 socket 的选项：</p>
<ul>
<li><code>getsockopt</code> 和 <code>setsockopt</code> 函数</li>
<li><code>fcntl</code> 函数</li>
<li><code>ioctl</code> 函数</li>
</ul>
<h3 id="getsockopt-amp-setsockopt"><a href="#getsockopt-amp-setsockopt" class="headerlink" title="getsockopt &amp; setsockopt"></a>getsockopt &amp; setsockopt</h3><p>这两个函数仅用于 socket：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;          /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);</span><br><span class="line">int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</span><br></pre></td></tr></table></figure>
<p>其中 <code>sockfd</code> 必须指向<strong>打开的</strong>套字符， <code>level</code> 指定如何解释后面的选项；<code>optname</code> 则是具体的选项内容；<code>optval</code> 指向某个具体变量，<code>setsockopt</code> 从 <code>optval</code> 指向的变量中读值，<code>getsockopt</code> 则将值写入 <code>optval</code>；显而易见的 <code>optlen</code> 为 <code>optval</code> 所指向变量的大小。</p>
<p><code>level</code> 分别指出 <code>optname</code> 是 <code>socket</code>、<code>ip</code> 还是 <code>TCP</code> 的选项。首先来看 <code>socket</code> 的 <code>SOL_SOCKET</code> 所对一个的选项，只列出了重要的部分：</p>
<ul>
<li><p><code>SO_REUSEADDR</code> &amp; <code>SO_REUSEPORT</code>：<code>SO_REUSEADDR</code> 主要有两个工作：1、改变了在处理源地址冲突时对通配地址(“any ip address”)的处理方式的处理方法；2、处于<code>TIME_WAIT</code>状态中的socket可以重用。关于这两者的行为及其异同不详述，请参考<a href="http://www.hashcoding.net/2017/06/04/SO-REUSEADDR-SO-REUSEPORT-%E5%BC%82%E5%90%8C/">SO_REUSEADDR &amp; SO_REUSEPORT 的异同</a></p>
</li>
<li><p><code>SO_RECVBUF</code> / <code>SO_SNDBUF</code> 先明确一个概念：每个TCP socket在内核中都有一个发送缓冲区和一个接收缓冲区，TCP的全双工的工作模式以及TCP的滑动窗口便是依赖于这两个独立的buffer以及此buffer的填充状态。接收缓冲区把数据缓存入内核，应用进程一直没有调用read进行读取的话，此数据会一直缓存在相应socket的接收缓冲区内。再啰嗦一点，不管进程是否读取socket，对端发来的数据都会经由内核接收并且缓存到socket的内核接收缓冲区之中。read所做的工作，就是把内核缓冲区中的数据拷贝到应用层用户的buffer里面，仅此而已。进程调用send发送的数据的时候，最简单情况（也是一般情况），将数据拷贝进入socket的内核发送缓冲区之中，然后send便会在上层返回。换句话说，send返回之时，数据不一定会发送到对端去（和write写文件有点类似），send仅仅是把应用层buffer的数据拷贝进socket的内核发送buffer中。如果应用进程一直没有读取，buffer满了之后，发生的动作是：通知对端TCP协议中的窗口关闭。这个便是滑动窗口的实现。保证TCP套接口接收缓冲区不会溢出，从而保证了TCP是可靠传输。因为对方不允许发出超过所通告窗口大小的数据。这就是TCP的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它。</p>
</li>
<li><p><code>SO_KEEPALIVE</code> <code>SO_KEEPALIVE</code> 如果一方已经关闭或异常终止连接，而另一方却不知道，我们将这样的TCP连接称为半打开的。TCP通过保活定时器(KeepAlive)来检测半打开连接。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP 就自动给对方发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：</p>
<ol>
<li>对方接收一切正常：以期望的 ACK 响应，2小时后，TCP 将发出另一个探测分节。</li>
<li>对方已崩溃且已重新启动：以 RST 响应。套接口的待处理错误被置为 <code>ECONNRESET</code>，套接口本身则被关闭。</li>
<li><p>对方无任何响应：源自 berkeley 的 TCP 发送另外 8 个探测分节，相隔 75 秒一个，试图得到一个响应。在发出第一个探测分节 11 分钟 15 秒后若仍无响应就放弃。套接口的待处理错误被置为 <code>ETIMEOUT</code>，套接口本身则被关闭。如 ICMP 错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为 <code>EHOSTUNREACH</code>。</p>
<p>有关 <code>SO_KEEPALIVE</code> 的三个参数详细解释如下: </p>
</li>
</ol>
<ul>
<li><code>tcp_keepalive_intvl</code>: 保活探测消息的发送频率。默认值为 75s。发送频率<code>tcp_keepalive_intvl</code> 乘以发送次数 <code>tcp_keepalive_probes</code> ，就得到了从开始探测直到放弃探测确定连接断开的时间，大约为11min。</li>
<li><code>tcp_keepalive_probes</code>，TCP 发送保活探测消息以确定连接是否已断开的次数。默认值为9（次）。注意：只有设置了 <code>SO_KEEPALIVE</code> 套接口选项后才会发送保活探测消息。</li>
<li><code>tcp_keepalive_time</code>，在 TCP 保活打开的情况下，最后一次数据交换到 TCP 发送第一个保活探测消息的时间，即允许的持续空闲时间。默认值为 7200s（2h）。</li>
</ul>
</li>
<li><p><code>SO_LINGER</code> <code>SO_LINGER</code> 将决定系统如何处理残存在套接字发送队列中的数据。处理方式无非两种：丢弃或者将数据继续发送至对端，优雅关闭连接。事实上，<code>SO_LINGER</code> 并不被推荐使用，大多数情况下我们推荐使用默认的关闭方式。关于 <code>SO_LINGER</code> 具体描述可以参考：<a href="http://blog.csdn.net/factor2000/article/details/3929816" target="_blank" rel="noopener">SO_LINGER 选项设置</a>。</p>
</li>
<li><p><code>SO_RCVLOWAT</code> / <code>SO_SNDLOWAT</code> 分别表示TCP接收缓冲区和发送缓冲区的低水位标记。它们一般被I/O复用系统调用用来判断socket是否可读或可写。当TCP接收缓冲区中可读数据的总数大于其低水位标记时，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据；当TCP发送缓冲区中的空闲空间（可以写入数据的空间）大于其低水位标记时，I/O复用系统调用将通知应用程序可以往对应的socket上写入数据。默认情况下，TCP接收缓冲区的低水位标记为1字节和TCP发送缓冲区的低水位标记均为2048字节。</p>
</li>
<li><p><code>SO_RCVTIMEO</code> / <code>SO_SNDTIMEO</code> 这两个选项给套接字的接收和发送设置一个超时值。注意，访问函数的参数是指向<code>timeval</code>结构的指针。通过设置值为0秒和0微妙禁止超时。缺省情况下，两个超时都是禁止的。</p>
</li>
</ul>
<p>另外，实际编程中还关心 TCP 相关的选项 <code>IPPROTO_TCP</code>：</p>
<ul>
<li><p><code>TCP_NODELAY</code> / <code>TCP_CHORK</code> 是否采用 Nagle 算法把较小的包组装为更大的帧。<strong>HTTP服务器经常使用 <code>TCP_NODELAY</code> 关闭该算法</strong>。相关的还有 <code>TCP_CORK</code>。</p>
</li>
<li><p><code>TCP_DEFER_ACCEPT</code> 推迟 <code>accept</code>，实际上是当接收到第一个数据之后，才会创建连接。<strong>（对于像HTTP等非交互式的服务器，这个很有意义，可以用来防御空连接攻击。）</strong></p>
</li>
<li><p><code>TCP_KEEPCNT</code> / <code>TCP_KEEPIDLE</code> / <code>TCP_KEEPINTVL</code> 这三个参数配合 <code>SO_KEEPALIVE</code> 使用，通过 <code>TCP_KEEPIDLE</code>、<code>TCP_KEEPINTVL</code> 和 <code>TCP_KEEPCNT</code> 设置 keepalive 的开始时间、间隔、次数等参数。保活时间：<code>keepalive_time = TCP_KEEPIDLE + TCP_KEEPINTVL * TCP_KEEPCNT</code> 从 <code>TCP_KEEPIDLE</code> 时间开始，向对端发送一个探测信息，然后每过 <code>TCP_KEEPINTVL</code>  发送一次探测信息。如果在保活时间内，就算检测不到对端了，仍然保持连接。超过这个保活时间，如果检测不到对端，服务器就会断开连接，如果能够检测到对方，那么连接一直持续。</p>
</li>
</ul>
<h2 id="非阻塞socket"><a href="#非阻塞socket" class="headerlink" title="非阻塞socket"></a>非阻塞socket</h2><p>阻塞是指调用结果返回前，当前线程会被挂起。当函数结果返回时当前线程才恢复执行。非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<p>前面的socket函数默认是阻塞模式，使用<code>fcntl</code>可以将socket设置为非阻塞模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int flags = fcntl(fd, F_GETFL, 0);</span><br><span class="line">fcntl(fd, F_SETFL, flags | O_NONBLOCK);</span><br></pre></td></tr></table></figure>
<p>非阻塞socket编程与阻塞编程的区别主要在于一些可能造成阻塞的操作在无法完成操作的情况下直接返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>。比如使用<code>read</code>，而此时输入缓冲区中没有任何数据，那么直接返回<code>EWOULDBLOCK</code>。这样服务器可以将CPU用于处理其他逻辑，而非等待数据到达。</p>
<p>对于非阻塞socket，可能写出下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fds[MAX_FDS];</span><br><span class="line">// ...</span><br><span class="line">for (int i = 0; i &lt; max_fd; ++i) &#123;</span><br><span class="line">    if (read(fds[i], buf, sizeof(buf)) != EWOULDBLOCK) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>对于非阻塞式socket，如果使用轮询实现，每次都要陷入内核态，且依次轮询效率非常低，所以提出了IO多路复用机制。所谓IO多路复用，在实现上是将轮询机制转换为观察者模式。用户需要注册文件描述符以及需要监听事件，而内核负责在发生某些事件（可读等）时通知用户。也就是说原来需要在每条连接上进行监听，而使用IO多路复用后，监听过程交给了内核，由内核将消息分发到每一条连接上。</p>
<p>按照IO多路复用的发展历程，出现了<code>select</code>、<code>poll</code>和<code>epoll</code>（在BSD上对应kqueue)。</p>
<p>关于<code>select</code>使用参考<a href="http://www.cnblogs.com/ccsccs/articles/4224253.html" target="_blank" rel="noopener">Linux select 详解</a>。</p>
<p>关于<code>poll</code>使用参考<a href="http://blog.csdn.net/zmxiangde_88/article/details/8099049" target="_blank" rel="noopener">poll调用详解</a>。</p>
<p>关于<code>epoll</code>使用参考<a href="http://blog.jobbole.com/93566/" target="_blank" rel="noopener">通过完整示例来理解如何使用epoll</a>。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">TCP - Wikis</a> </li>
<li>TCP/IP 详解 卷一：协议</li>
<li>UNIX 网络编程 卷一：套接字联网API</li>
<li><a href="https://www.zhihu.com/question/48871684" target="_blank" rel="noopener">如何正确关闭 TCP 连接 - 知乎</a></li>
<li><a href="http://0xffffff.org/2014/11/20/33-servie-program/" target="_blank" rel="noopener">浅谈服务端编程</a></li>
<li><a href="http://elf8848.iteye.com/blog/1961192" target="_blank" rel="noopener">TCP/IP Socket心跳机制so_keepalive的三个参数详解</a></li>
<li><a href="http://blog.csdn.net/tengyft/article/details/45826735" target="_blank" rel="noopener">SO_RCVLOWAT和SO_SNDLOWAT选项</a></li>
<li><a href="https://my.oschina.net/yangan/blog/185262" target="_blank" rel="noopener">TCP选项之SO_RCVLOWAT和SO_SNDLOWAT</a></li>
<li><a href="http://blog.chinaunix.net/uid-29075379-id-3905006.html" target="_blank" rel="noopener">TCP选项之SO_RCVBUF和SO_SNDBUF</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/05/17/链接/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/17/链接/" itemprop="url">链接</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-17T09:50:10+08:00">
                2017-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/05/17/链接/" class="leancloud_visitors" data-flag-title="链接">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>链接是把各种代码、数据收集起来组合成单一文件的过程，这个文件可以被加载到内存中执行。在实际开发中，会将项目分散成小的、更容易管理的模块，然后独立的修改和编译这些模块。链接则是将各个模块组合成可执行文件的过程。</p>
<p>链接通常由链接器完成，不过现代编译器或编译环境已经处理了链接过程，需要手动使用链接器完成的场景已经很少了。大多数现代编译系统提供了编译驱动程序，它可以依次使用预处理、编译、汇编、链接器来完成编译到链接的过程，不需要用户干预。</p>
<p>比如由a.c和b.c两个文件，在编译驱动程序的帮助下，可以使用简单命令完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o program a.c b.c</span><br></pre></td></tr></table></figure>
<p>上述命令等价于下面这些命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cpp a.c a.i</span><br><span class="line">cpp b.c b.i</span><br><span class="line">cc1 a.i -o a.S</span><br><span class="line">cc1 b.i -o b.S</span><br><span class="line">as -o a.o a.S</span><br><span class="line">as -o b.o b.S</span><br><span class="line">ld -o program a.o b.o</span><br></pre></td></tr></table></figure>
<p>上述过程依次调用预处理、编译、汇编和链接器，最终生成了可执行文件。</p>
<p>像ld程序这样的静态链接器以一组可重定位的目标文件和参数作为输入，生成完全链接的可执行目标文件。可重定位目标文件由一系列的节(section)组成。</p>
<h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>目标文件有三种</p>
<ul>
<li>可重定位目标文件</li>
<li>可执行目标文件</li>
<li>共享目标文件</li>
</ul>
<p>这里只关心可重定位目标文件，它包含了二进制代码和数据，不过其中的信息并不完善，需要和其他文件一起才能组成一个可执行目标文件或者共享目标文件。</p>
<p>所谓可重定位，是指包含的二进制代码中有引用到其他模块的，由于不知道其他模块中二进制代码布局，所以留了空等待回填。使用例子更方便理解可重定位目标文件。假设有下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int a, a1=1;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">  static int b = 1;</span><br><span class="line">  static int c;</span><br><span class="line"></span><br><span class="line">  printf(&quot;hello world&quot;, a, b);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将之命名为<code>hello.c</code>，然后使用命令生成重定位目标文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.o hello.c</span><br></pre></td></tr></table></figure>
<p>此时<code>hello.o</code>便是可重定位目标文件，使用<code>objdump -h hello.o</code>可以看看可重定位目标文件的节(section)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/mnt/d/tmp$ objdump -h hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000028  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  0000000000000000  0000000000000000  00000068  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000004  0000000000000000  0000000000000000  00000070  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       0000000c  0000000000000000  0000000000000000  00000070  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      00000035  0000000000000000  0000000000000000  0000007c  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000b1  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000b8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure>
<p><code>Idx</code> 是编号，<code>Name</code> 是节点名称，<code>Size</code> 是节大小，<code>VMA</code> 是在虚拟内存中的起点，<code>LMA</code> 是节的装载地址（除了ROM之外，通常与 VMA 相同），<code>File off</code> 是在文件中的具体偏移，<code>Algn</code> 是对齐地址。各节第二行描述了节的属性。<code>CONTENTS</code> 表示节在文件中占用了内存空间，<code>ALLOC</code> 则表示需要分配内存，<code>RELOC</code> 表示需要重定位。</p>
<p><code>.text</code> 包含了已编译程序的二进制代码，<code>.data</code>是已经初始化的全局C变量或静态局部变量，<code>.bss</code>是未初始化的全局变量或静态局部变量，<code>rodata</code>包含只读数据。其他的数据暂时可以不用关心。</p>
<p>观察符号表来说明符号所在section：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/mnt/d/tmp$ objdump -t hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*  0000000000000000 hello.c</span><br><span class="line">0000000000000000 l    d  .text  0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data  0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss   0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .rodata        0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data  0000000000000004 b.2288</span><br><span class="line">0000000000000000 l     O .bss   0000000000000004 c.2289</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack        0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame      0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment       0000000000000000 .comment</span><br><span class="line">0000000000000004       O *COM*  0000000000000004 a</span><br><span class="line">0000000000000000 g     O .data  0000000000000004 a1</span><br><span class="line">0000000000000000 g     F .text  0000000000000028 main</span><br><span class="line">0000000000000000         *UND*  0000000000000000 printf</span><br></pre></td></tr></table></figure>
<p>各列分别是解内偏移，标记位，所在节，对齐方式和符号名。<em>ABS</em> 表示这是一个不和任何节相关的绝对符号，<em>UND</em>则这个符号不在本文件中定义，<em>COM</em> 表示还未分配位置的未初始化数据目标。</p>
<p><code>a</code>和<code>c</code>没有初始化，放到了<code>.bss</code>节中，<code>b</code>和<code>a1</code>则是放到了<code>.data</code>节中，而<code>mian</code>表示的函数放到了<code>.text</code>节中，<code>printf</code>则是未定义的符号，需要进行重定位。使用<code>objdump -r</code>可以显示可重定位目标文件的重定位项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/mnt/d/tmp$ objdump -r hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000006 R_X86_64_PC32     .data</span><br><span class="line">000000000000000c R_X86_64_PC32     a-0x0000000000000004</span><br><span class="line">0000000000000013 R_X86_64_32       .rodata</span><br><span class="line">000000000000001d R_X86_64_PC32     printf-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure>
<p>分别表示 <code>.text</code> 和 <code>.eh_frame</code> 节的重定位表。重定位表是在程序中留下的空位所在地方，可以修改代码简单验证一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int a;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">  static int b = 1;</span><br><span class="line"></span><br><span class="line">  printf(&quot;hello world&quot;, a, b);</span><br><span class="line">  printf(&quot;hello world&quot;, a, b);</span><br><span class="line">  printf(&quot;hello world&quot;, a, b);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将<code>printf</code>使用多次，然后看看重定位表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/mnt/d/tmp$ objdump -r hello.o</span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000006 R_X86_64_PC32     .data</span><br><span class="line">000000000000000c R_X86_64_PC32     a-0x0000000000000004</span><br><span class="line">0000000000000013 R_X86_64_32       .rodata</span><br><span class="line">000000000000001d R_X86_64_PC32     printf-0x0000000000000004</span><br><span class="line">0000000000000023 R_X86_64_PC32     .data</span><br><span class="line">0000000000000029 R_X86_64_PC32     a-0x0000000000000004</span><br><span class="line">0000000000000030 R_X86_64_32       .rodata</span><br><span class="line">000000000000003a R_X86_64_PC32     printf-0x0000000000000004</span><br><span class="line">0000000000000040 R_X86_64_PC32     .data</span><br><span class="line">0000000000000046 R_X86_64_PC32     a-0x0000000000000004</span><br><span class="line">000000000000004d R_X86_64_32       .rodata</span><br><span class="line">0000000000000057 R_X86_64_PC32     printf-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure>
<p>这样的结果刚好印证了前面的说法。</p>
<p>链接器将可重定位目标文件组合成为可执行或共享目标文件时，必须完成两个任务：</p>
<ul>
<li>符号解析 符号解析是将符号的定义和每次使用联系起来</li>
<li>重定位 重定位则是将引用符号时留空填上对应的符号地址</li>
</ul>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>链接器解析符号引用的办法是将每个引用与它输入的可重定位目标文件的符号表中一个确定的符号联系起来。如果符号的定义和引用都在同一文件内，解析起来非常方便。如果不是当前模块中定义的符号，则会在其他文件中查找，如果所有文件中都没有，那么会报错。比如对于下面的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void bar(int,int);</span><br><span class="line">int main() &#123;</span><br><span class="line">    bar(0,0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器能够正常执行，并生成可重定位目标文件，但是链接器会报错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/cc672f5D.o: In function `main&apos;:</span><br><span class="line">test.c:(.text+0x5): undefined reference to `bar&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NOTICE: 注意C++中符号的命名不同于C语言（存在重载），所以在C++中可能看到的符号名类似于<code>_Z3barii</code></p>
</blockquote>
<p>当然，如果多个文件中存在多重定义的全局符号，则会按照一定的规则来选出一个符号作为目标符号，具体信息可以查阅相关资料。</p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>你可能已经注意到在重定位表中存在这两种不同类型的重定义<code>R_X86_64_PC32</code>和<code>R_X86_64_32</code>。</p>
<p>前一种表示使用32位PC相对地址引用，比如<code>pc+4</code>之类的值，所以此处应该回填目标符号和当前符号的相对地址。</p>
<p>后一种表示使用32位绝对地址引用，说明此处可以直接填上符号的绝对地址，比如<code>jmp bar</code>。</p>
<p>链接器在所有的符号查找完成的同时记录下其真正的地址。链接器重定位算法大概如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foreach section s &#123;</span><br><span class="line">  foreach relocation entry r &#123;</span><br><span class="line">    refptr = s + r.offset;</span><br><span class="line">    if (r.type == XXXX_PC32) &#123;</span><br><span class="line">      refaddr = ADDR(s) + r.offset;</span><br><span class="line">      *refptr = ADDR(r.symbol) + *refptr - refaddr;</span><br><span class="line">    &#125;</span><br><span class="line">    if (r.type == XXXX_32) &#123;</span><br><span class="line">      *refptr = ADDR(r.symbol) + *refptr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>ADDR()</code>表示了指定符号的真正地址。对于相对地址，首先用节的真实地址（这就是为甚么符号表中竟然含有节名）和符号在节中的偏移计算出需要回填的位置在内存中的真实地址。然后通过所引用符号的内存地址计算出其偏移。可能不能理解的是为何算法中加上了<code>*refptr</code>，我们可以看看重定位表项:<code>a-0x0000000000000004</code>，后面的值实际上就是<code>*refptr</code>的值。这样做可以在不同指令大小和编码方式不同的机器上，使用相同的链接器，即链接器可以透明的重定位引用，而不需要知道具体机器相关的细节。对于绝对地址，已经不需要再过解释。</p>
<h2 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h2><p>有时会用到一些第三方提供的库文件，但是只用到其中一两个函数，而整个文件非常大，感觉非常不合算。比如标准库函数，如果我们只需要一个<code>printf</code>却把整个标准库包含进去，得不偿失。此时静态库的概念被提出来，将所有相关的目标模块打包成为一个单独的文件，然后链接器链接的时候，只拷贝被程序引用到的目标模块或函数。</p>
<h2 id="共享库与位置无关代码"><a href="#共享库与位置无关代码" class="headerlink" title="共享库与位置无关代码"></a>共享库与位置无关代码</h2><p>比如使用标准库，每个程序都拷贝一份标准库代码，如果 PC 中运行着非常多的程序时，那么标准库拷贝也会被复制多份，因此提出了共享库的概念。使用共享库，将原有的拷贝代码到程序中的方式改为 PC 中只运行一份代码库，所有程序中均调用该共享库的实例。共享库是一个目标模块，在运行时随机加载到储存器的任意地址，并和一个在储存器中的程序链接起来。这个过程成为动态链接，是由一个叫动态链接器的程序来执行的。共享库在 Unix 系统中通常使用后缀 so，在 Windows 系统中称为 DLL。</p>
<p>动态库是随机加载到存储器中，而用户程序怎么知道何时何地呢？此时使用叫做<strong>位置无关的代码</strong>(Position-Independent Code, PIC)来解决。举例来说明为何位置无关代码能解决这个问题，首先假设有 <code>find_func_address</code> 函数用于在共享库中查找目标函数地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *find_func_address(const char *name);</span><br></pre></td></tr></table></figure>
<p>然后在具体的程序中使用共享库并使用内部函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 假设共享库中有函数 bar，其签名如下 */</span><br><span class="line">typedef void (*Bar)();</span><br><span class="line"></span><br><span class="line">/* load library */</span><br><span class="line">Bar bar = (Bar)find_func_address(&quot;bar&quot;);  </span><br><span class="line"></span><br><span class="line">bar(); /* call */</span><br><span class="line"></span><br><span class="line">/* release library */</span><br></pre></td></tr></table></figure>
<p>只需要 <code>find_func_address</code> 能找到函数在共享库中的地址，然后在需要的地方查找即可。不过程序员肯定受不了每次使用均调用一次 <code>find_func_address</code> ，并且程序中存在上千甚至更多次引用时，重复加载的效率也非常低。因此可以将代码改写一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*Bar)();</span><br><span class="line">void bar() &#123;</span><br><span class="line">  static Bar bar_ = (Bar) find_func_address(&quot;bar&quot;);</span><br><span class="line">  return bar_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">bar(); /* call */</span><br></pre></td></tr></table></figure>
<p>这里的代码解决了上面的两个问题：1、程序中引用共享库中的 <code>bar</code> 函数只需要使用 <code>void bar()</code> 函数即可；2、利用局部静态变量的初始化特性保证只初始化一次。</p>
<blockquote>
<p>注意，上述代码并不是线程安全的，参考：<a href="http://blog.csdn.net/wingfiring/article/details/498242" target="_blank" rel="noopener">多线程中局部静态变量初始化的陷阱</a></p>
</blockquote>
<p>当然，这部分工作已经由编译器完成，我们不需要操心。在编译器实现中，使用了 GOT (global offset table) 和 PLT (procedure linkage table) 完成，而这个过程称为延迟绑定(lazy binding)。所谓延迟绑定，就是将过程地址的绑定推迟到第一次调用该过程（函数）时。每个函数均有对应的 GOT 表项和 PLT 表项，如果将之和上面的代码对应，那么 GOT 表项相当于 <code>void bar()</code>，而 PLT 表项相当于 <code>static Bar bar_ = (Bar) find_func_address(&quot;bar&quot;);</code>。在使用延迟绑定技术时，用户调用了共享库函数，此时 IP 跳转到该函数的 GOT 表项所在位置；对于首次调用，GOT 表项填着 PLT 表项地址，所以 IP 继续跳转到 PLT 表项所在位置，而 PLT 负责完成查找函数地址，并将地址保存到 GOT 表项，然后跳转到 GOT 表项从新执行；对于非首次访问，直接跳转到 GOT 所在地址，完成调用过程。</p>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p>[1] 深入理解计算机系统<br>[2] <a href="www.hashcoding.net/2017/05/03/%E5%B8%B8%E7%94%A8Linux%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/">Objdump 使用</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/05/13/FastJson-踩坑记录/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/13/FastJson-踩坑记录/" itemprop="url">FastJson 踩坑记录</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-13T20:49:05+08:00">
                2017-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Debug-日志/" itemprop="url" rel="index">
                    <span itemprop="name">Debug 日志</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/13/FastJson-踩坑记录/" class="leancloud_visitors" data-flag-title="FastJson 踩坑记录">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>关键字: fastjson stackoverflow<br>本文使用的版本是 1.2.32</p>
</blockquote>
<p>fastjson 是阿里开源的Json格式化工具库。在项目中使用了fastjson，然后出现了一个奇怪的bug。程序在序列化的时候递归调用了我调用序列化函数的函数。简单点说就是序列化中递归地调用了自己，最后stackoverflow。</p>
<p>下面是是使用的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Host &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    public Host() &#123;&#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Host factory(byte [] bytes) &#123;</span><br><span class="line">        return JSON.parseObjec(bytes, Host.class);</span><br><span class="line">    &#125;</span><br><span class="line">    public byte[] getJson() &#123;</span><br><span class="line">        return JSON.toJSONBytes(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在程序中某处使用<code>byte []bytes = host.getJson()</code>，出现的错误大概如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at com.alibaba.fastjson.serializer.JSONSerializer.setContext(JSONSerializer.java:113)</span><br><span class="line">	at com.alibaba.fastjson.serializer.JSONSerializer.setContext(JSONSerializer.java:109)</span><br><span class="line">	at com.alibaba.fastjson.serializer.ASMSerializer_1_Host.write(Unknown Source)</span><br><span class="line">	at com.alibaba.fastjson.serializer.JSONSerializer.write(JSONSerializer.java:275)</span><br><span class="line">	at com.alibaba.fastjson.JSON.toJSONBytes(JSON.java:679)</span><br><span class="line">	at com.alibaba.fastjson.JSON.toJSONBytes(JSON.java:605)</span><br><span class="line">	at com.alibaba.fastjson.JSON.toJSONBytes(JSON.java:598)</span><br><span class="line">	at xxx.Host.getBytes(Host.java:38)</span><br><span class="line">	at com.alibaba.fastjson.serializer.ASMSerializer_1_Host.write(Unknown Source)</span><br><span class="line">	at com.alibaba.fastjson.serializer.JSONSerializer.write(JSONSerializer.java:275)</span><br><span class="line">	at com.alibaba.fastjson.JSON.toJSONBytes(JSON.java:679)</span><br><span class="line">	at com.alibaba.fastjson.JSON.toJSONBytes(JSON.java:605)</span><br><span class="line">	at com.alibaba.fastjson.JSON.toJSONBytes(JSON.java:598)</span><br><span class="line">	at xxx.Host.getBytes(Host.java:38)</span><br></pre></td></tr></table></figure>
<p>分析调用堆栈发现fastjson在生成的<code>serializer.ASMSerializer\_1\_Host</code>中调用了<code>Host.getJson()</code>导致了递归。排除自己的错误后，就将代码定位到了fastjson中，应该是fastjson中出了问题。然后开始调试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] toJSONBytes(Object object, SerializeConfig config, int defaultFeatures, SerializerFeature... features) &#123;</span><br><span class="line">    SerializeWriter out = new SerializeWriter(null, defaultFeatures, features);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        JSONSerializer serializer = new JSONSerializer(out, config);</span><br><span class="line">        serializer.write(object);</span><br><span class="line">        return out.toBytes(IOUtils.UTF8);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照栈调用顺序来看，出错点应该在<code>serializer.write(object)</code>内部，继续深入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final void write(Object object) &#123;</span><br><span class="line">    if (object == null) &#123;</span><br><span class="line">        out.writeNull();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz = object.getClass();</span><br><span class="line">    ObjectSerializer writer = getObjectWriter(clazz);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        writer.write(this, object, null, null, 0);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new JSONException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里发现通过<code>getObjectWriter(clazz)</code>取得了<code>host</code>的<code>writer</code>，想必就是自动生成的<code>ASMSerializer_1_Host</code>实例。本来想进入<code>writer.write</code>中观察，没有源代码只好放弃。然后将目标放到<code>getObjectWriter</code>中，看看在<code>writer</code>实例构造过程中能不能找到点线索。</p>
<p>经过几层跳转，来到了真正的<code>getObjectWriter</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line">private ObjectSerializer getObjectWriter(Class&lt;?&gt; clazz, boolean create) &#123;</span><br><span class="line">    ObjectSerializer writer = serializers.get(clazz);</span><br><span class="line"></span><br><span class="line">    if (writer == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            for (Object o : ServiceLoader.load(AutowiredObjectSerializer.class, classLoader)) &#123;</span><br><span class="line">                if (!(o instanceof AutowiredObjectSerializer)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                AutowiredObjectSerializer autowired = (AutowiredObjectSerializer) o;</span><br><span class="line">                for (Type forType : autowired.getAutowiredFor()) &#123;</span><br><span class="line">                    put(forType, autowired);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassCastException ex) &#123;</span><br><span class="line">            // skip</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer = serializers.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (writer == null) &#123;</span><br><span class="line">        final ClassLoader classLoader = JSON.class.getClassLoader();</span><br><span class="line">        if (classLoader != Thread.currentThread().getContextClassLoader()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (Object o : ServiceLoader.load(AutowiredObjectSerializer.class, classLoader)) &#123;</span><br><span class="line"></span><br><span class="line">                    if (!(o instanceof AutowiredObjectSerializer)) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    AutowiredObjectSerializer autowired = (AutowiredObjectSerializer) o;</span><br><span class="line">                    for (Type forType : autowired.getAutowiredFor()) &#123;</span><br><span class="line">                        put(forType, autowired);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassCastException ex) &#123;</span><br><span class="line">                // skip</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            writer = serializers.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (writer == null) &#123;</span><br><span class="line">        if (Map.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, MapSerializer.instance);</span><br><span class="line">        &#125; else if (List.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, ListSerializer.instance);</span><br><span class="line">        &#125; else if (Collection.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, CollectionCodec.instance);</span><br><span class="line">        &#125; else if (Date.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, DateCodec.instance);</span><br><span class="line">        &#125; else if (JSONAware.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, JSONAwareSerializer.instance);</span><br><span class="line">        &#125; else if (JSONSerializable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, JSONSerializableSerializer.instance);</span><br><span class="line">        &#125; else if (JSONStreamAware.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, MiscCodec.instance);</span><br><span class="line">        &#125; else if (clazz.isEnum() || (clazz.getSuperclass() != null &amp;&amp; clazz.getSuperclass().isEnum())) &#123;</span><br><span class="line">            JSONType jsonType = clazz.getAnnotation(JSONType.class);</span><br><span class="line">            if (jsonType != null &amp;&amp; jsonType.serializeEnumAsJavaBean()) &#123;</span><br><span class="line">                put(clazz, createJavaBeanSerializer(clazz));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                put(clazz, EnumSerializer.instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (clazz.isArray()) &#123;</span><br><span class="line">            Class&lt;?&gt; componentType = clazz.getComponentType();</span><br><span class="line">            ObjectSerializer compObjectSerializer = getObjectWriter(componentType);</span><br><span class="line">            put(clazz, new ArraySerializer(componentType, compObjectSerializer));</span><br><span class="line">        &#125; else if (Throwable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            SerializeBeanInfo beanInfo = TypeUtils.buildBeanInfo(clazz, null, propertyNamingStrategy);</span><br><span class="line">            beanInfo.features |= SerializerFeature.WriteClassName.mask;</span><br><span class="line">            put(clazz, new JavaBeanSerializer(beanInfo));</span><br><span class="line">        &#125; else if (TimeZone.class.isAssignableFrom(clazz) || Map.Entry.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, MiscCodec.instance);</span><br><span class="line">        &#125; else if (Appendable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, AppendableSerializer.instance);</span><br><span class="line">        &#125; else if (Charset.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, ToStringSerializer.instance);</span><br><span class="line">        &#125; else if (Enumeration.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, EnumerationSerializer.instance);</span><br><span class="line">        &#125; else if (Calendar.class.isAssignableFrom(clazz) //</span><br><span class="line">                || XMLGregorianCalendar.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, CalendarCodec.instance);</span><br><span class="line">        &#125; else if (Clob.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, ClobSeriliazer.instance);</span><br><span class="line">        &#125; else if (TypeUtils.isPath(clazz)) &#123;</span><br><span class="line">            put(clazz, ToStringSerializer.instance);</span><br><span class="line">        &#125; else if (Iterator.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            put(clazz, MiscCodec.instance);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String className = clazz.getName();</span><br><span class="line">            if (className.startsWith(&quot;java.awt.&quot;) //</span><br><span class="line">                &amp;&amp; AwtCodec.support(clazz) //</span><br><span class="line">            ) &#123;</span><br><span class="line">                // awt</span><br><span class="line">                if (!awtError) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        put(Class.forName(&quot;java.awt.Color&quot;), AwtCodec.instance);</span><br><span class="line">                        put(Class.forName(&quot;java.awt.Font&quot;), AwtCodec.instance);</span><br><span class="line">                        put(Class.forName(&quot;java.awt.Point&quot;), AwtCodec.instance);</span><br><span class="line">                        put(Class.forName(&quot;java.awt.Rectangle&quot;), AwtCodec.instance);</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                        awtError = true;</span><br><span class="line">                        // skip</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return  AwtCodec.instance;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // jdk8</span><br><span class="line">            if ((!jdk8Error) //</span><br><span class="line">                &amp;&amp; (className.startsWith(&quot;java.time.&quot;) //</span><br><span class="line">                    || className.startsWith(&quot;java.util.Optional&quot;) //</span><br><span class="line">                    || className.equals(&quot;java.util.concurrent.atomic.LongAdder&quot;)</span><br><span class="line">                    || className.equals(&quot;java.util.concurrent.atomic.DoubleAdder&quot;)</span><br><span class="line">                )) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    put(Class.forName(&quot;java.time.LocalDateTime&quot;), Jdk8DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.time.LocalDate&quot;), Jdk8DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.time.LocalTime&quot;), Jdk8DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.time.ZonedDateTime&quot;), Jdk8DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.time.OffsetDateTime&quot;), Jdk8DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.time.OffsetTime&quot;), Jdk8DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.time.ZoneOffset&quot;), Jdk8DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.time.ZoneRegion&quot;), Jdk8DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.time.Period&quot;), Jdk8DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.time.Duration&quot;), Jdk8DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.time.Instant&quot;), Jdk8DateCodec.instance);</span><br><span class="line"></span><br><span class="line">                    put(Class.forName(&quot;java.util.Optional&quot;), OptionalCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.util.OptionalDouble&quot;), OptionalCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.util.OptionalInt&quot;), OptionalCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.util.OptionalLong&quot;), OptionalCodec.instance);</span><br><span class="line"></span><br><span class="line">                    put(Class.forName(&quot;java.util.concurrent.atomic.LongAdder&quot;), AdderSerializer.instance);</span><br><span class="line">                    put(Class.forName(&quot;java.util.concurrent.atomic.DoubleAdder&quot;), AdderSerializer.instance);</span><br><span class="line">                    </span><br><span class="line">                    writer = serializers.get(clazz);</span><br><span class="line">                    if (writer != null) &#123;</span><br><span class="line">                        return writer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    // skip</span><br><span class="line">                    jdk8Error = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if ((!oracleJdbcError) //</span><br><span class="line">                &amp;&amp; className.startsWith(&quot;oracle.sql.&quot;)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    put(Class.forName(&quot;oracle.sql.DATE&quot;), DateCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;oracle.sql.TIMESTAMP&quot;), DateCodec.instance);</span><br><span class="line">                    </span><br><span class="line">                    writer = serializers.get(clazz);</span><br><span class="line">                    if (writer != null) &#123;</span><br><span class="line">                        return writer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    // skip</span><br><span class="line">                    oracleJdbcError = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if ((!springfoxError) //</span><br><span class="line">                &amp;&amp; className.equals(&quot;springfox.documentation.spring.web.json.Json&quot;)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    put(Class.forName(&quot;springfox.documentation.spring.web.json.Json&quot;), //</span><br><span class="line">                        SwaggerJsonSerializer.instance);</span><br><span class="line">                    </span><br><span class="line">                    writer = serializers.get(clazz);</span><br><span class="line">                    if (writer != null) &#123;</span><br><span class="line">                        return writer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // skip</span><br><span class="line">                    springfoxError = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((!guavaError) //</span><br><span class="line">                    &amp;&amp; className.startsWith(&quot;com.google.common.collect.&quot;)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    put(Class.forName(&quot;com.google.common.collect.HashMultimap&quot;), //</span><br><span class="line">                            GuavaCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;com.google.common.collect.LinkedListMultimap&quot;), //</span><br><span class="line">                            GuavaCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;com.google.common.collect.ArrayListMultimap&quot;), //</span><br><span class="line">                            GuavaCodec.instance);</span><br><span class="line">                    put(Class.forName(&quot;com.google.common.collect.TreeMultimap&quot;), //</span><br><span class="line">                            GuavaCodec.instance);</span><br><span class="line"></span><br><span class="line">                    writer = serializers.get(clazz);</span><br><span class="line">                    if (writer != null) &#123;</span><br><span class="line">                        return writer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // skip</span><br><span class="line">                    guavaError = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (className.equals(&quot;net.sf.json.JSONNull&quot;)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    put(Class.forName(&quot;net.sf.json.JSONNull&quot;), //</span><br><span class="line">                            MiscCodec.instance);</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // skip</span><br><span class="line">                &#125;</span><br><span class="line">                writer = serializers.get(clazz);</span><br><span class="line">                if (writer != null) &#123;</span><br><span class="line">                    return writer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (TypeUtils.isProxy(clazz)) &#123;</span><br><span class="line">                Class&lt;?&gt; superClazz = clazz.getSuperclass();</span><br><span class="line"></span><br><span class="line">                ObjectSerializer superWriter = getObjectWriter(superClazz);</span><br><span class="line">                put(clazz, superWriter);</span><br><span class="line">                return superWriter;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (create) &#123;</span><br><span class="line">                put(clazz, createJavaBeanSerializer(clazz));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer = serializers.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    return writer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单扫描代码逻辑，发现<code>writer</code>是通过<code>serializers.get(clazz)</code>获取的。而代码中分别从<code>Thread.currentThread().getContextClassLoader</code>、<code>JSON.class.getClassLoader</code>以及最后对一下常见类分析来填充<code>serializers</code>。最后一种办法的末尾，走到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put(clazz, createJavaBeanSerializer(clazz));</span><br></pre></td></tr></table></figure>
<p>可以发现逻辑是实在找不到，使用<code>createJavaBeanSerializer(clazz)</code>来创建<code>clazz</code>对应的<code>writer</code>。看来我们的目标应该是这个<code>createJavaBeanSerializer</code>函数，所以进一步深入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final ObjectSerializer createJavaBeanSerializer(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">    SerializeBeanInfo beanInfo = TypeUtils.buildBeanInfo(clazz, null, propertyNamingStrategy, fieldBased);</span><br><span class="line">    if (beanInfo.fields.length == 0 &amp;&amp; Iterable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        return MiscCodec.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return createJavaBeanSerializer(beanInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用<code>TypeUtils.buildBeanInfo</code>来生成<code>SerializerBeanInfo</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public static SerializeBeanInfo buildBeanInfo(Class&lt;?&gt; beanType //</span><br><span class="line">        , Map&lt;String, String&gt; aliasMap //</span><br><span class="line">        , PropertyNamingStrategy propertyNamingStrategy //</span><br><span class="line">        , boolean fieldBased //</span><br><span class="line">) &#123;</span><br><span class="line">    </span><br><span class="line">    JSONType jsonType = beanType.getAnnotation(JSONType.class);</span><br><span class="line"></span><br><span class="line">    // fieldName,field ，先生成fieldName的快照，减少之后的findField的轮询</span><br><span class="line">    Map&lt;String, Field&gt; fieldCacheMap = new HashMap&lt;String, Field&gt;();</span><br><span class="line">    ParserConfig.parserAllFieldToCache(beanType, fieldCacheMap);</span><br><span class="line"></span><br><span class="line">    List&lt;FieldInfo&gt; fieldInfoList = fieldBased</span><br><span class="line">            ? computeGettersWithFieldBase(beanType, aliasMap, false, propertyNamingStrategy) //</span><br><span class="line">            : computeGetters(beanType, jsonType, aliasMap, fieldCacheMap, false, propertyNamingStrategy);</span><br><span class="line">    FieldInfo[] fields = new FieldInfo[fieldInfoList.size()];</span><br><span class="line">    fieldInfoList.toArray(fields);</span><br><span class="line">    </span><br><span class="line">    String[] orders = null;</span><br><span class="line"></span><br><span class="line">    final int features;</span><br><span class="line">    String typeName = null;</span><br><span class="line">    if (jsonType != null) &#123;</span><br><span class="line">        orders = jsonType.orders();</span><br><span class="line">        typeName = jsonType.typeName();</span><br><span class="line">        if (typeName.length() == 0) &#123;</span><br><span class="line">            typeName = null;</span><br><span class="line">        &#125;</span><br><span class="line">        features = SerializerFeature.of(jsonType.serialzeFeatures());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        features = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FieldInfo[] sortedFields;</span><br><span class="line">    List&lt;FieldInfo&gt; sortedFieldList;</span><br><span class="line">    if (orders != null &amp;&amp; orders.length != 0) &#123;</span><br><span class="line">        sortedFieldList = fieldBased</span><br><span class="line">                ? computeGettersWithFieldBase(beanType, aliasMap, true, propertyNamingStrategy) //</span><br><span class="line">                : computeGetters(beanType, jsonType, aliasMap,fieldCacheMap, true, propertyNamingStrategy);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sortedFieldList = new ArrayList&lt;FieldInfo&gt;(fieldInfoList);</span><br><span class="line">        Collections.sort(sortedFieldList);</span><br><span class="line">    &#125;</span><br><span class="line">    sortedFields = new FieldInfo[sortedFieldList.size()];</span><br><span class="line">    sortedFieldList.toArray(sortedFields);</span><br><span class="line">    </span><br><span class="line">    if (Arrays.equals(sortedFields, fields)) &#123;</span><br><span class="line">        sortedFields = fields;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return new SerializeBeanInfo(beanType, jsonType, typeName, features, fields, sortedFields);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>parserAllFieldToCache</code>将字段保存起来，减少访问次数。紧接着设置<code>fieldInfoList</code>的值，此时<code>fieldBase</code>为<code>false</code>，所以进入了<code>computeGetters</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;FieldInfo&gt; computeGetters(Class&lt;?&gt; clazz, //</span><br><span class="line">                                            JSONType jsonType, //</span><br><span class="line">                                            Map&lt;String, String&gt; aliasMap, //</span><br><span class="line">                                            Map&lt;String, Field&gt; fieldCacheMap, //</span><br><span class="line">                                            boolean sorted, //</span><br><span class="line">                                            PropertyNamingStrategy propertyNamingStrategy //</span><br><span class="line">) &#123;</span><br><span class="line">    Map&lt;String, FieldInfo&gt; fieldInfoMap = new LinkedHashMap&lt;String, FieldInfo&gt;();</span><br><span class="line"></span><br><span class="line">    for (Method method : clazz.getMethods()) &#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        int ordinal = 0, serialzeFeatures = 0, parserFeatures = 0;</span><br><span class="line">        String label = null;</span><br><span class="line"></span><br><span class="line">        if (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (method.getParameterTypes().length != 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (method.getReturnType() == ClassLoader.class) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (method.getName().equals(&quot;getMetaClass&quot;)</span><br><span class="line">            &amp;&amp; method.getReturnType().getName().equals(&quot;groovy.lang.MetaClass&quot;)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JSONField annotation = method.getAnnotation(JSONField.class);</span><br><span class="line"></span><br><span class="line">        if (annotation == null) &#123;</span><br><span class="line">            annotation = getSuperMethodAnnotation(clazz, method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (annotation != null) &#123;</span><br><span class="line">            if (!annotation.serialize()) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ordinal = annotation.ordinal();</span><br><span class="line">            serialzeFeatures = SerializerFeature.of(annotation.serialzeFeatures());</span><br><span class="line">            parserFeatures = Feature.of(annotation.parseFeatures());</span><br><span class="line"></span><br><span class="line">            if (annotation.name().length() != 0) &#123;</span><br><span class="line">                String propertyName = annotation.name();</span><br><span class="line"></span><br><span class="line">                if (aliasMap != null) &#123;</span><br><span class="line">                    propertyName = aliasMap.get(propertyName);</span><br><span class="line">                    if (propertyName == null) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                FieldInfo fieldInfo = new FieldInfo(propertyName, method, null, clazz, null, ordinal,</span><br><span class="line">                                                    serialzeFeatures, parserFeatures, annotation, null, label);</span><br><span class="line">                fieldInfoMap.put(propertyName, fieldInfo);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (annotation.label().length() != 0) &#123;</span><br><span class="line">                label = annotation.label();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (methodName.startsWith(&quot;get&quot;)) &#123;</span><br><span class="line">            if (methodName.length() &lt; 4) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (methodName.equals(&quot;getClass&quot;)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (methodName.equals(&quot;getDeclaringClass&quot;) &amp;&amp; clazz.isEnum()) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            char c3 = methodName.charAt(3);</span><br><span class="line"></span><br><span class="line">            String propertyName;</span><br><span class="line">            if (Character.isUpperCase(c3) //</span><br><span class="line">                || c3 &gt; 512 // for unicode method name</span><br><span class="line">            ) &#123;</span><br><span class="line">            if (compatibleWithJavaBean) &#123;</span><br><span class="line">                    propertyName = decapitalize(methodName.substring(3));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    propertyName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);</span><br><span class="line">                &#125;</span><br><span class="line">                propertyName = getPropertyNameByCompatibleFieldName(fieldCacheMap, methodName,  propertyName,3);</span><br><span class="line">            &#125; else if (c3 == &apos;_&apos;) &#123;</span><br><span class="line">                propertyName = methodName.substring(4);</span><br><span class="line">            &#125; else if (c3 == &apos;f&apos;) &#123;</span><br><span class="line">                propertyName = methodName.substring(3);</span><br><span class="line">            &#125; else if (methodName.length() &gt;= 5 &amp;&amp; Character.isUpperCase(methodName.charAt(4))) &#123;</span><br><span class="line">                propertyName = decapitalize(methodName.substring(3));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean ignore = isJSONTypeIgnore(clazz, propertyName);</span><br><span class="line"></span><br><span class="line">            if (ignore) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //假如bean的field很多的情况一下，轮询时将大大降低效率</span><br><span class="line">            Field field = ParserConfig.getFieldFromCache(propertyName, fieldCacheMap);</span><br><span class="line"></span><br><span class="line">            if (field == null &amp;&amp; propertyName.length() &gt; 1) &#123;</span><br><span class="line">                char ch = propertyName.charAt(1);</span><br><span class="line">                if (ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;) &#123;</span><br><span class="line">                    String javaBeanCompatiblePropertyName = decapitalize(methodName.substring(3));</span><br><span class="line">                    field = ParserConfig.getFieldFromCache(javaBeanCompatiblePropertyName, fieldCacheMap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            JSONField fieldAnnotation = null;</span><br><span class="line">            if (field != null) &#123;</span><br><span class="line">                fieldAnnotation = field.getAnnotation(JSONField.class);</span><br><span class="line"></span><br><span class="line">                if (fieldAnnotation != null) &#123;</span><br><span class="line">                    if (!fieldAnnotation.serialize()) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ordinal = fieldAnnotation.ordinal();</span><br><span class="line">                    serialzeFeatures = SerializerFeature.of(fieldAnnotation.serialzeFeatures());</span><br><span class="line">                    parserFeatures = Feature.of(fieldAnnotation.parseFeatures());</span><br><span class="line"></span><br><span class="line">                    if (fieldAnnotation.name().length() != 0) &#123;</span><br><span class="line">                        propertyName = fieldAnnotation.name();</span><br><span class="line"></span><br><span class="line">                        if (aliasMap != null) &#123;</span><br><span class="line">                            propertyName = aliasMap.get(propertyName);</span><br><span class="line">                            if (propertyName == null) &#123;</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (fieldAnnotation.label().length() != 0) &#123;</span><br><span class="line">                        label = fieldAnnotation.label();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (aliasMap != null) &#123;</span><br><span class="line">                propertyName = aliasMap.get(propertyName);</span><br><span class="line">                if (propertyName == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (propertyNamingStrategy != null) &#123;</span><br><span class="line">                propertyName = propertyNamingStrategy.translate(propertyName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FieldInfo fieldInfo = new FieldInfo(propertyName, method, field, clazz, null, ordinal, serialzeFeatures, parserFeatures,</span><br><span class="line">                                                annotation, fieldAnnotation, label);</span><br><span class="line">            fieldInfoMap.put(propertyName, fieldInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (methodName.startsWith(&quot;is&quot;)) &#123;</span><br><span class="line">            if (methodName.length() &lt; 3) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (method.getReturnType() != Boolean.TYPE</span><br><span class="line">                    &amp;&amp; method.getReturnType() != Boolean.class) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            char c2 = methodName.charAt(2);</span><br><span class="line"></span><br><span class="line">            String propertyName;</span><br><span class="line">            if (Character.isUpperCase(c2)) &#123;</span><br><span class="line">                if (compatibleWithJavaBean) &#123;</span><br><span class="line">                    propertyName = decapitalize(methodName.substring(2));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    propertyName = Character.toLowerCase(methodName.charAt(2)) + methodName.substring(3);</span><br><span class="line">                &#125;</span><br><span class="line">                propertyName = getPropertyNameByCompatibleFieldName(fieldCacheMap, methodName,  propertyName,2);</span><br><span class="line">            &#125; else if (c2 == &apos;_&apos;) &#123;</span><br><span class="line">                propertyName = methodName.substring(3);</span><br><span class="line">            &#125; else if (c2 == &apos;f&apos;) &#123;</span><br><span class="line">                propertyName = methodName.substring(2);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean ignore = isJSONTypeIgnore(clazz, propertyName);</span><br><span class="line"></span><br><span class="line">            if (ignore) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Field field = ParserConfig.getFieldFromCache(propertyName,fieldCacheMap);</span><br><span class="line"></span><br><span class="line">            if (field == null) &#123;</span><br><span class="line">                field = ParserConfig.getFieldFromCache(methodName,fieldCacheMap);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            JSONField fieldAnnotation = null;</span><br><span class="line">            if (field != null) &#123;</span><br><span class="line">                fieldAnnotation = field.getAnnotation(JSONField.class);</span><br><span class="line"></span><br><span class="line">                if (fieldAnnotation != null) &#123;</span><br><span class="line">                    if (!fieldAnnotation.serialize()) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ordinal = fieldAnnotation.ordinal();</span><br><span class="line">                    serialzeFeatures = SerializerFeature.of(fieldAnnotation.serialzeFeatures());</span><br><span class="line">                    parserFeatures = Feature.of(fieldAnnotation.parseFeatures());</span><br><span class="line"></span><br><span class="line">                    if (fieldAnnotation.name().length() != 0) &#123;</span><br><span class="line">                        propertyName = fieldAnnotation.name();</span><br><span class="line"></span><br><span class="line">                        if (aliasMap != null) &#123;</span><br><span class="line">                            propertyName = aliasMap.get(propertyName);</span><br><span class="line">                            if (propertyName == null) &#123;</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (fieldAnnotation.label().length() != 0) &#123;</span><br><span class="line">                        label = fieldAnnotation.label();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (aliasMap != null) &#123;</span><br><span class="line">                propertyName = aliasMap.get(propertyName);</span><br><span class="line">                if (propertyName == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (propertyNamingStrategy != null) &#123;</span><br><span class="line">                propertyName = propertyNamingStrategy.translate(propertyName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //优先选择get</span><br><span class="line">            if (fieldInfoMap.containsKey(propertyName)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FieldInfo fieldInfo = new FieldInfo(propertyName, method, field, clazz, null, ordinal, serialzeFeatures, parserFeatures,</span><br><span class="line">                                                annotation, fieldAnnotation, label);</span><br><span class="line">            fieldInfoMap.put(propertyName, fieldInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    computeFields(clazz, aliasMap, propertyNamingStrategy, fieldInfoMap, fields);</span><br><span class="line"></span><br><span class="line">    return getFieldInfos(clazz, sorted, fieldInfoMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里针对<code>clazz</code>的每一个方法进行了判断，由于只有<code>get</code>和<code>set</code>开头的函数，所以只关心<code>methodName.startsWith(&quot;get&quot;)</code>分支。最后进入了<code>getPropertyNameByCompatibleFieldName</code>所在的分支，并将<code>propertyName</code>设置为对应<code>get</code>的属性名。在<code>getPropertyNameByCompatibleFieldName</code>函数中，而<code>compatibleWithFieldName</code>设置为<code>false</code>所以相当于跳过了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static String getPropertyNameByCompatibleFieldName(Map&lt;String, Field&gt; fieldCacheMap, String methodName,</span><br><span class="line">                                                            String propertyName,int fromIdx) &#123;</span><br><span class="line">    if (compatibleWithFieldName)&#123;</span><br><span class="line">            if (!fieldCacheMap.containsKey(propertyName))&#123;</span><br><span class="line">                String tempPropertyName=methodName.substring(fromIdx);</span><br><span class="line">                return  fieldCacheMap.containsKey(tempPropertyName)?tempPropertyName:propertyName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return propertyName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续分析，程序进入<code>isJSONTypeIgnore</code>根据注解判断是否跳过该字段，我的例子中不关心。紧接着调用了<code>getFieldFromCache</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static Field getFieldFromCache(String fieldName, Map&lt;String, Field&gt; fieldCacheMap) &#123;</span><br><span class="line">    Field field = fieldCacheMap.get(fieldName);</span><br><span class="line"></span><br><span class="line">    if (field == null) &#123;</span><br><span class="line">        field = fieldCacheMap.get(&quot;_&quot; + fieldName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (field == null) &#123;</span><br><span class="line">        field = fieldCacheMap.get(&quot;m_&quot; + fieldName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (field == null) &#123;</span><br><span class="line">        char c0 = fieldName.charAt(0);</span><br><span class="line">        if (c0 &gt;= &apos;a&apos; &amp;&amp; c0 &lt;= &apos;z&apos;) &#123;</span><br><span class="line">            char[] chars = fieldName.toCharArray();</span><br><span class="line">            chars[0] -= 32; // lower</span><br><span class="line">            String fieldNameX = new String(chars);</span><br><span class="line">            field = fieldCacheMap.get(fieldNameX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里按照刚才取出的方法名来查找字段，如果失败则加上<code>_</code>或者<code>m_</code>之类的方法继续判断。返回继续分析，在做了部分如注解别名之类的处理后，将分析得到的结果生成一个<code>FieldInfo</code>，并保存在<code>fieldInfoMap</code>中。最后调用<code>computeFields</code>进一步处理一些<code>public</code>属性的<code>fields</code>数据。最后经过<code>getFieldInfos</code>处理后，将得到的<code>List&lt;FieldInfo&gt;</code>中，返回上一级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private static void computeFields(</span><br><span class="line">        Class&lt;?&gt; clazz, //</span><br><span class="line">        Map&lt;String, String&gt; aliasMap, //</span><br><span class="line">        PropertyNamingStrategy propertyNamingStrategy, //</span><br><span class="line">        Map&lt;String, FieldInfo&gt; fieldInfoMap, //</span><br><span class="line">        Field[] fields) &#123;</span><br><span class="line"></span><br><span class="line">    for (Field field : fields) &#123;</span><br><span class="line">        if (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JSONField fieldAnnotation = field.getAnnotation(JSONField.class);</span><br><span class="line"></span><br><span class="line">        int ordinal = 0, serialzeFeatures = 0, parserFeatures = 0;</span><br><span class="line">        String propertyName = field.getName();</span><br><span class="line">        String label = null;</span><br><span class="line">        if (fieldAnnotation != null) &#123;</span><br><span class="line">            if (!fieldAnnotation.serialize()) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ordinal = fieldAnnotation.ordinal();</span><br><span class="line">            serialzeFeatures = SerializerFeature.of(fieldAnnotation.serialzeFeatures());</span><br><span class="line">            parserFeatures = Feature.of(fieldAnnotation.parseFeatures());</span><br><span class="line"></span><br><span class="line">            if (fieldAnnotation.name().length() != 0) &#123;</span><br><span class="line">                propertyName = fieldAnnotation.name();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fieldAnnotation.label().length() != 0) &#123;</span><br><span class="line">                label = fieldAnnotation.label();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (aliasMap != null) &#123;</span><br><span class="line">            propertyName = aliasMap.get(propertyName);</span><br><span class="line">            if (propertyName == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (propertyNamingStrategy != null) &#123;</span><br><span class="line">            propertyName = propertyNamingStrategy.translate(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!fieldInfoMap.containsKey(propertyName)) &#123;</span><br><span class="line">            FieldInfo fieldInfo = new FieldInfo(propertyName, null, field, clazz, null, ordinal, serialzeFeatures, parserFeatures,</span><br><span class="line">                                                null, fieldAnnotation, label);</span><br><span class="line">            fieldInfoMap.put(propertyName, fieldInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析到这里，可以发现在<code>fieldInfoList</code>中实际上值：<code>name</code>,<code>json</code>。看到这里相比也能猜出大概了，现在继续跟踪。回到<code>buildBeanInfo</code>中，将刚才得到的<code>fieldInfoList</code>构造为<code>SerializeBeanInfo</code>并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">public ObjectSerializer createJavaBeanSerializer(SerializeBeanInfo beanInfo) &#123;</span><br><span class="line">    JSONType jsonType = beanInfo.jsonType;</span><br><span class="line">    </span><br><span class="line">    if (jsonType != null) &#123;</span><br><span class="line">        Class&lt;?&gt; serializerClass = jsonType.serializer();</span><br><span class="line">        if (serializerClass != Void.class) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Object seralizer = serializerClass.newInstance();</span><br><span class="line">                if (seralizer instanceof ObjectSerializer) &#123;</span><br><span class="line">                    return (ObjectSerializer) seralizer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                // skip</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (jsonType.asm() == false) &#123;</span><br><span class="line">            asm = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (SerializerFeature feature : jsonType.serialzeFeatures()) &#123;</span><br><span class="line">            if (SerializerFeature.WriteNonStringValueAsString == feature //</span><br><span class="line">                    || SerializerFeature.WriteEnumUsingToString == feature //</span><br><span class="line">                    || SerializerFeature.NotWriteDefaultValue == feature) &#123;</span><br><span class="line">                asm = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; clazz = beanInfo.beanType;</span><br><span class="line">    if (!Modifier.isPublic(beanInfo.beanType.getModifiers())) &#123;</span><br><span class="line">        return new JavaBeanSerializer(beanInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean asm = this.asm &amp;&amp; !fieldBased;</span><br><span class="line"></span><br><span class="line">    if (asm &amp;&amp; asmFactory.classLoader.isExternalClass(clazz)</span><br><span class="line">            || clazz == Serializable.class || clazz == Object.class) &#123;</span><br><span class="line">        asm = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (asm &amp;&amp; !ASMUtils.checkName(clazz.getSimpleName())) &#123;</span><br><span class="line">        asm = false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (asm) &#123;</span><br><span class="line">        for(FieldInfo fieldInfo : beanInfo.fields)&#123;</span><br><span class="line">            Field field = fieldInfo.field;</span><br><span class="line">            if (field != null &amp;&amp; !field.getType().equals(fieldInfo.fieldClass)) &#123;</span><br><span class="line">                asm = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Method method = fieldInfo.method;</span><br><span class="line">            if (method != null &amp;&amp; !method.getReturnType().equals(fieldInfo.fieldClass)) &#123;</span><br><span class="line">                asm = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            JSONField annotation = fieldInfo.getAnnotation();</span><br><span class="line">            </span><br><span class="line">            if (annotation == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ((!ASMUtils.checkName(annotation.name())) //</span><br><span class="line">                    || annotation.format().length() != 0</span><br><span class="line">                    || annotation.jsonDirect()</span><br><span class="line">                    || annotation.serializeUsing() != Void.class</span><br><span class="line">                    || annotation.unwrapped()</span><br><span class="line">                    ) &#123;</span><br><span class="line">                asm = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (SerializerFeature feature : annotation.serialzeFeatures()) &#123;</span><br><span class="line">                if (SerializerFeature.WriteNonStringValueAsString == feature //</span><br><span class="line">                        || SerializerFeature.WriteEnumUsingToString == feature //</span><br><span class="line">                        || SerializerFeature.NotWriteDefaultValue == feature) &#123;</span><br><span class="line">                    asm = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (asm) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectSerializer asmSerializer = createASMSerializer(beanInfo);</span><br><span class="line">            if (asmSerializer != null) &#123;</span><br><span class="line">                return asmSerializer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">            // skip</span><br><span class="line">        &#125; catch (ClassCastException e) &#123;</span><br><span class="line">            // skip</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new JSONException(&quot;create asm serializer error, class &quot;</span><br><span class="line">                    + clazz, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new JavaBeanSerializer(beanInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过处理后进入了<code>createASMSerializer</code>，其中调用<code>createJavaBeanSerializer</code>来创建具体的<code>writer</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line">public JavaBeanSerializer createJavaBeanSerializer(SerializeBeanInfo beanInfo) throws Exception &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = beanInfo.beanType;</span><br><span class="line">    if (clazz.isPrimitive()) &#123;</span><br><span class="line">        throw new JSONException(&quot;unsupportd class &quot; + clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JSONType jsonType = clazz.getAnnotation(JSONType.class);</span><br><span class="line"></span><br><span class="line">    FieldInfo[] unsortedGetters = beanInfo.fields;;</span><br><span class="line"></span><br><span class="line">    for (FieldInfo fieldInfo : unsortedGetters) &#123;</span><br><span class="line">        if (fieldInfo.field == null //</span><br><span class="line">            &amp;&amp; fieldInfo.method != null //</span><br><span class="line">            &amp;&amp; fieldInfo.method.getDeclaringClass().isInterface()) &#123;</span><br><span class="line">            return new JavaBeanSerializer(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FieldInfo[] getters = beanInfo.sortedFields;</span><br><span class="line"></span><br><span class="line">    boolean nativeSorted = beanInfo.sortedFields == beanInfo.fields;</span><br><span class="line"></span><br><span class="line">    if (getters.length &gt; 256) &#123;</span><br><span class="line">        return new JavaBeanSerializer(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (FieldInfo getter : getters) &#123;</span><br><span class="line">        if (!ASMUtils.checkName(getter.getMember().getName())) &#123;</span><br><span class="line">            return new JavaBeanSerializer(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String className = &quot;ASMSerializer_&quot; + seed.incrementAndGet() + &quot;_&quot; + clazz.getSimpleName();</span><br><span class="line">    String packageName = ASMSerializerFactory.class.getPackage().getName();</span><br><span class="line">    String classNameType = packageName.replace(&apos;.&apos;, &apos;/&apos;) + &quot;/&quot; + className;</span><br><span class="line">    String classNameFull = packageName + &quot;.&quot; + className;</span><br><span class="line"></span><br><span class="line">    ClassWriter cw = new ClassWriter();</span><br><span class="line">    cw.visit(V1_5 //</span><br><span class="line">                , ACC_PUBLIC + ACC_SUPER //</span><br><span class="line">                , classNameType //</span><br><span class="line">                , JavaBeanSerializer //</span><br><span class="line">                , new String[] &#123; ObjectSerializer &#125; //</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    for (FieldInfo fieldInfo : getters) &#123;</span><br><span class="line">        if (fieldInfo.fieldClass.isPrimitive() //</span><br><span class="line">            //|| fieldInfo.fieldClass.isEnum() //</span><br><span class="line">            || fieldInfo.fieldClass == String.class) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new FieldWriter(cw, ACC_PUBLIC, fieldInfo.name + &quot;_asm_fieldType&quot;, &quot;Ljava/lang/reflect/Type;&quot;) //</span><br><span class="line">                                                                                                        .visitEnd();</span><br><span class="line"></span><br><span class="line">        if (List.class.isAssignableFrom(fieldInfo.fieldClass)) &#123;</span><br><span class="line">            new FieldWriter(cw, ACC_PUBLIC, fieldInfo.name + &quot;_asm_list_item_ser_&quot;,</span><br><span class="line">                            ObjectSerializer_desc) //</span><br><span class="line">                                                    .visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new FieldWriter(cw, ACC_PUBLIC, fieldInfo.name + &quot;_asm_ser_&quot;, ObjectSerializer_desc) //</span><br><span class="line">                                                                                                    .visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MethodVisitor mw = new MethodWriter(cw, ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;(&quot; + desc(SerializeBeanInfo.class) + &quot;)V&quot;, null, null);</span><br><span class="line">    mw.visitVarInsn(ALOAD, 0);</span><br><span class="line">    mw.visitVarInsn(ALOAD, 1);</span><br><span class="line">    mw.visitMethodInsn(INVOKESPECIAL, JavaBeanSerializer, &quot;&lt;init&gt;&quot;, &quot;(&quot; + desc(SerializeBeanInfo.class) + &quot;)V&quot;);</span><br><span class="line"></span><br><span class="line">    // init _asm_fieldType</span><br><span class="line">    for (int i = 0; i &lt; getters.length; ++i) &#123;</span><br><span class="line">        FieldInfo fieldInfo = getters[i];</span><br><span class="line">        if (fieldInfo.fieldClass.isPrimitive() //</span><br><span class="line">//                || fieldInfo.fieldClass.isEnum() //</span><br><span class="line">            || fieldInfo.fieldClass == String.class) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mw.visitVarInsn(ALOAD, 0);</span><br><span class="line"></span><br><span class="line">        if (fieldInfo.method != null) &#123;</span><br><span class="line">            mw.visitLdcInsn(com.alibaba.fastjson.asm.Type.getType(desc(fieldInfo.declaringClass)));</span><br><span class="line">            mw.visitLdcInsn(fieldInfo.method.getName());</span><br><span class="line">            mw.visitMethodInsn(INVOKESTATIC, type(ASMUtils.class), &quot;getMethodType&quot;,</span><br><span class="line">                                &quot;(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/reflect/Type;&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mw.visitVarInsn(ALOAD, 0);</span><br><span class="line">            mw.visitLdcInsn(i);</span><br><span class="line">            mw.visitMethodInsn(INVOKESPECIAL, JavaBeanSerializer, &quot;getFieldType&quot;, &quot;(I)Ljava/lang/reflect/Type;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mw.visitFieldInsn(PUTFIELD, classNameType, fieldInfo.name + &quot;_asm_fieldType&quot;, &quot;Ljava/lang/reflect/Type;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mw.visitInsn(RETURN);</span><br><span class="line">    mw.visitMaxs(4, 4);</span><br><span class="line">    mw.visitEnd();</span><br><span class="line"></span><br><span class="line">    boolean DisableCircularReferenceDetect = false;</span><br><span class="line">    if (jsonType != null) &#123;</span><br><span class="line">        for (SerializerFeature featrues : jsonType.serialzeFeatures()) &#123;</span><br><span class="line">            if (featrues == SerializerFeature.DisableCircularReferenceDetect) &#123;</span><br><span class="line">                DisableCircularReferenceDetect = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 0 write</span><br><span class="line">    // 1 writeNormal</span><br><span class="line">    // 2 writeNonContext</span><br><span class="line">    for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">        String methodName;</span><br><span class="line">        boolean nonContext = DisableCircularReferenceDetect;</span><br><span class="line">        boolean writeDirect = false;</span><br><span class="line">        if (i == 0) &#123;</span><br><span class="line">            methodName = &quot;write&quot;;</span><br><span class="line">            writeDirect = true;</span><br><span class="line">        &#125; else if (i == 1) &#123;</span><br><span class="line">            methodName = &quot;writeNormal&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            writeDirect = true;</span><br><span class="line">            nonContext = true;</span><br><span class="line">            methodName = &quot;writeDirectNonContext&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Context context = new Context(getters, beanInfo, classNameType, writeDirect,</span><br><span class="line">                                        nonContext);</span><br><span class="line"></span><br><span class="line">        mw = new MethodWriter(cw, //</span><br><span class="line">                                ACC_PUBLIC, //</span><br><span class="line">                                methodName, //</span><br><span class="line">                                &quot;(L&quot; + JSONSerializer</span><br><span class="line">                                            + &quot;;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;I)V&quot;, //</span><br><span class="line">                                null, //</span><br><span class="line">                                new String[] &#123; &quot;java/io/IOException&quot; &#125; //</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            Label endIf_ = new Label();</span><br><span class="line">            mw.visitVarInsn(ALOAD, Context.obj);</span><br><span class="line">            //serializer.writeNull();</span><br><span class="line">            mw.visitJumpInsn(IFNONNULL, endIf_);</span><br><span class="line">            mw.visitVarInsn(ALOAD, Context.serializer);</span><br><span class="line">            mw.visitMethodInsn(INVOKEVIRTUAL, JSONSerializer,</span><br><span class="line">                    &quot;writeNull&quot;, &quot;()V&quot;);</span><br><span class="line"></span><br><span class="line">            mw.visitInsn(RETURN);</span><br><span class="line">            mw.visitLabel(endIf_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mw.visitVarInsn(ALOAD, Context.serializer);</span><br><span class="line">        mw.visitFieldInsn(GETFIELD, JSONSerializer, &quot;out&quot;, SerializeWriter_desc);</span><br><span class="line">        mw.visitVarInsn(ASTORE, context.var(&quot;out&quot;));</span><br><span class="line"></span><br><span class="line">        if ((!nativeSorted) //</span><br><span class="line">            &amp;&amp; !context.writeDirect) &#123;</span><br><span class="line"></span><br><span class="line">            if (jsonType == null || jsonType.alphabetic()) &#123;</span><br><span class="line">                Label _else = new Label();</span><br><span class="line"></span><br><span class="line">                mw.visitVarInsn(ALOAD, context.var(&quot;out&quot;));</span><br><span class="line">                mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, &quot;isSortField&quot;, &quot;()Z&quot;);</span><br><span class="line"></span><br><span class="line">                mw.visitJumpInsn(IFNE, _else);</span><br><span class="line">                mw.visitVarInsn(ALOAD, 0);</span><br><span class="line">                mw.visitVarInsn(ALOAD, 1);</span><br><span class="line">                mw.visitVarInsn(ALOAD, 2);</span><br><span class="line">                mw.visitVarInsn(ALOAD, 3);</span><br><span class="line">                mw.visitVarInsn(ALOAD, 4);</span><br><span class="line">                mw.visitVarInsn(ILOAD, 5);</span><br><span class="line">                mw.visitMethodInsn(INVOKEVIRTUAL, classNameType,</span><br><span class="line">                                    &quot;writeUnsorted&quot;, &quot;(L&quot; + JSONSerializer</span><br><span class="line">                                                    + &quot;;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;I)V&quot;);</span><br><span class="line">                mw.visitInsn(RETURN);</span><br><span class="line"></span><br><span class="line">                mw.visitLabel(_else);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // isWriteDoubleQuoteDirect</span><br><span class="line">        if (context.writeDirect &amp;&amp; !nonContext) &#123;</span><br><span class="line">            Label _direct = new Label();</span><br><span class="line">            Label _directElse = new Label();</span><br><span class="line"></span><br><span class="line">            mw.visitVarInsn(ALOAD, 0);</span><br><span class="line">            mw.visitVarInsn(ALOAD, Context.serializer);</span><br><span class="line">            mw.visitMethodInsn(INVOKEVIRTUAL, JavaBeanSerializer, &quot;writeDirect&quot;, &quot;(L&quot; + JSONSerializer + &quot;;)Z&quot;);</span><br><span class="line">            mw.visitJumpInsn(IFNE, _directElse);</span><br><span class="line"></span><br><span class="line">            mw.visitVarInsn(ALOAD, 0);</span><br><span class="line">            mw.visitVarInsn(ALOAD, 1);</span><br><span class="line">            mw.visitVarInsn(ALOAD, 2);</span><br><span class="line">            mw.visitVarInsn(ALOAD, 3);</span><br><span class="line">            mw.visitVarInsn(ALOAD, 4);</span><br><span class="line">            mw.visitVarInsn(ILOAD, 5);</span><br><span class="line">            mw.visitMethodInsn(INVOKEVIRTUAL, classNameType,</span><br><span class="line">                                &quot;writeNormal&quot;, &quot;(L&quot; + JSONSerializer</span><br><span class="line">                                                + &quot;;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;I)V&quot;);</span><br><span class="line">            mw.visitInsn(RETURN);</span><br><span class="line"></span><br><span class="line">            mw.visitLabel(_directElse);</span><br><span class="line">            mw.visitVarInsn(ALOAD, context.var(&quot;out&quot;));</span><br><span class="line">            mw.visitLdcInsn(SerializerFeature.DisableCircularReferenceDetect.mask);</span><br><span class="line">            mw.visitMethodInsn(INVOKEVIRTUAL, SerializeWriter, &quot;isEnabled&quot;, &quot;(I)Z&quot;);</span><br><span class="line">            mw.visitJumpInsn(IFEQ, _direct);</span><br><span class="line"></span><br><span class="line">            mw.visitVarInsn(ALOAD, 0);</span><br><span class="line">            mw.visitVarInsn(ALOAD, 1);</span><br><span class="line">            mw.visitVarInsn(ALOAD, 2);</span><br><span class="line">            mw.visitVarInsn(ALOAD, 3);</span><br><span class="line">            mw.visitVarInsn(ALOAD, 4);</span><br><span class="line">            mw.visitVarInsn(ILOAD, 5);</span><br><span class="line">            mw.visitMethodInsn(INVOKEVIRTUAL, classNameType, &quot;writeDirectNonContext&quot;,</span><br><span class="line">                                &quot;(L&quot; + JSONSerializer + &quot;;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;I)V&quot;);</span><br><span class="line">            mw.visitInsn(RETURN);</span><br><span class="line"></span><br><span class="line">            mw.visitLabel(_direct);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mw.visitVarInsn(ALOAD, Context.obj); // obj</span><br><span class="line">        mw.visitTypeInsn(CHECKCAST, type(clazz)); // serializer</span><br><span class="line">        mw.visitVarInsn(ASTORE, context.var(&quot;entity&quot;)); // obj</span><br><span class="line">        generateWriteMethod(clazz, mw, getters, context);</span><br><span class="line">        mw.visitInsn(RETURN);</span><br><span class="line">        mw.visitMaxs(7, context.variantIndex + 2);</span><br><span class="line">        mw.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!nativeSorted) &#123;</span><br><span class="line">        // sortField support</span><br><span class="line">        Context context = new Context(getters, beanInfo, classNameType, false,</span><br><span class="line">                                        DisableCircularReferenceDetect);</span><br><span class="line"></span><br><span class="line">        mw = new MethodWriter(cw, ACC_PUBLIC, &quot;writeUnsorted&quot;,</span><br><span class="line">                                &quot;(L&quot; + JSONSerializer + &quot;;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;I)V&quot;,</span><br><span class="line">                                null, new String[] &#123; &quot;java/io/IOException&quot; &#125;);</span><br><span class="line"></span><br><span class="line">        mw.visitVarInsn(ALOAD, Context.serializer);</span><br><span class="line">        mw.visitFieldInsn(GETFIELD, JSONSerializer, &quot;out&quot;, SerializeWriter_desc);</span><br><span class="line">        mw.visitVarInsn(ASTORE, context.var(&quot;out&quot;));</span><br><span class="line"></span><br><span class="line">        mw.visitVarInsn(ALOAD, Context.obj); // obj</span><br><span class="line">        mw.visitTypeInsn(CHECKCAST, type(clazz)); // serializer</span><br><span class="line">        mw.visitVarInsn(ASTORE, context.var(&quot;entity&quot;)); // obj</span><br><span class="line"></span><br><span class="line">        generateWriteMethod(clazz, mw, unsortedGetters, context);</span><br><span class="line"></span><br><span class="line">        mw.visitInsn(RETURN);</span><br><span class="line">        mw.visitMaxs(7, context.variantIndex + 2);</span><br><span class="line">        mw.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 0 writeAsArray</span><br><span class="line">    // 1 writeAsArrayNormal</span><br><span class="line">    // 2 writeAsArrayNonContext</span><br><span class="line">    for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">        String methodName;</span><br><span class="line">        boolean nonContext = DisableCircularReferenceDetect;</span><br><span class="line">        boolean writeDirect = false;</span><br><span class="line">        if (i == 0) &#123;</span><br><span class="line">            methodName = &quot;writeAsArray&quot;;</span><br><span class="line">            writeDirect = true;</span><br><span class="line">        &#125; else if (i == 1) &#123;</span><br><span class="line">            methodName = &quot;writeAsArrayNormal&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            writeDirect = true;</span><br><span class="line">            nonContext = true;</span><br><span class="line">            methodName = &quot;writeAsArrayNonContext&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Context context = new Context(getters, beanInfo, classNameType, writeDirect,</span><br><span class="line">                                        nonContext);</span><br><span class="line"></span><br><span class="line">        mw = new MethodWriter(cw, ACC_PUBLIC, methodName,</span><br><span class="line">                                &quot;(L&quot; + JSONSerializer + &quot;;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;I)V&quot;,</span><br><span class="line">                                null, new String[] &#123; &quot;java/io/IOException&quot; &#125;);</span><br><span class="line"></span><br><span class="line">        mw.visitVarInsn(ALOAD, Context.serializer);</span><br><span class="line">        mw.visitFieldInsn(GETFIELD, JSONSerializer, &quot;out&quot;, SerializeWriter_desc);</span><br><span class="line">        mw.visitVarInsn(ASTORE, context.var(&quot;out&quot;));</span><br><span class="line"></span><br><span class="line">        mw.visitVarInsn(ALOAD, Context.obj); // obj</span><br><span class="line">        mw.visitTypeInsn(CHECKCAST, type(clazz)); // serializer</span><br><span class="line">        mw.visitVarInsn(ASTORE, context.var(&quot;entity&quot;)); // obj</span><br><span class="line">        generateWriteAsArray(clazz, mw, getters, context);</span><br><span class="line">        mw.visitInsn(RETURN);</span><br><span class="line">        mw.visitMaxs(7, context.variantIndex + 2);</span><br><span class="line">        mw.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    byte[] code = cw.toByteArray();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; exampleClass = classLoader.defineClassPublic(classNameFull, code, 0, code.length);</span><br><span class="line">    Constructor&lt;?&gt; constructor = exampleClass.getConstructor(SerializeBeanInfo.class);</span><br><span class="line">    Object instance = constructor.newInstance(beanInfo);</span><br><span class="line"></span><br><span class="line">    return (JavaBeanSerializer) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里为止，我们的分析就可以结束了，实际上这里是根据<code>fieldInfo</code>，通过CodeGen技术生成一个<code>writer</code>实例。而<code>getJson</code>被简单当作了<code>json</code>属性的<code>getter</code>，所以在<code>writer.write(object)</code>中调用了<code>getJson</code>从而出现了递归。那么这个问题的简单解决办法就是将<code>getJson</code>换个名字，比如<code>toJson</code>。最后，在github的issue中也翻到了一个对应的问题，作者给出的答案就是换个名字。</p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/5/2.png" alt="question"></p>
<p><img src="http://www.hashcoding.net/uploads/images/2017/5/3.png" alt="answer"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/05/07/C-C-调用约定/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/07/C-C-调用约定/" itemprop="url">C/C++ 调用约定</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-07T18:42:50+08:00">
                2017-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/07/C-C-调用约定/" class="leancloud_visitors" data-flag-title="C/C++ 调用约定">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>__cdecl</code> 是 C declaration 的缩写，表示 C 语言默认的函数调用方法：</p>
<ul>
<li>所有参数从右到左依次入栈，</li>
<li>参数由调用者清除，称为手动清栈</li>
<li>被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。</li>
</ul>
<p><code>__stdcall</code> 是 Standard Call 的缩写，是 C++ 的标准调用方式：</p>
<ul>
<li>所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是 this 指针。</li>
<li>这些堆栈中的参数由被调用的函数在返回后清除，使用的指令是 retn X，X 表示参数占用的字节数，CPU 在 ret 之后自动弹出 X 个字节的堆栈空间，称为自动清栈。</li>
<li>函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，不能少，否则返回后会出错。</li>
</ul>
<p><code>__pascal</code> 是 Pascal 语言（Delphi）的函数调用方式，也可以在 C/C++ 中使用，参数压栈顺序与前两者相反。返回时的清栈方式与 <code>__stdcall</code> 相同。</p>
<p><code>__fastcall</code> 是编译器指定的快速调用方式。由于大多数的函数参数个数很少，使用堆栈传递比较费时。因此 <code>__fastcall</code> 通常规定将前两个（或若干个）参数由寄存器传递，其余参数还是通过堆栈传递。不同编译器编译的程序规定的寄存器不同，返回方式和 <code>__stdcall</code> 相当。</p>
<p><code>__thiscall</code> 是为了解决类成员调用中 this 指针传递而规定的。<code>__thiscall</code> 要求把 this 指针放在特定寄存器中，该寄存器由编译器决定。VC 使用 ecx，Borland 的 C++ 编译器使用 eax。返回方式和 <code>__stdcall</code> 相当。</p>
<p><code>__fastcall</code> 和 <code>__thiscall</code> 涉及的寄存器由编译器决定，因此不能用作跨编译器的接口。所以 Windows 上的 COM 对象接口都定义为 <code>__stdcall</code> 调用方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.hashcoding.net/2017/05/07/SIMD-与编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Patrick">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/07/SIMD-与编程/" itemprop="url">SIMD 与编程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-07T14:33:49+08:00">
                2017-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/05/07/SIMD-与编程/" class="leancloud_visitors" data-flag-title="SIMD 与编程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SIMD-简介"><a href="#SIMD-简介" class="headerlink" title="SIMD 简介"></a>SIMD 简介</h1><p>在谈 SIMD 之前，不得不谈一谈计算机体系结构的分类。常见的体系结构分类方法有两种：冯氏分类法和 Flynn 分类法。</p>
<p>冯氏分类法使用系统的最大并行度对计算机进行分类。最大并行度的定义是：计算机系统在单位时间内能够处理的最大的二进制位数。</p>
<p>Flynn 分类法则是按照指令流和数据流的多倍性进行分类。在 Flynn 中有定义：</p>
<ul>
<li>指令流（instruction stream），即计算机执行的指令序列</li>
<li>数据流（data stream），即由指令流调用的数据序列</li>
<li>多倍性（multiplicity），即在系统受限的部件上，同时处于同一执行阶段的指令或数据的最大数目</li>
</ul>
<p>Flynn 把计算机系统结构分为4类：</p>
<ul>
<li>单指令流单数据流（single instruction stream single data stream, SISD)</li>
<li>单指令流多数据流（single instruction stream multiple data stream, SIMD)</li>
<li>多指令流单数据流（multiple instruction stream single data stream, MISD)</li>
<li>多指令流多数据流（multiple instruction stream multiple data stream, MIMD)</li>
</ul>
<p>其中 SIMD 就是今天的主角：单指令流多数据流是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。在微处理器中，单指令流多数据流技术则是一个控制器控制多个平行的处理微元。</p>
<p>SIMD 技术的关键是在一条单独的指令中同时执行多个运算操作，以增加处理器的吞吐量。为此，SIMD 结构的 CPU 有多个执行部件，但都在同一个指令部件的控制之下，中央控制器向各个处理单元发送指令，整个系统只要求有一个中央控制器，只要求存储一份程序，所有的计算都是同步的。</p>
<p>为了了解 SIMD 在性能上的优势，我们以加法指令为例进行说明：单指令流单数据流型 CPU 对加法指令译码后，执行部件先访问主存，取得第一个操作数，之后再一次访问主存，取得第二个操作数，随后才能进行求和运算；而在 SIMD 型 CPU 中，指令译码后，几个执行部件同时访问主存，一次性获得所有操作数进行运算。这一特点使得 SIMD 技术特别适合于多媒体应用等数据密集型运算，比如可以在 libx264、ffmpeg 等中看到其身影。</p>
<h1 id="SIMD-在现代处理器上的应用"><a href="#SIMD-在现代处理器上的应用" class="headerlink" title="SIMD 在现代处理器上的应用"></a>SIMD 在现代处理器上的应用</h1><p>SIMD 在现代处理器上得到了广泛的应用，其中 Intel 开发了 MMX、SSE、SSE2 等等，AMD 开发了 3D Now! ，而 neon 则是 ARM 在 Cortex-A 系列机上的 SIMD 支持。</p>
<h2 id="MMX"><a href="#MMX" class="headerlink" title="MMX"></a>MMX</h2><p>MMX 是 Intel 于1996年在奔腾上设计开发的 SIMD 支持，通过一次处理多个数据，增强了多媒体处理方面的能力。然而 MMX 占用浮点数寄存器进行运算，使得 MMX 指令和浮点操作指令不能同时运行，必须做密集的切换。</p>
<blockquote>
<p>MMX 寄存器，称作 MM0-MM7，实际上就是处理器内部 80 比特字长的浮点寄存器栈 st（0）到 st (7)的尾数部分（64 比特长）的复用。由于浮点栈寄存器的高16位未被 MMX 技术使用，因此这 16 位都置为 1，因此从栈寄存器的角度看，其浮点值为 NaN 或 Infinities，这可用于区分寄存器是处于浮点栈状态还是 MMX 状态。利用了装配数据类型（packed data type）的概念，每个 MMX 寄存器的 64 比特字长可以看作是 2 个 32 位整数、或者 4 个 16 位整数、或者 8 个 8 位整数，从而可以执行整数 SIMD 运算。</p>
</blockquote>
<h2 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h2><p>1999年，Intel在其Pentium III微处理器中集成了 SSE（Streaming SIMD Extensions）技术，有效增强了 CPU 浮点运算的能力。SSE兼容MMX指令，可以通过 SIMD 和单时钟周期并行处理多个浮点数据来有效提高浮点运算速度。具有 SSE 指令集支持的处理器有 8 个 128 位的寄存器，每一个寄存器可以存放 4 个单精度（32位）浮点数。SSE同时提供了一个指令集，其中的指令允许把浮点数加载到这些 128 位寄存器中，这些数就可以在这些寄存器中进行算术逻辑运算，然后把结果送回主存。也就是说，SSE 中的所有计算都可以针对 4 个浮点数一次性完成。</p>
<p>在 SSE 之后，Intel 对 SSE 进行了拓展。时至今日已经发展到了AVX（Advanced Vector Extensions）。</p>
<h2 id="3D-Now"><a href="#3D-Now" class="headerlink" title="3D Now!"></a>3D Now!</h2><p>3DNow!（据称是“3D No Waiting!”的缩写）是由AMD开发的一套SIMD多媒体指令集，支持单精度浮点数的矢量运算，用于增强x86架构的计算机在三维图像处理上的性能</p>
<h2 id="NEON"><a href="#NEON" class="headerlink" title="NEON"></a>NEON</h2><p>ARM CPU 最开始只有普通的寄存器，可以进行基本数据类型的基本运算。自 ARMv5 开始引入了 VFP（Vector Floating Point）指令，该指令用于向量化加速浮点运算。自ARMv7开始正式引入 NEON 指令，NEON 性能远超 VFP，因此 VFP 指令被废弃。</p>
<h1 id="SIMD-与编程"><a href="#SIMD-与编程" class="headerlink" title="SIMD 与编程"></a>SIMD 与编程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO: 自己都还没学会</span><br></pre></td></tr></table></figure>
<p>入门可以参考<a href="http://blog.csdn.net/gengshenghong/article/details/7007100" target="_blank" rel="noopener">在C/C++代码中使用SSE等指令集的指令(1)介绍</a></p>
<p>简单应用可以参考<a href="http://blog.csdn.net/housisong/article/details/1866970" target="_blank" rel="noopener">YUV视频格式到RGB32格式转换的速度优化 中篇</a></p>
<p>在 Intel 上与 SIMD 相关可以参考<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide" target="_blank" rel="noopener">Intel Intrinsics Guide</a>。</p>
<p>源码阅读可以参考<a href="https://github.com/Microsoft/DirectXMath" target="_blank" rel="noopener">DirectXMath</a>。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] 计算机系统结构 高等教育出版社 王志英<br>[2] <a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E6%8C%87%E4%BB%A4%E6%B5%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%B5%81" target="_blank" rel="noopener">单指令多数据流 - wiki</a><br>[3] <a href="http://share.onlinesjtu.com/mod/tab/view.php?id=303" target="_blank" rel="noopener">SIMD 技术 - 上海交通大学</a><br>[4] <a href="http://baike.baidu.com/link?url=q7oQjCLR8a8YYzM0tW5bUBln2J1rEKXXxjjhmv1eQoZYaJwMrOT8mp88qvXx1Q8_cnOh_WlsNS9XDbIRqLBbUK" target="_blank" rel="noopener">Neon ARM架构处理器扩展结构 - 百度百科</a><br>[5] <a href="https://zh.wikipedia.org/wiki/MMX" target="_blank" rel="noopener">MMX - wiki</a><br>[6] <a href="https://zh.wikipedia.org/wiki/SSE" target="_blank" rel="noopener">SSE - wiki</a><br>[7] <a href="https://zh.wikipedia.org/wiki/3DNow!" target="_blank" rel="noopener">3DNow! - wiki</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Patrick</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/thinkermao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Patrick</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("lMQDA5ivsWA2jcjJzTTImuvx-gzGzoHsz", "JIA0x48kG2WhEllWMb31Xt60");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
